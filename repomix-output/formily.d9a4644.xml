This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: docs/**/*.zh-CN.md, packages/{antd,react,core,reactive}/docs/**/*.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
docs/
  guide/
    advanced/
      async.zh-CN.md
      build.zh-CN.md
      business-logic.zh-CN.md
      calculator.zh-CN.md
      controlled.zh-CN.md
      custom.zh-CN.md
      destructor.zh-CN.md
      layout.zh-CN.md
      linkages.zh-CN.md
      validate.zh-CN.md
    scenes/
      dialog-drawer.zh-CN.md
      edit-detail.zh-CN.md
      login-register.zh-CN.md
      more.zh-CN.md
      query-list.zh-CN.md
      step-form.zh-CN.md
      tab-form.zh-CN.md
    contribution.zh-CN.md
    form-builder.zh-CN.md
    index.zh-CN.md
    issue-helper.zh-CN.md
    learn-formily.zh-CN.md
    quick-start.zh-CN.md
    upgrade.zh-CN.md
  index.zh-CN.md
packages/
  antd/
    docs/
      components/
        ArrayCards.md
        ArrayCards.zh-CN.md
        ArrayCollapse.md
        ArrayCollapse.zh-CN.md
        ArrayItems.md
        ArrayItems.zh-CN.md
        ArrayTable.md
        ArrayTable.zh-CN.md
        ArrayTabs.md
        ArrayTabs.zh-CN.md
        Cascader.md
        Cascader.zh-CN.md
        Checkbox.md
        Checkbox.zh-CN.md
        DatePicker.md
        DatePicker.zh-CN.md
        Editable.md
        Editable.zh-CN.md
        Form.md
        Form.zh-CN.md
        FormButtonGroup.md
        FormButtonGroup.zh-CN.md
        FormCollapse.md
        FormCollapse.zh-CN.md
        FormDialog.md
        FormDialog.zh-CN.md
        FormDrawer.md
        FormDrawer.zh-CN.md
        FormGrid.md
        FormGrid.zh-CN.md
        FormItem.md
        FormItem.zh-CN.md
        FormLayout.md
        FormLayout.zh-CN.md
        FormStep.md
        FormStep.zh-CN.md
        FormTab.md
        FormTab.zh-CN.md
        index.md
        index.zh-CN.md
        Input.md
        Input.zh-CN.md
        NumberPicker.md
        NumberPicker.zh-CN.md
        Password.md
        Password.zh-CN.md
        PreviewText.md
        PreviewText.zh-CN.md
        Radio.md
        Radio.zh-CN.md
        Reset.md
        Reset.zh-CN.md
        Select.md
        Select.zh-CN.md
        SelectTable.md
        SelectTable.zh-CN.md
        Space.md
        Space.zh-CN.md
        Submit.md
        Submit.zh-CN.md
        Switch.md
        Switch.zh-CN.md
        TimePicker.md
        TimePicker.zh-CN.md
        Transfer.md
        Transfer.zh-CN.md
        TreeSelect.md
        TreeSelect.zh-CN.md
        Upload.md
        Upload.zh-CN.md
      index.md
      index.zh-CN.md
  core/
    docs/
      api/
        entry/
          createForm.md
          createForm.zh-CN.md
          FieldEffectHooks.md
          FieldEffectHooks.zh-CN.md
          FormChecker.md
          FormChecker.zh-CN.md
          FormEffectHooks.md
          FormEffectHooks.zh-CN.md
          FormHooksAPI.md
          FormHooksAPI.zh-CN.md
          FormPath.md
          FormPath.zh-CN.md
          FormValidatorRegistry.md
          FormValidatorRegistry.zh-CN.md
        models/
          ArrayField.md
          ArrayField.zh-CN.md
          Field.md
          Field.zh-CN.md
          Form.md
          Form.zh-CN.md
          ObjectField.md
          ObjectField.zh-CN.md
          Query.md
          Query.zh-CN.md
          VoidField.md
          VoidField.zh-CN.md
      guide/
        architecture.md
        architecture.zh-CN.md
        field.md
        field.zh-CN.md
        form.md
        form.zh-CN.md
        index.md
        index.zh-CN.md
        mvvm.md
        mvvm.zh-CN.md
        values.md
        values.zh-CN.md
      index.md
      index.zh-CN.md
  react/
    docs/
      api/
        components/
          ArrayField.md
          ArrayField.zh-CN.md
          ExpressionScope.md
          ExpressionScope.zh-CN.md
          Field.md
          Field.zh-CN.md
          FormConsumer.md
          FormConsumer.zh-CN.md
          FormProvider.md
          FormProvider.zh-CN.md
          ObjectField.md
          ObjectField.zh-CN.md
          RecordScope.md
          RecordScope.zh-CN.md
          RecordsScope.md
          RecordsScope.zh-CN.md
          RecursionField.md
          RecursionField.zh-CN.md
          SchemaField.md
          SchemaField.zh-CN.md
          VoidField.md
          VoidField.zh-CN.md
        hooks/
          useExpressionScope.md
          useExpressionScope.zh-CN.md
          useField.md
          useField.zh-CN.md
          useFieldSchema.md
          useFieldSchema.zh-CN.md
          useForm.md
          useForm.zh-CN.md
          useFormEffects.md
          useFormEffects.zh-CN.md
          useParentForm.md
          useParentForm.zh-CN.md
        shared/
          connect.md
          connect.zh-CN.md
          context.md
          context.zh-CN.md
          mapProps.md
          mapProps.zh-CN.md
          mapReadPretty.md
          mapReadPretty.zh-CN.md
          observer.md
          observer.zh-CN.md
          Schema.md
          Schema.zh-CN.md
      guide/
        architecture.md
        architecture.zh-CN.md
        concept.md
        concept.zh-CN.md
        index.md
        index.zh-CN.md
      index.md
      index.zh-CN.md
  reactive/
    docs/
      api/
        react/
          observer.md
          observer.zh-CN.md
        vue/
          observer.md
          observer.zh-CN.md
        action.md
        action.zh-CN.md
        autorun.md
        autorun.zh-CN.md
        batch.md
        batch.zh-CN.md
        define.md
        define.zh-CN.md
        hasCollected.md
        hasCollected.zh-CN.md
        markObservable.md
        markObservable.zh-CN.md
        markRaw.md
        markRaw.zh-CN.md
        model.md
        model.zh-CN.md
        observable.md
        observable.zh-CN.md
        observe.md
        observe.zh-CN.md
        raw.md
        raw.zh-CN.md
        reaction.md
        reaction.zh-CN.md
        toJS.md
        toJS.zh-CN.md
        tracker.md
        tracker.zh-CN.md
        typeChecker.md
        typeChecker.zh-CN.md
        untracked.md
        untracked.zh-CN.md
      guide/
        best-practice.md
        best-practice.zh-CN.md
        concept.md
        concept.zh-CN.md
        index.md
        index.zh-CN.md
      index.md
      index.zh-CN.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/guide/advanced/async.zh-CN.md">
# 实现异步数据源

异步数据源管理，核心体现在[Field](https://core.formilyjs.org/zh-CN/api/models/field)模型中的 dataSource 属性，我们可以在 effects 中修改 Field 的 dataSource，也可以在 reactions 中修改 dataSource 属性。

如果字段组件内部(比如 Select)有消费 dataSource 属性，当 dataSource 发生变化时，对应组件会自动重渲染。

<Alert>
注意：如果是业务自定义组件，请手动映射dataSource到自定义组件中，可以使用 <a href="https://react.formilyjs.org/zh-CN/api/shared/connect">connect</a>，也可以使用 <a href="https://react.formilyjs.org/zh-CN/api/shared/observer">observer</a> + <a href="https://react.formilyjs.org/zh-CN/api/hooks/use-field">useField</a>
</Alert>

具体案例可以参考：

- [Select](https://antd.formilyjs.org/zh-CN/components/select)
- [TreeSelect](https://antd.formilyjs.org/zh-CN/components/tree-select)
- [Cascader](https://antd.formilyjs.org/zh-CN/components/cascader)
</file>

<file path="docs/guide/advanced/build.zh-CN.md">
# 按需打包

## 基于 Umi 开发

#### 安装 `babel-plugin-import`

```shell
npm install babel-plugin-import --save-dev
```

或者

```shell
yarn add babel-plugin-import --dev
```

#### 插件配置

修改 `.umirc.js`或 `.umirc.ts`

```js
export default {
  extraBabelPlugins: [
    [
      'babel-plugin-import',
      { libraryName: 'antd', libraryDirectory: 'es', style: true },
      'antd',
    ],
    [
      'babel-plugin-import',
      { libraryName: '@formily/antd', libraryDirectory: 'esm', style: true },
      '@formily/antd',
    ],
  ],
}
```

## 基于 create-react-app 开发

首先我们需要对`create-react-app`的默认配置进行自定义，这里我们使用 [react-app-rewired](https://github.com/timarney/react-app-rewired) （一个对 `create-react-app` 进行自定义配置的社区解决方案）。
引入 `react-app-rewired` 并修改 `package.json` 里的启动配置。由于新的 [react-app-rewired@2.x](https://github.com/timarney/react-app-rewired#alternatives) 版本的关系，你还需要安装 [customize-cra](https://github.com/arackaf/customize-cra)。

```shell
$ npm install react-app-rewired customize-cra  --save-dev
```

或者

```shell
$ yarn add react-app-rewired customize-cra --dev
```

修改 `package.json`

```diff
"scripts": {
-   "start": "react-scripts start",
+   "start": "react-app-rewired start",
-   "build": "react-scripts build",
+   "build": "react-app-rewired build",
-   "test": "react-scripts test",
+   "test": "react-app-rewired test",
}
```

然后在项目根目录创建一个 `config-overrides.js` 用于修改默认配置。

```js
module.exports = function override(config, env) {
  // do stuff with the webpack config...
  return config
}
```

#### 安装 babel-plugin-import

```shell
npm install babel-plugin-import --save-dev
```

或者

```shell
yarn add babel-plugin-import --dev
```

修改`config-overrides.js`

```diff
+ const { override, fixBabelImports } = require('customize-cra');

- module.exports = function override(config, env) {
-   // do stuff with the webpack config...
-   return config;
- };
+ module.exports = override(
+   fixBabelImports('antd', {
+     libraryName: 'antd',
+     libraryDirectory: 'es',
+     style: true
+   }),
+   fixBabelImports('@formily/antd', {
+     libraryName: '@formily/antd',
+     libraryDirectory: 'esm',
+     style: true
+   }),
+ );
```

## 在 Webpack 中使用

#### 安装 babel-plugin-import

```shell
npm install babel-plugin-import --save-dev
```

或者

```shell
yarn add babel-plugin-import --dev
```

修改 `.babelrc` 或者 babel-loader

```json
{
  "plugins": [
    [
      "import",
      {
        "libraryName": "antd",
        "libraryDirectory": "es",
        "style": true
      },
      "antd"
    ],
    [
      "import",
      {
        "libraryName": "@formily/antd",
        "libraryDirectory": "esm",
        "style": true
      },
      "@formily/antd"
    ]
  ]
}
```

更多配置请参考 [babel-plugin-import](https://github.com/ant-design/babel-plugin-import)
</file>

<file path="docs/guide/advanced/business-logic.zh-CN.md">
# 管理业务逻辑

在前面的文档中，我们其实可以发现 Formily 已经提供了局部描述逻辑的能力，也就是字段组件的 x-reactions/reactions 属性，而且在 Schema 中，x-reactions 既能传函数，也能传一个结构化对象，当然，还有 Formily1.x 继承下来的 effects，那么总结一下，在 Formily2.x 中描述逻辑的方式有：

- 纯 JSX 模式下的 effects 或 reactions 属性
- Schema 模式下的 effects 或结构化 x-reactions 属性
- Schema 模式下的 effects 或函数态 x-reactions 属性

这么多描述逻辑的方式，我们该如何选择？什么场景下是最佳实践呢？首先，我们要理解清楚 effects 和 reactions 的定位。

首先，reactions 是用在具体字段属性上的响应器，它会基于函数内依赖的数据变化而重复执行，它最大的优点就是简单直接，容易理解，比如：

```tsx pure
/* eslint-disable */
<Field
  name="A"
  reactions={(field) => {
    /**具体逻辑实现**/
  }}
/>
```

然后，effects 是用于实现副作用隔离逻辑管理模型，它最大的优点就是在字段数量超多的场景下，可以让视图代码变得更易维护，同时它还有一个能力，就是可以批量化的对字段做处理。比如我们在 A,B,C 字段属性显示声明 x-reactions，如果这 3 个字段的 x-reactions 逻辑都是一模一样的，那我们在 effects 中只需这么写即可：

```ts
onFieldReact('*(A,B,C)', (field) => {
  //...逻辑
})
```

使用 effects 还有一个好处就是可以实现一系列的可复用逻辑插件，可以做到很方便的逻辑可拔插，同时还能做一些全局监控之类的事情。

这样看来，是不是我们就不需要局部定义逻辑了？

并不是，上面的写法的前提是对于字段数量很多，如果视图层满屏的 reactions，看着是很难受的，所以考虑将逻辑抽离统一维护则是一个比较好的策略。相反，如果字段数量很少，逻辑相对简单的，直接在字段属性上写 reactions 也是不错的，清晰明了。

同时，因为 JSON Schema 是可以给配置化系统消费的，我们需要在配置界面上对具体某个字段做逻辑配置。所以我们还是需要支持局部定义逻辑能力，同时还需要支持结构化描述逻辑，比如：

```json
{
  "x-reactions": {
    "dependencies": ["aa"],
    "fulfill": {
      "state": {
        "visible": "{{$deps[0] == '123'}}"
      }
    }
  }
}
```

这样可以很好的解决大部分配置场景的联动需求了，但是，还有一种场景，就是我们的联动过程是存在异步的，逻辑非常复杂的，或者存在大量数据处理的，那我们就只能考虑开放函数态描述的能力了，比如：

```json
{
  "x-reactions": "{{(field)=>{/**具体逻辑实现**/}}}"
}
```

这种就很像是低代码配置了，当然，我们也可以在上下文作用域中注册一系列的通用逻辑函数：

```json
{
  "x-reactions": "{{customFunction}}"
}
```

最终总结下来，我们管理业务逻辑的方式，有以下优先级：

- 纯源码模式
  - 字段数量庞大，逻辑复杂，优先选择 effects 中定义逻辑
  - 字段数量少，逻辑简单，优先选择 reactions 中定义逻辑
- Schema 模式
  - 不存在异步逻辑，优先选择结构化 reactions 定义逻辑
  - 存在异步逻辑，或者大量计算，优先选择函数态 reactions 定义逻辑

对于 effects 中如何玩出花来，我们主要看[@formily/core](https://core.formilyjs.org/zh-CN)文档即可
</file>

<file path="docs/guide/advanced/calculator.zh-CN.md">
# 实现联动计算器

联动计算器，主要用于在填写表单的过程中做求值汇总，在 Formily1.x 中实现这类需求的成本非常非常高，在 2.x 中，我们可以借助 reactions 轻松实现

## Markup Schema 案例

```tsx
import React from 'react'
import {
  Form,
  FormItem,
  NumberPicker,
  ArrayTable,
  Editable,
  Input,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Editable,
    Input,
    NumberPicker,
    ArrayTable,
  },
})

const form = createForm()

export default () => {
  return (
    <Form form={form} layout="vertical">
      <SchemaField>
        <SchemaField.Array
          name="projects"
          title="Projects"
          x-decorator="FormItem"
          x-component="ArrayTable"
        >
          <SchemaField.Object>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{ width: 50, title: 'Sort', align: 'center' }}
            >
              <SchemaField.Void
                x-decorator="FormItem"
                x-component="ArrayTable.SortHandle"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{ width: 80, title: 'Index', align: 'center' }}
            >
              <SchemaField.String
                x-decorator="FormItem"
                x-component="ArrayTable.Index"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{ title: 'Price' }}
            >
              <SchemaField.Number
                name="price"
                x-decorator="Editable"
                required
                x-component="NumberPicker"
                x-component-props={{
                  addonAfter: '$',
                }}
                default={0}
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{ title: 'Count' }}
            >
              <SchemaField.Number
                name="count"
                x-decorator="Editable"
                required
                x-component="NumberPicker"
                default={0}
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{ title: 'Total' }}
            >
              <SchemaField.Number
                x-decorator="FormItem"
                name="total"
                x-component="NumberPicker"
                x-pattern="readPretty"
                x-component-props={{
                  addonAfter: '$',
                }}
                x-reactions={{
                  dependencies: ['.price', '.count'],
                  when: '{{$deps[0] && $deps[1]}}',
                  fulfill: {
                    state: {
                      value: '{{$deps[0] * $deps[1]}}',
                    },
                  },
                }}
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{
                title: 'Operations',
                dataIndex: 'operations',
                width: 200,
                fixed: 'right',
              }}
            >
              <SchemaField.Void x-component="FormItem">
                <SchemaField.Void x-component="ArrayTable.Remove" />
                <SchemaField.Void x-component="ArrayTable.MoveDown" />
                <SchemaField.Void x-component="ArrayTable.MoveUp" />
              </SchemaField.Void>
            </SchemaField.Void>
          </SchemaField.Object>
          <SchemaField.Void x-component="ArrayTable.Addition" title="Add" />
        </SchemaField.Array>
        <SchemaField.Number
          name="total"
          title="Total"
          x-decorator="FormItem"
          x-component="NumberPicker"
          x-component-props={{
            addonAfter: '$',
          }}
          x-pattern="readPretty"
          x-reactions={{
            dependencies: ['.projects'],
            when: '{{$deps[0].length > 0}}',
            fulfill: {
              state: {
                value:
                  '{{$deps[0].reduce((total,item)=>item.total ? total+item.total : total,0)}}',
              },
            },
          }}
        />
      </SchemaField>
      <FormButtonGroup>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup>
    </Form>
  )
}
```

## JSON Schema 案例

```tsx
import React from 'react'
import {
  Form,
  FormItem,
  NumberPicker,
  ArrayTable,
  Editable,
  Input,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Editable,
    Input,
    NumberPicker,
    ArrayTable,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    projects: {
      type: 'array',
      title: 'Projects',
      'x-decorator': 'FormItem',
      'x-component': 'ArrayTable',
      items: {
        type: 'object',
        properties: {
          column_1: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': {
              width: 50,
              title: 'Sort',
              align: 'center',
            },
            properties: {
              sortable: {
                type: 'void',
                'x-component': 'ArrayTable.SortHandle',
              },
            },
          },
          column_2: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': {
              width: 50,
              title: 'Index',
              align: 'center',
            },
            properties: {
              index: {
                type: 'void',
                'x-component': 'ArrayTable.Index',
              },
            },
          },
          column_3: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': {
              title: 'Price',
            },
            properties: {
              price: {
                type: 'number',
                default: 0,
                'x-decorator': 'Editable',
                'x-component': 'NumberPicker',
                'x-component-props': {
                  addonAfter: '$',
                },
              },
            },
          },
          column_4: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': {
              title: 'Count',
            },
            properties: {
              count: {
                type: 'number',
                default: 0,
                'x-decorator': 'Editable',
                'x-component': 'NumberPicker',
                'x-component-props': {
                  addonAfter: '$',
                },
              },
            },
          },
          column_5: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': {
              title: 'Total',
            },
            properties: {
              total: {
                type: 'number',
                'x-read-pretty': true,
                'x-decorator': 'FormItem',
                'x-component': 'NumberPicker',
                'x-component-props': {
                  addonAfter: '$',
                },
                'x-reactions': {
                  dependencies: ['.price', '.count'],
                  when: '{{$deps[0] && $deps[1]}}',
                  fulfill: {
                    state: {
                      value: '{{$deps[0] * $deps[1]}}',
                    },
                  },
                },
              },
            },
          },
          column_6: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': {
              title: 'Operations',
            },
            properties: {
              item: {
                type: 'void',
                'x-component': 'FormItem',
                properties: {
                  remove: {
                    type: 'void',
                    'x-component': 'ArrayTable.Remove',
                  },
                  moveDown: {
                    type: 'void',
                    'x-component': 'ArrayTable.MoveDown',
                  },
                  moveUp: {
                    type: 'void',
                    'x-component': 'ArrayTable.MoveUp',
                  },
                },
              },
            },
          },
        },
      },
      properties: {
        add: {
          type: 'void',
          title: 'Add',
          'x-component': 'ArrayTable.Addition',
        },
      },
    },
    total: {
      type: 'number',
      title: 'Total',
      'x-decorator': 'FormItem',
      'x-component': 'NumberPicker',
      'x-component-props': {
        addonAfter: '$',
      },
      'x-pattern': 'readPretty',
      'x-reactions': {
        dependencies: ['.projects'],
        when: '{{$deps[0].length > 0}}',
        fulfill: {
          state: {
            value:
              '{{$deps[0].reduce((total,item)=>item.total ? total+item.total : total,0)}}',
          },
        },
      },
    },
  },
}

export default () => {
  return (
    <Form form={form} layout="vertical">
      <SchemaField schema={schema} />
      <FormButtonGroup>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup>
    </Form>
  )
}
```
</file>

<file path="docs/guide/advanced/controlled.zh-CN.md">
# 实现表单受控

Formily2.x 已经放弃了给表单组件和字段组件支持受控模式，因为表单内部管理状态模式本身就不是受控模式，在将受控模式转为非受控模式的过程中会有很多边界问题，同时受控模式会存在大量的脏检查过程，性能很不好，反而非受控模式本身就可以解决大部分问题了。

所以 Formily 就不再支持受控模式了，但是如果我们硬要实现普通 React 受控，还是可以支持的，只不过只能实现值受控，不能实现字段级受控，也就是我们使用的 Field 组件，属性只会在初次渲染时生效，未来属性发生任何变化都不会自动更新，想要自动更新，除非重新创建 Form 实例(显然这样会丢失所有之前维护好的状态)。

所以，我们更加推荐的是使用[@formily/reactive](https://reactive.formilyjs.org/zh-CN) 实现响应式受控，既能实现值受控，也能实现字段级受控

## 值受控

普通受控模式，会强依赖脏检查实现数据同步，同时组件渲染次数会非常高

```tsx
import React, { useMemo, useState, useEffect, useRef } from 'react'
import { createForm, onFormValuesChange } from '@formily/core'
import { createSchemaField } from '@formily/react'
import { Form, FormItem, Input } from '@formily/antd'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const MyForm = (props) => {
  const form = useMemo(
    () =>
      createForm({
        values: props.values,
        effects: () => {
          onFormValuesChange((form) => {
            props.onChange(form.values)
          })
        },
      }),
    []
  )
  const count = useRef(1)

  useEffect(() => {
    form.setValues(props.values, 'overwrite')
  }, [JSON.stringify(props.values)])

  return (
    <Form form={form}>
      <SchemaField>
        <SchemaField.String
          name="input"
          x-decorator="FormItem"
          x-component="Input"
          x-component-props={{ placeholder: '受控者' }}
        />
      </SchemaField>
      Form组件渲染次数：{count.current++}
    </Form>
  )
}

export default () => {
  const [values, setValues] = useState({ input: '' })
  const count = useRef(1)
  return (
    <>
      <FormItem>
        <Input
          value={values.input}
          placeholder="控制者"
          onChange={(event) => {
            setValues({ ...values, input: event.target.value })
          }}
        />
      </FormItem>
      <MyForm
        values={values}
        onChange={(values) => {
          setValues({ ...values })
        }}
      />
      根组件渲染次数：{count.current++}
    </>
  )
}
```

## 响应式值受控

响应式受控主要是使用[@formily/reactive](https://reactive.formilyjs.org/zh-CN)实现响应式更新，我们可以轻松实现双向绑定，同时性能完爆普通受控更新

```tsx
import React, { useMemo, useRef } from 'react'
import { createForm } from '@formily/core'
import { createSchemaField } from '@formily/react'
import { Form, FormItem, Input } from '@formily/antd'
import { observable } from '@formily/reactive'
import { observer } from '@formily/reactive-react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const MyForm = (props) => {
  const count = useRef(1)
  const form = useMemo(
    () =>
      createForm({
        values: props.values,
      }),
    []
  )

  return (
    <Form form={form}>
      <SchemaField>
        <SchemaField.String
          name="input"
          x-decorator="FormItem"
          x-component="Input"
          x-component-props={{ placeholder: '受控者' }}
        />
      </SchemaField>
      Form组件渲染次数：{count.current++}
    </Form>
  )
}

const Controller = observer((props) => {
  const count = useRef(1)
  return (
    <FormItem>
      <Input
        value={props.values.input}
        placeholder="控制者"
        onChange={(event) => {
          props.values.input = event.target.value
        }}
      />
      Controller组件渲染次数：{count.current++}
    </FormItem>
  )
})

export default () => {
  const count = useRef(1)
  const values = useMemo(() =>
    observable({
      input: '',
    })
  )
  return (
    <>
      <Controller values={values} />
      <MyForm values={values} />
      根组件渲染次数：{count.current++}
    </>
  )
}
```

## Schema 受控

对于表单配置化场景会有一个需求，表单的 Schema 会发生频繁改变，其实就相当于频繁创建新表单了，之前操作的状态就应该丢弃了

```tsx
import React, { useMemo, useState } from 'react'
import { createForm } from '@formily/core'
import { createSchemaField } from '@formily/react'
import { Form, FormItem, Input, Select } from '@formily/antd'
import { Button, Space } from 'antd'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
    Select,
  },
})

export default () => {
  const [current, setCurrent] = useState({})
  const form = useMemo(() => createForm(), [current])
  return (
    <Form form={form} layout="vertical">
      <Space style={{ marginBottom: 20 }}>
        <Button
          onClick={() => {
            setCurrent({
              type: 'object',
              properties: {
                aa: {
                  type: 'string',
                  title: 'AA',
                  'x-decorator': 'FormItem',
                  'x-component': 'Input',
                  'x-component-props': {
                    placeholder: 'Input',
                  },
                },
              },
            })
          }}
        >
          Schema1
        </Button>
        <Button
          onClick={() => {
            setCurrent({
              type: 'object',
              properties: {
                aa: {
                  type: 'string',
                  title: 'AA',
                  'x-decorator': 'FormItem',
                  enum: [
                    {
                      label: '111',
                      value: '111',
                    },
                    { label: '222', value: '222' },
                  ],
                  'x-component': 'Select',
                  'x-component-props': {
                    placeholder: 'Select',
                  },
                },
                bb: {
                  type: 'string',
                  title: 'BB',
                  'x-decorator': 'FormItem',
                  'x-component': 'Input',
                },
              },
            })
          }}
        >
          Schema2
        </Button>
      </Space>
      <SchemaField schema={current} />
    </Form>
  )
}
```

## Schema 片段联动(顶层控制)

片段联动最重要的是需要手动清理字段模型，否则无法做到 UI 同步

```tsx
import React, { useMemo, useRef } from 'react'
import { createForm } from '@formily/core'
import { createSchemaField, observer } from '@formily/react'
import { Form, FormItem, Input, Select } from '@formily/antd'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
    Select,
  },
})

const DYNAMIC_INJECT_SCHEMA = {
  type_1: {
    type: 'void',
    properties: {
      aa: {
        type: 'string',
        title: 'AA',
        'x-decorator': 'FormItem',
        'x-component': 'Input',
        'x-component-props': {
          placeholder: 'Input',
        },
      },
    },
  },
  type_2: {
    type: 'void',
    properties: {
      aa: {
        type: 'string',
        title: 'AA',
        'x-decorator': 'FormItem',
        enum: [
          {
            label: '111',
            value: '111',
          },
          { label: '222', value: '222' },
        ],
        'x-component': 'Select',
        'x-component-props': {
          placeholder: 'Select',
        },
      },
      bb: {
        type: 'string',
        title: 'BB',
        'x-decorator': 'FormItem',
        'x-component': 'Input',
      },
    },
  },
}

const App = observer(() => {
  const oldTypeRef = useRef()
  const form = useMemo(() => createForm(), [])
  const currentType = form.values.type
  const schema = {
    type: 'object',
    properties: {
      type: {
        type: 'string',
        title: '类型',
        enum: [
          { label: '类型1', value: 'type_1' },
          { label: '类型2', value: 'type_2' },
        ],
        'x-decorator': 'FormItem',
        'x-component': 'Select',
      },
      container: DYNAMIC_INJECT_SCHEMA[currentType],
    },
  }

  if (oldTypeRef.current !== currentType) {
    form.clearFormGraph('container.*') //回收字段模型
  }

  oldTypeRef.current = currentType

  return (
    <Form form={form} layout="vertical">
      <SchemaField schema={schema} />
    </Form>
  )
})

export default App
```

## Schema 片段联动(自定义组件)

```tsx
import React, { useMemo, useState, useEffect } from 'react'
import { createForm } from '@formily/core'
import {
  createSchemaField,
  RecursionField,
  useForm,
  useField,
  observer,
} from '@formily/react'
import { Form, FormItem, Input, Select } from '@formily/antd'

const Custom = observer(() => {
  const field = useField()
  const form = useForm()
  const [schema, setSchema] = useState({})

  useEffect(() => {
    form.clearFormGraph(`${field.address}.*`) //回收字段模型
    //可以异步获取
    setSchema(DYNAMIC_INJECT_SCHEMA[form.values.type])
  }, [form.values.type])

  return (
    <RecursionField
      basePath={field.address}
      schema={schema}
      onlyRenderProperties
    />
  )
})

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
    Select,
    Custom,
  },
})

const DYNAMIC_INJECT_SCHEMA = {
  type_1: {
    type: 'void',
    properties: {
      aa: {
        type: 'string',
        title: 'AA',
        'x-decorator': 'FormItem',
        'x-component': 'Input',
        'x-component-props': {
          placeholder: 'Input',
        },
      },
    },
  },
  type_2: {
    type: 'void',
    properties: {
      aa: {
        type: 'string',
        title: 'AA',
        'x-decorator': 'FormItem',
        enum: [
          {
            label: '111',
            value: '111',
          },
          { label: '222', value: '222' },
        ],
        'x-component': 'Select',
        'x-component-props': {
          placeholder: 'Select',
        },
      },
      bb: {
        type: 'string',
        title: 'BB',
        'x-decorator': 'FormItem',
        'x-component': 'Input',
      },
    },
  },
}

const App = observer(() => {
  const form = useMemo(() => createForm(), [])
  const schema = {
    type: 'object',
    properties: {
      type: {
        type: 'string',
        title: '类型',
        enum: [
          { label: '类型1', value: 'type_1' },
          { label: '类型2', value: 'type_2' },
        ],
        'x-decorator': 'FormItem',
        'x-component': 'Select',
      },
      container: {
        type: 'object',
        'x-component': 'Custom',
      },
    },
  }

  return (
    <Form form={form} layout="vertical">
      <SchemaField schema={schema} />
    </Form>
  )
})

export default App
```

## 字段级受控

### 最佳实践

推荐使用[@formily/reactive](https://reactive.formilyjs.org/zh-CN) 实现响应式受控

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField } from '@formily/react'
import { Form, FormItem, Input } from '@formily/antd'
import { observable } from '@formily/reactive'
import { observer } from '@formily/reactive-react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const form = createForm()

const obs = observable({
  input: '',
})

const Controller = observer(() => {
  return (
    <FormItem>
      <Input
        value={obs.input}
        placeholder="控制者"
        onChange={(event) => {
          obs.input = event.target.value
        }}
      />
    </FormItem>
  )
})

export default () => {
  return (
    <>
      <Controller />
      <Form form={form}>
        <SchemaField>
          <SchemaField.String
            name="input"
            x-decorator="FormItem"
            x-component="Input"
            x-component-props={{ placeholder: '受控者' }}
            x-reactions={(field) => {
              field.component[1].placeholder = obs.input || '受控者'
            }}
          />
        </SchemaField>
      </Form>
    </>
  )
}
```

### 反模式

使用传统受控模式是无法自动更新的

```tsx
import React, { useState } from 'react'
import { createForm } from '@formily/core'
import { createSchemaField } from '@formily/react'
import { Form, FormItem, Input } from '@formily/antd'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const form = createForm()

export default () => {
  const [value, setValue] = useState('')
  return (
    <>
      <FormItem>
        <Input
          value={value}
          placeholder="控制者"
          onChange={(event) => {
            setValue(event.target.value)
          }}
        />
      </FormItem>
      <Form form={form}>
        <SchemaField>
          <SchemaField.String
            name="input"
            x-decorator="FormItem"
            x-component="Input"
            x-component-props={{ placeholder: value || '受控者' }}
          />
        </SchemaField>
      </Form>
    </>
  )
}
```
</file>

<file path="docs/guide/advanced/custom.zh-CN.md">
# 实现自定义组件

实现业务自定义组件主要是使用[@formily/react](https://react.formilyjs.org/zh-CN) 或[@formily/vue](https://vue.formilyjs.org)中的 Hooks API 与 observer API

接入现成组件库的话，我们主要使用 connect/mapProps/mapReadPretty API

如果想要实现一些更复杂的自定义组件，我们强烈推荐直接看[@formily/antd](https://github.com/alibaba/formily/tree/formily_next/packages/antd/src)或 [@formily/next](https://github.com/alibaba/formily/tree/formily_next/packages/next/src)的源码
</file>

<file path="docs/guide/advanced/destructor.zh-CN.md">
# 前后端数据差异兼容方案

很多时候，我们总会遇到前端数据结构与后端数据结构不匹配的场景，看似很简单的问题，其实解决起来非常的让人难受，最常见的问题就是：

前端日期范围组件输出的是数组结构，但是后端要求的格式是拆分扁平数据结构，这种问题很大程度是受后端领域模型所限制，因为从后端模型设计的角度来看，拆分扁平结构是最佳方案；

但从前端组件化角度来看，数组结构又是最佳的；

所以哪一边都有其道理，可惜的是，每次都只能前端去消化这样一个不平等条约，不过，有了 Formily，你就完全不需要为这样一个尴尬局面而难受了，**Formily 提供了解构路径的能力，可以帮助用户快速解决这类问题。**，下面可以看看例子

## Markup Schema 案例

```tsx
import React from 'react'
import {
  Form,
  FormItem,
  DatePicker,
  FormButtonGroup,
  Radio,
  Submit,
} from '@formily/antd'
import { createForm, onFieldValueChange } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    DatePicker,
    Radio,
  },
})

const form = createForm({
  effects() {
    onFieldValueChange('visible_destructor', (field) => {
      form.setFieldState('[startDate,endDate]', (state) => {
        state.visible = !!field.value
      })
    })
  },
})

export default () => {
  return (
    <Form form={form} layout="vertical">
      <SchemaField>
        <SchemaField.Boolean
          name="visible_destructor"
          title="是否显示解构字段"
          default={true}
          enum={[
            { label: '是', value: true },
            { label: '否', value: false },
          ]}
          x-decorator="FormItem"
          x-component="Radio.Group"
        />
        <SchemaField.String
          name="undestructor"
          title="解构前"
          x-decorator="FormItem"
          x-component="DatePicker.RangePicker"
        />
        <SchemaField.String
          name="[startDate,endDate]"
          title="解构后"
          default={['2020-11-20', '2021-12-30']}
          x-decorator="FormItem"
          x-component="DatePicker.RangePicker"
        />
      </SchemaField>
      <code>
        <pre>
          <FormConsumer>
            {(form) => JSON.stringify(form.values, null, 2)}
          </FormConsumer>
        </pre>
      </code>
      <FormButtonGroup>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup>
    </Form>
  )
}
```

## JSON Schema 案例

```tsx
import React from 'react'
import {
  Form,
  FormItem,
  DatePicker,
  FormButtonGroup,
  Radio,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    DatePicker,
    Radio,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    visible_destructor: {
      type: 'boolean',
      title: '是否显示解构字段',
      default: true,
      enum: [
        { label: '是', value: true },
        { label: '否', value: false },
      ],
      'x-decorator': 'FormItem',
      'x-component': 'Radio.Group',
    },
    undestructor: {
      type: 'string',
      title: '解构前',
      'x-decorator': 'FormItem',
      'x-component': 'DatePicker.RangePicker',
    },
    '[startDate,endDate]': {
      type: 'string',
      title: '解构后',
      default: ['2020-11-20', '2021-12-30'],
      'x-decorator': 'FormItem',
      'x-component': 'DatePicker.RangePicker',
      'x-reactions': {
        dependencies: ['visible_destructor'],
        fulfill: {
          state: {
            visible: '{{!!$deps[0]}}',
          },
        },
      },
    },
  },
}

export default () => {
  return (
    <Form form={form} layout="vertical">
      <SchemaField schema={schema} />
      <code>
        <pre>
          <FormConsumer>
            {(form) => JSON.stringify(form.values, null, 2)}
          </FormConsumer>
        </pre>
      </code>
      <FormButtonGroup>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup>
    </Form>
  )
}
```

## 纯 JSX 案例

```tsx
import React from 'react'
import {
  Form,
  FormItem,
  DatePicker,
  FormButtonGroup,
  Radio,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { Field, FormConsumer } from '@formily/react'

const form = createForm()

export default () => {
  return (
    <Form form={form} layout="vertical">
      <Field
        name="visible_destructor"
        title="是否显示解构字段"
        initialValue={true}
        dataSource={[
          { label: '是', value: true },
          { label: '否', value: false },
        ]}
        decorator={[FormItem]}
        component={[Radio.Group]}
      />
      <Field
        name="undestructor"
        title="解构前"
        decorator={[FormItem]}
        component={[DatePicker.RangePicker]}
      />
      <Field
        name="[startDate,endDate]"
        title="解构后"
        initialValue={['2020-11-20', '2021-12-30']}
        decorator={[FormItem]}
        component={[DatePicker.RangePicker]}
        reactions={(field) => {
          field.visible = !!field.query('visible_destructor').value()
        }}
      />
      <code>
        <pre>
          <FormConsumer>
            {(form) => JSON.stringify(form.values, null, 2)}
          </FormConsumer>
        </pre>
      </code>
      <FormButtonGroup>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup>
    </Form>
  )
}
```
</file>

<file path="docs/guide/advanced/layout.zh-CN.md">
# 实现表单布局

表单布局主要是使用[@formily/antd](https://antd.formilyjs.org/zh-CN) 或 [@formily/next](https://fusion.formilyjs.org/zh-CN) 中的：

- [FormLayout](https://antd.formilyjs.org/zh-CN/components/form-layout) 组件
- [FormItem](https://antd.formilyjs.org/zh-CN/components/form-item) 组件
- [FormGrid](https://antd.formilyjs.org/zh-CN/components/form-grid) 组件
- [Space](https://antd.formilyjs.org/zh-CN/components/space) 组件

这 4 个组件基本上能解决所有复杂表单布局场景，我们只需要灵活的组合使用这几个组件即可。
</file>

<file path="docs/guide/advanced/linkages.zh-CN.md">
# 实现联动逻辑

Formily1.x 中实现联动逻辑只有一种模式，也就是主动模式，必须要监听一个或多个字段的事件变化去控制另一个或者多个字段的状态，这样对于一对多联动场景很方便，但是对于多对一场景就很麻烦了，需要监听多个字段的变化去控制一个字段状态，所以 Formily2.x 提供了响应式机制，可以让联动支持被动式联动，只需要关注某个字段所依赖的字段即可，依赖字段变化了，被依赖的字段即可自动联动。

## 主动模式

主动联动核心是基于

- [FormEffectHooks](https://core.formilyjs.org/zh-CN/api/entry/form-effect-hooks)
- [FieldEffectHooks](https://core.formilyjs.org/zh-CN/api/entry/field-effect-hooks)
- [setFormState](https://core.formilyjs.org/zh-CN/api/models/form#setformstate)
- [setFieldState](https://core.formilyjs.org/zh-CN/api/models/form#setfieldstate)
- [SchemaReactions](https://react.formilyjs.org/zh-CN/api/shared/schema#schemareactions)

实现主动联动，优点是实现一对多联动时非常方便

### 一对一联动

#### Effects 用例

```tsx
import React from 'react'
import { createForm, onFieldValueChange } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, Input, Select } from '@formily/antd'

const form = createForm({
  effects() {
    onFieldValueChange('select', (field) => {
      form.setFieldState('input', (state) => {
        //对于初始联动，如果字段找不到，setFieldState会将更新推入更新队列，直到字段出现再执行操作
        state.display = field.value
      })
    })
  },
})

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    Select,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.String
        name="select"
        title="控制者"
        default="visible"
        enum={[
          { label: '显示', value: 'visible' },
          { label: '隐藏', value: 'none' },
          { label: '隐藏-保留值', value: 'hidden' },
        ]}
        x-component="Select"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="input"
        title="受控者"
        x-component="Input"
        x-decorator="FormItem"
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

#### SchemaReactions 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, Input, Select } from '@formily/antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    Select,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.String
        name="select"
        title="控制者"
        default="visible"
        enum={[
          { label: '显示', value: 'visible' },
          { label: '隐藏', value: 'none' },
          { label: '隐藏-保留值', value: 'hidden' },
        ]}
        x-component="Select"
        x-decorator="FormItem"
        x-reactions={{
          target: 'input',
          fulfill: {
            state: {
              display: '{{$self.value}}',
            },
          },
        }}
      />
      <SchemaField.String
        name="input"
        title="受控者"
        x-component="Input"
        x-decorator="FormItem"
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

### 一对多联动

#### Effects 用例

```tsx
import React from 'react'
import { createForm, onFieldValueChange } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, Input, Select } from '@formily/antd'

const form = createForm({
  effects() {
    onFieldValueChange('select', (field) => {
      form.setFieldState('*(input1,input2)', (state) => {
        //对于初始联动，如果字段找不到，setFieldState会将更新推入更新队列，直到字段出现再执行操作
        state.display = field.value
      })
    })
  },
})

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    Select,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.String
        name="select"
        title="控制者"
        default="visible"
        enum={[
          { label: '显示', value: 'visible' },
          { label: '隐藏', value: 'none' },
          { label: '隐藏-保留值', value: 'hidden' },
        ]}
        x-component="Select"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="input1"
        title="受控者"
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="input2"
        title="受控者"
        x-component="Input"
        x-decorator="FormItem"
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

#### SchemaReactions 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, Input, Select } from '@formily/antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    Select,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.String
        name="select"
        title="控制者"
        default="visible"
        enum={[
          { label: '显示', value: 'visible' },
          { label: '隐藏', value: 'none' },
          { label: '隐藏-保留值', value: 'hidden' },
        ]}
        x-component="Select"
        x-decorator="FormItem"
        x-reactions={{
          target: '*(input1,input2)',
          fulfill: {
            state: {
              display: '{{$self.value}}',
            },
          },
        }}
      />
      <SchemaField.String
        name="input1"
        title="受控者"
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="input2"
        title="受控者"
        x-component="Input"
        x-decorator="FormItem"
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

### 依赖联动

#### Effects 用例

```tsx
import React from 'react'
import { createForm, onFieldValueChange } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, Input, NumberPicker } from '@formily/antd'

const form = createForm({
  effects() {
    onFieldValueChange('dim_1', (field) => {
      const dim1 = field.value
      const dim2 = field.query('dim_2').value()
      form.setFieldState('result', (state) => {
        state.value = dim1 * dim2
      })
    })
    onFieldValueChange('dim_2', (field) => {
      const dim1 = field.query('dim_1').value()
      const dim2 = field.value || 0
      form.setFieldState('result', (state) => {
        state.value = dim1 * dim2
      })
    })
  },
})

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    NumberPicker,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.Number
        name="dim_1"
        title="控制者"
        default={0}
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
      <SchemaField.Number
        name="dim_2"
        title="控制者"
        default={0}
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
      <SchemaField.Number
        name="result"
        title="受控者"
        x-pattern="readPretty"
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

#### SchemaReactions 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, Input, NumberPicker } from '@formily/antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    NumberPicker,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.Number
        name="dim_1"
        title="控制者"
        default={0}
        x-component="NumberPicker"
        x-decorator="FormItem"
        x-reactions={{
          dependencies: ['dim_2'],
          target: 'result',
          fulfill: {
            state: {
              value: '{{$self.value * $deps[0]}}',
            },
          },
        }}
      />
      <SchemaField.Number
        name="dim_2"
        title="控制者"
        default={0}
        x-component="NumberPicker"
        x-decorator="FormItem"
        x-reactions={{
          dependencies: ['dim_1'],
          target: 'result',
          fulfill: {
            state: {
              value: '{{$self.value * $deps[0]}}',
            },
          },
        }}
      />
      <SchemaField.Number
        name="result"
        title="受控者"
        x-pattern="readPretty"
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

### 链式联动

#### Effects 用例

```tsx
import React from 'react'
import { createForm, onFieldValueChange } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, Input, Select } from '@formily/antd'

const form = createForm({
  effects() {
    onFieldValueChange('select', (field) => {
      form.setFieldState('input1', (state) => {
        //对于初始联动，如果字段找不到，setFieldState会将更新推入更新队列，直到字段出现再执行操作
        state.visible = !!field.value
      })
    })
    onFieldValueChange('input1', (field) => {
      form.setFieldState('input2', (state) => {
        //对于初始联动，如果字段找不到，setFieldState会将更新推入更新队列，直到字段出现再执行操作
        state.visible = !!field.value
      })
    })
  },
})

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    Select,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.String
        name="select"
        title="控制者"
        default={false}
        enum={[
          { label: '显示', value: true },
          { label: '隐藏', value: false },
        ]}
        x-component="Select"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="input1"
        title="受控者"
        default={true}
        enum={[
          { label: '显示', value: true },
          { label: '隐藏', value: false },
        ]}
        x-component="Select"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="input2"
        title="受控者"
        x-component="Input"
        x-decorator="FormItem"
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

#### SchemaReactions 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, Input, Select } from '@formily/antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    Select,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.String
        name="select"
        title="控制者"
        default={false}
        enum={[
          { label: '显示', value: true },
          { label: '隐藏', value: false },
        ]}
        x-component="Select"
        x-decorator="FormItem"
        x-reactions={{
          target: 'input1',
          fulfill: {
            state: {
              visible: '{{!!$self.value}}',
            },
          },
        }}
      />
      <SchemaField.String
        name="input1"
        title="受控者"
        default={true}
        enum={[
          { label: '显示', value: true },
          { label: '隐藏', value: false },
        ]}
        x-component="Select"
        x-decorator="FormItem"
        x-reactions={{
          target: 'input2',
          fulfill: {
            state: {
              visible: '{{!!$self.value}}',
            },
          },
        }}
      />
      <SchemaField.String
        name="input2"
        title="受控者"
        x-component="Input"
        x-decorator="FormItem"
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

### 循环联动

#### Effects 用例

```tsx
import React from 'react'
import { createForm, onFieldInputValueChange } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, NumberPicker } from '@formily/antd'

const form = createForm({
  effects() {
    onFieldInputValueChange('total', (field) => {
      if (field.value === undefined) return
      form.setFieldState('count', (state) => {
        const price = form.values.price
        if (!price) return
        state.value = field.value / price
      })
      form.setFieldState('price', (state) => {
        const count = form.values.count
        if (!count) return
        state.value = field.value / count
      })
    })
    onFieldInputValueChange('price', (field) => {
      form.setFieldState('total', (state) => {
        const count = form.values.count
        if (count === undefined) return
        state.value = field.value * count
      })
    })
    onFieldInputValueChange('count', (field) => {
      form.setFieldState('total', (state) => {
        const price = form.values.price
        if (price === undefined) return
        state.value = field.value * price
      })
    })
  },
})

const SchemaField = createSchemaField({
  components: {
    FormItem,
    NumberPicker,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.Number
        name="total"
        title="总价"
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
      <SchemaField.Number
        name="count"
        title="数量"
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
      <SchemaField.Number
        name="price"
        title="单价"
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

#### SchemaReactions 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, NumberPicker } from '@formily/antd'
const form = createForm()

const SchemaField = createSchemaField({
  components: {
    FormItem,
    NumberPicker,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.Number
        name="total"
        title="总价"
        x-component="NumberPicker"
        x-decorator="FormItem"
        x-reactions={[
          {
            target: 'count',
            effects: ['onFieldInputValueChange'],
            dependencies: ['price'],
            fulfill: {
              state: {
                value: '{{$deps[0] ? $self.value / $deps[0] : $target.value}}',
              },
            },
          },
          {
            target: 'price',
            effects: ['onFieldInputValueChange'],
            dependencies: ['count'],
            fulfill: {
              state: {
                value: '{{$deps[0] ? $self.value / $deps[0] : $target.value}}',
              },
            },
          },
        ]}
      />
      <SchemaField.Number
        name="count"
        title="数量"
        x-component="NumberPicker"
        x-decorator="FormItem"
        x-reactions={{
          target: 'total',
          effects: ['onFieldInputValueChange'],
          dependencies: ['price'],
          fulfill: {
            state: {
              value:
                '{{$deps[0] !== undefined ? $self.value * $deps[0] : $target.value}}',
            },
          },
        }}
      />
      <SchemaField.Number
        name="price"
        title="单价"
        x-component="NumberPicker"
        x-decorator="FormItem"
        x-reactions={{
          target: 'total',
          effects: ['onFieldInputValueChange'],
          dependencies: ['count'],
          fulfill: {
            state: {
              value:
                '{{$deps[0] !== undefined ? $self.value * $deps[0] : $target.value}}',
            },
          },
        }}
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

### 自身联动

#### Effects 用例

```tsx
import React from 'react'
import { createForm, onFieldValueChange } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, Input } from '@formily/antd'
import './input.less'

const form = createForm({
  effects() {
    onFieldValueChange('color', (field) => {
      field.setComponentProps({
        style: {
          backgroundColor: field.value,
        },
      })
    })
  },
})

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.Number
        name="color"
        default="#FFFFFF"
        title="颜色"
        x-component="Input"
        x-decorator="FormItem"
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

#### SchemaReactions 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, Input } from '@formily/antd'
import './input.less'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.Number
        name="color"
        default="#FFFFFF"
        title="颜色"
        x-component="Input"
        x-decorator="FormItem"
        x-reactions={{
          target: 'color',
          fulfill: {
            state: {
              'component[1].style.backgroundColor': '{{$self.value}}',
            },
            //以下用法也可以
            // schema: {
            //   'x-component-props.style.backgroundColor': '{{$self.value}}',
            // },
          },
        }}
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

### 异步联动

#### Effects 用例

```tsx
import React from 'react'
import { createForm, onFieldValueChange } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, Input, Select } from '@formily/antd'

const form = createForm({
  effects() {
    onFieldValueChange('select', (field) => {
      field.loading = true
      setTimeout(() => {
        field.loading = false
        form.setFieldState('input', (state) => {
          //对于初始联动，如果字段找不到，setFieldState会将更新推入更新队列，直到字段出现再执行操作
          state.display = field.value
        })
      }, 1000)
    })
  },
})

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    Select,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.String
        name="select"
        title="控制者"
        default="visible"
        enum={[
          { label: '显示', value: 'visible' },
          { label: '隐藏', value: 'none' },
          { label: '隐藏-保留值', value: 'hidden' },
        ]}
        x-component="Select"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="input"
        title="受控者"
        x-component="Input"
        x-decorator="FormItem"
        x-visible={false}
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

#### SchemaReactions 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, Input, Select } from '@formily/antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    Select,
  },
  scope: {
    asyncVisible(field, target) {
      field.loading = true
      setTimeout(() => {
        field.loading = false
        form.setFieldState(target, (state) => {
          //对于初始联动，如果字段找不到，setFieldState会将更新推入更新队列，直到字段出现再执行操作
          state.display = field.value
        })
      }, 1000)
    },
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.String
        name="select"
        title="控制者"
        default="visible"
        enum={[
          { label: '显示', value: 'visible' },
          { label: '隐藏', value: 'none' },
          { label: '隐藏-保留值', value: 'hidden' },
        ]}
        x-component="Select"
        x-decorator="FormItem"
        x-reactions={{
          target: 'input',
          effects: ['onFieldInit', 'onFieldValueChange'],
          fulfill: {
            run: 'asyncVisible($self,$target)',
          },
        }}
      />
      <SchemaField.String
        name="input"
        title="受控者"
        x-component="Input"
        x-decorator="FormItem"
        x-visible={false}
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

## 被动模式

被动模式的核心是基于

- [onFieldReact](https://core.formilyjs.org/zh-CN/api/entry/field-effect-hooks#onfieldreact)实现全局响应式逻辑
- [FieldReaction](https://core.formilyjs.org/zh-CN/api/models/field#fieldreaction)实现局部响应式逻辑
- [SchemaReactions](https://react.formilyjs.org/zh-CN/api/shared/schema#schemareactions)实现 Schema 协议中的结构化逻辑描述(内部是基于 FieldReaction 来实现的)

### 一对一联动

#### Effects 用例

```tsx
import React from 'react'
import { createForm, onFieldReact } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, Input, Select } from '@formily/antd'

const form = createForm({
  effects() {
    onFieldReact('input', (field) => {
      field.display = field.query('select').value()
    })
  },
})

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    Select,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.String
        name="select"
        title="控制者"
        default="visible"
        enum={[
          { label: '显示', value: 'visible' },
          { label: '隐藏', value: 'none' },
          { label: '隐藏-保留值', value: 'hidden' },
        ]}
        x-component="Select"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="input"
        title="受控者"
        x-component="Input"
        x-decorator="FormItem"
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

#### SchemaReactions 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, Input, Select } from '@formily/antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    Select,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.String
        name="select"
        title="控制者"
        default="visible"
        enum={[
          { label: '显示', value: 'visible' },
          { label: '隐藏', value: 'none' },
          { label: '隐藏-保留值', value: 'hidden' },
        ]}
        x-component="Select"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="input"
        title="受控者"
        x-component="Input"
        x-decorator="FormItem"
        x-reactions={{
          dependencies: ['select'],
          fulfill: {
            state: {
              display: '{{$deps[0]}}',
            },
          },
        }}
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

### 一对多联动

#### Effects 用例

```tsx
import React from 'react'
import { createForm, onFieldReact } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, Input, Select } from '@formily/antd'

const form = createForm({
  effects() {
    onFieldReact('*(input1,input2)', (field) => {
      field.display = field.query('select').value()
    })
  },
})

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    Select,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.String
        name="select"
        title="控制者"
        default="visible"
        enum={[
          { label: '显示', value: 'visible' },
          { label: '隐藏', value: 'none' },
          { label: '隐藏-保留值', value: 'hidden' },
        ]}
        x-component="Select"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="input1"
        title="受控者"
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="input2"
        title="受控者"
        x-component="Input"
        x-decorator="FormItem"
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

#### SchemaReactions 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, Input, Select } from '@formily/antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    Select,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.String
        name="select"
        title="控制者"
        default="visible"
        enum={[
          { label: '显示', value: 'visible' },
          { label: '隐藏', value: 'none' },
          { label: '隐藏-保留值', value: 'hidden' },
        ]}
        x-component="Select"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="input1"
        title="受控者"
        x-component="Input"
        x-decorator="FormItem"
        x-reactions={{
          dependencies: ['select'],
          fulfill: {
            state: {
              display: '{{$deps[0]}}',
            },
          },
        }}
      />
      <SchemaField.String
        name="input2"
        title="受控者"
        x-component="Input"
        x-decorator="FormItem"
        x-reactions={{
          dependencies: ['select'],
          fulfill: {
            state: {
              display: '{{$deps[0]}}',
            },
          },
        }}
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

### 依赖联动

#### Effects 用例

```tsx
import React from 'react'
import { createForm, onFieldReact } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, Input, NumberPicker } from '@formily/antd'

const form = createForm({
  effects() {
    onFieldReact('result', (field) => {
      field.value = field.query('dim_1').value() * field.query('dim_2').value()
    })
  },
})

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    NumberPicker,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.Number
        name="dim_1"
        title="控制者"
        default={0}
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
      <SchemaField.Number
        name="dim_2"
        title="控制者"
        default={0}
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
      <SchemaField.Number
        name="result"
        title="受控者"
        x-pattern="readPretty"
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

#### SchemaReactions 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, Input, NumberPicker } from '@formily/antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    NumberPicker,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.Number
        name="dim_1"
        title="控制者"
        default={0}
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
      <SchemaField.Number
        name="dim_2"
        title="控制者"
        default={0}
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
      <SchemaField.Number
        name="result"
        title="受控者"
        x-pattern="readPretty"
        x-component="NumberPicker"
        x-decorator="FormItem"
        x-reactions={{
          dependencies: ['dim_1', 'dim_2'],
          fulfill: {
            state: {
              value: '{{$deps[0] * $deps[1]}}',
            },
          },
        }}
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

### 链式联动

#### Effects 用例

```tsx
import React from 'react'
import { createForm, onFieldReact } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, Input, Select } from '@formily/antd'

const form = createForm({
  effects() {
    onFieldReact('input1', (field) => {
      field.visible = !!field.query('select').value()
    })
    onFieldReact('input2', (field) => {
      field.visible = !!field.query('input1').value()
    })
  },
})

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    Select,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.String
        name="select"
        title="控制者"
        default={false}
        enum={[
          { label: '显示', value: true },
          { label: '隐藏', value: false },
        ]}
        x-component="Select"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="input1"
        title="受控者"
        default={true}
        enum={[
          { label: '显示', value: true },
          { label: '隐藏', value: false },
        ]}
        x-component="Select"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="input2"
        title="受控者"
        x-component="Input"
        x-decorator="FormItem"
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

#### SchemaReactions 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, Input, Select } from '@formily/antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    Select,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.String
        name="select"
        title="控制者"
        default={false}
        enum={[
          { label: '显示', value: true },
          { label: '隐藏', value: false },
        ]}
        x-component="Select"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="input1"
        title="受控者"
        default={true}
        enum={[
          { label: '显示', value: true },
          { label: '隐藏', value: false },
        ]}
        x-component="Select"
        x-decorator="FormItem"
        x-reactions={{
          dependencies: ['select'],
          fulfill: {
            state: {
              visible: '{{!!$deps[0]}}',
            },
          },
        }}
      />
      <SchemaField.String
        name="input2"
        title="受控者"
        x-component="Input"
        x-decorator="FormItem"
        x-reactions={{
          dependencies: ['input1'],
          fulfill: {
            state: {
              visible: '{{!!$deps[0]}}',
            },
          },
        }}
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

### 循环联动

#### Effects 用例

```tsx
import React from 'react'
import { createForm, onFieldReact } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, NumberPicker } from '@formily/antd'

const form = createForm({
  effects() {
    onFieldReact('total', (field) => {
      const count = field.query('count').value()
      const price = field.query('price').value()
      if (count !== undefined && price !== undefined) {
        field.value = count * price
      }
    })
    onFieldReact('price', (field) => {
      const total = field.query('total').value()
      const count = field.query('count').value()
      if (total !== undefined && count > 0) {
        field.value = total / count
      }
    })
    onFieldReact('count', (field) => {
      const total = field.query('total').value()
      const price = field.query('price').value()
      if (total !== undefined && price > 0) {
        field.value = total / price
      }
    })
  },
})

const SchemaField = createSchemaField({
  components: {
    FormItem,
    NumberPicker,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.Number
        name="total"
        title="总价"
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
      <SchemaField.Number
        name="count"
        title="数量"
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
      <SchemaField.Number
        name="price"
        title="单价"
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

#### SchemaReactions 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, NumberPicker } from '@formily/antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    FormItem,
    NumberPicker,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.Number
        name="total"
        title="总价"
        x-component="NumberPicker"
        x-decorator="FormItem"
        x-reactions={{
          dependencies: ['.count', '.price'],
          fulfill: {
            state: {
              value:
                '{{$deps[0] !== undefined && $deps[1] !== undefined ? $deps[0] * $deps[1] : $self.value}}',
            },
          },
        }}
      />
      <SchemaField.Number
        name="count"
        title="数量"
        x-component="NumberPicker"
        x-decorator="FormItem"
        x-reactions={{
          dependencies: ['.total', '.price'],
          fulfill: {
            state: {
              value: '{{ $deps[1] > 0 ? $deps[0] / $deps[1] : $self.value}}',
            },
          },
        }}
      />
      <SchemaField.Number
        name="price"
        title="单价"
        x-component="NumberPicker"
        x-decorator="FormItem"
        x-reactions={{
          dependencies: ['.total', '.count'],
          fulfill: {
            state: {
              value: '{{ $deps[1] > 0 ? $deps[0] / $deps[1] : $self.value}}',
            },
          },
        }}
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

### 自身联动

#### Effects 用例

```tsx
import React from 'react'
import { createForm, onFieldReact } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, Input } from '@formily/antd'
import './input.less'

const form = createForm({
  effects() {
    onFieldReact('color', (field) => {
      field.setComponentProps({
        style: {
          backgroundColor: field.value,
        },
      })
    })
  },
})

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.Number
        name="color"
        default="#FFFFFF"
        title="颜色"
        x-component="Input"
        x-decorator="FormItem"
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

#### SchemaReactions 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, Input } from '@formily/antd'
import './input.less'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.Number
        name="color"
        default="#FFFFFF"
        title="颜色"
        x-component="Input"
        x-decorator="FormItem"
        x-reactions={{
          fulfill: {
            state: {
              'component[1].style.backgroundColor': '{{$self.value}}',
            },
            //以下用法也可以
            // schema: {
            //   'x-component-props.style.backgroundColor': '{{$self.value}}',
            // },
          },
        }}
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

### 异步联动

#### Effects 用例

```tsx
import React from 'react'
import { createForm, onFieldReact } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, Input, Select } from '@formily/antd'

const form = createForm({
  effects() {
    onFieldReact('input', (field) => {
      const select = field.query('select').take()
      if (!select) return
      const selectValue = select.value
      select.loading = true
      if (selectValue) {
        setTimeout(() => {
          select.loading = false
          field.display = selectValue
        }, 1000)
      }
    })
  },
})

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    Select,
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.String
        name="select"
        title="控制者"
        default="visible"
        enum={[
          { label: '显示', value: 'visible' },
          { label: '隐藏', value: 'none' },
          { label: '隐藏-保留值', value: 'hidden' },
        ]}
        x-component="Select"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="input"
        title="受控者"
        x-component="Input"
        x-decorator="FormItem"
        x-visible={false}
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```

#### SchemaReactions 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField, FormConsumer } from '@formily/react'
import { Form, FormItem, Input, Select } from '@formily/antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    Select,
  },
  scope: {
    asyncVisible(field) {
      const select = field.query('select').take()
      if (!select) return
      const selectValue = select.value
      select.loading = true
      if (selectValue) {
        setTimeout(() => {
          select.loading = false
          field.display = selectValue
        }, 1000)
      }
    },
  },
})

export default () => (
  <Form form={form}>
    <SchemaField>
      <SchemaField.String
        name="select"
        title="控制者"
        default="visible"
        enum={[
          { label: '显示', value: 'visible' },
          { label: '隐藏', value: 'none' },
          { label: '隐藏-保留值', value: 'hidden' },
        ]}
        x-component="Select"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="input"
        title="受控者"
        x-component="Input"
        x-decorator="FormItem"
        x-visible={false}
        x-reactions="{{asyncVisible}}"
      />
    </SchemaField>
    <FormConsumer>
      {() => (
        <code>
          <pre>{JSON.stringify(form.values, null, 2)}</pre>
        </code>
      )}
    </FormConsumer>
  </Form>
)
```
</file>

<file path="docs/guide/advanced/validate.zh-CN.md">
# 表单校验

Formily 的表单校验使用了极其强大且灵活的@formily/validator 校验引擎，校验主要分两种场景：

- Markup(JSON) Schema 场景协议校验属性校验，使用 JSON Schema 本身的校验属性与 x-validator 属性实现校验
- 纯 JSX 场景校验属性，使用 validator 属性实现校验

同时我们还能在 effects 或者 x-reactions/reactions 中实现联动校验

具体规则校验文档参考 [FieldValidator](https://core.formilyjs.org/zh-CN/api/models/field#fieldvalidator)

表单校验是表单中优化用户体验和保证数据准确性的重要一环，Formily 提供了多种校验方式，包括内置规则校验、内置格式校验、自定义规则校验等，下面我们将逐一介绍这些校验方式。

## 内置规则校验

内置规则校验是指 Formily 提供的一些常用校验规则，比如必填、最大值、最小值、长度、枚举、常量、整除等，实现了最简单和最通用的校验，这些规则可以通过 JSON Schema 的属性描述，也可以通过 x-validator 属性描述。Formily 支持多种形式的内置规则书写方式，建议团队内部根据使用习惯制定团队规范。

#### Markup Schema 案例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField } from '@formily/react'
import { Form, FormItem, Input, NumberPicker } from '@formily/antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
    NumberPicker,
  },
})

export default () => (
  <Form form={form} labelCol={6} wrapperCol={10}>
    <SchemaField>
      <SchemaField.String
        name="required_1"
        title="必填"
        required
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="required_2"
        title="必填"
        x-validator={{ required: true }}
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="required_3"
        title="必填"
        x-validator={[{ required: true }]}
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.Number
        name="max_1"
        title="最大值(>5报错)"
        maximum={5}
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
      <SchemaField.Number
        name="max_2"
        title="最大值(>5报错)"
        x-validator={{ maximum: 5 }}
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
      <SchemaField.Number
        name="max_3"
        title="最大值(>5报错)"
        x-validator={[{ maximum: 5 }]}
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
      <SchemaField.Number
        name="max_4"
        title="最大值(>=5报错)"
        exclusiveMaximum={5}
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
      <SchemaField.Number
        name="max_5"
        title="最大值(>=5报错)"
        x-validator={{ exclusiveMaximum: 5 }}
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
      <SchemaField.Number
        name="max_6"
        title="最大值(>=5报错)"
        x-validator={[{ exclusiveMaximum: 5 }]}
        x-component="NumberPicker"
        x-decorator="FormItem"
      />

      <SchemaField.Number
        name="min_1"
        title="最小值(<5报错)"
        minimum={5}
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
      <SchemaField.Number
        name="min_2"
        title="最小值(<5报错)"
        x-validator={{ minimum: 5 }}
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
      <SchemaField.Number
        name="min_3"
        title="最小值(<5报错)"
        x-validator={[{ minimum: 5 }]}
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
      <SchemaField.Number
        name="min_4"
        title="最小值(<=5报错)"
        exclusiveMinimum={5}
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
      <SchemaField.Number
        name="min_5"
        title="最小值(<=5报错)"
        x-validator={{ exclusiveMinimum: 5 }}
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
      <SchemaField.Number
        name="min_6"
        title="最小值(<=5报错)"
        x-validator={[{ exclusiveMinimum: 5 }]}
        x-component="NumberPicker"
        x-decorator="FormItem"
      />

      <SchemaField.String
        name="length_1"
        title="长度为5"
        x-validator={{ len: 5 }}
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="length_2"
        title="长度为5"
        x-validator={[{ len: 5 }]}
        x-component="Input"
        x-decorator="FormItem"
      />

      <SchemaField.String
        name="maxlength_1"
        title="最大长度为5"
        maxLength={5}
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="maxlength_2"
        title="最大长度为5"
        x-validator={{ max: 5 }}
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="maxlength_3"
        title="最大长度为5"
        x-validator={[{ max: 5 }]}
        x-component="Input"
        x-decorator="FormItem"
      />

      <SchemaField.String
        name="maxlength_4"
        title="最小长度为5"
        minLength={5}
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="maxlength_5"
        title="最小长度为5"
        x-validator={{ min: 5 }}
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="maxlength_6"
        title="最小长度为5"
        x-validator={[{ min: 5 }]}
        x-component="Input"
        x-decorator="FormItem"
      />

      <SchemaField.String
        name="whitespace"
        title="排除纯空白字符"
        x-validator={[{ whitespace: true }]}
        x-component="Input"
        x-decorator="FormItem"
      />

      <SchemaField.String
        name="enum"
        title="枚举匹配"
        x-validator={[{ enum: ['1', '2', '3'] }]}
        x-component="Input"
        x-decorator="FormItem"
      />

      <SchemaField.String
        name="const"
        title="常量匹配"
        const="123"
        x-component="Input"
        x-decorator="FormItem"
      />

      <SchemaField.String
        name="multipleOf"
        title="整除匹配"
        multipleOf={2}
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
    </SchemaField>
  </Form>
)
```

#### JSON Schema 案例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField } from '@formily/react'
import { Form, FormItem, Input, NumberPicker } from '@formily/antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
    NumberPicker,
  },
})

const schema = {
  type: 'object',
  properties: {
    required_1: {
      name: 'required_1',
      title: '必填',
      type: 'string',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    required_2: {
      name: 'required_2',
      title: '必填',
      type: 'string',
      'x-validator': {
        required: true,
      },
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    required_3: {
      name: 'required_3',
      title: '必填',
      type: 'string',
      'x-validator': [
        {
          required: true,
        },
      ],
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    max_1: {
      name: 'max_1',
      title: '最大值(>5报错)',
      type: 'number',
      maximum: 5,
      'x-decorator': 'FormItem',
      'x-component': 'NumberPicker',
    },
    max_2: {
      name: 'max_2',
      title: '最大值(>5报错)',
      type: 'number',
      'x-validator': {
        maximum: 5,
      },
      'x-decorator': 'FormItem',
      'x-component': 'NumberPicker',
    },
    max_3: {
      name: 'max_3',
      title: '最大值(>5报错)',
      type: 'number',
      'x-validator': [
        {
          maximum: 5,
        },
      ],
      'x-decorator': 'FormItem',
      'x-component': 'NumberPicker',
    },
    max_4: {
      name: 'max_4',
      title: '最大值(>=5报错)',
      type: 'number',
      exclusiveMaximum: 5,
      'x-decorator': 'FormItem',
      'x-component': 'NumberPicker',
    },
    max_5: {
      name: 'max_5',
      title: '最大值(>=5报错)',
      type: 'number',
      'x-validator': {
        exclusiveMaximum: 5,
      },
      'x-decorator': 'FormItem',
      'x-component': 'NumberPicker',
    },
    max_6: {
      name: 'max_6',
      title: '最大值(>=5报错)',
      type: 'number',
      'x-validator': [
        {
          exclusiveMaximum: 5,
        },
      ],
      'x-decorator': 'FormItem',
      'x-component': 'NumberPicker',
    },
    min_1: {
      name: 'min_1',
      title: '最小值(<5报错)',
      type: 'number',
      minimum: 5,
      'x-decorator': 'FormItem',
      'x-component': 'NumberPicker',
    },
    min_2: {
      name: 'min_2',
      title: '最小值(<5报错)',
      type: 'number',
      'x-validator': {
        minimum: 5,
      },
      'x-decorator': 'FormItem',
      'x-component': 'NumberPicker',
    },
    min_3: {
      name: 'min_3',
      title: '最小值(<5报错)',
      type: 'string',
      'x-validator': [
        {
          minimum: 5,
        },
      ],
      'x-decorator': 'FormItem',
      'x-component': 'NumberPicker',
    },
    min_4: {
      name: 'min_4',
      title: '最小值(<=5报错)',
      type: 'number',
      exclusiveMinimum: 5,
      'x-decorator': 'FormItem',
      'x-component': 'NumberPicker',
    },
    min_5: {
      name: 'min_5',
      title: '最小值(<=5报错)',
      type: 'number',
      'x-validator': {
        exclusiveMinimum: 5,
      },
      'x-decorator': 'FormItem',
      'x-component': 'NumberPicker',
    },
    min_6: {
      name: 'min_6',
      title: '最小值(<=5报错)',
      type: 'number',
      'x-validator': [
        {
          exclusiveMinimum: 5,
        },
      ],
      'x-decorator': 'FormItem',
      'x-component': 'NumberPicker',
    },
    length_1: {
      name: 'length_1',
      title: '长度为5',
      type: 'string',
      'x-validator': {
        len: 5,
      },
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    length_2: {
      name: 'length_2',
      title: '长度为5',
      type: 'string',
      'x-validator': [
        {
          len: 5,
        },
      ],
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    maxlength_1: {
      name: 'maxlength_1',
      title: '最大长度为5',
      type: 'string',
      maxLength: 5,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    maxlength_2: {
      name: 'maxlength_2',
      title: '最大长度为5',
      type: 'string',
      'x-validator': {
        max: 5,
      },
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    maxlength_3: {
      name: 'maxlength_3',
      title: '最大长度为5',
      type: 'string',
      'x-validator': [
        {
          max: 5,
        },
      ],
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    minlength_1: {
      name: 'minlength_1',
      title: '最小长度为5',
      type: 'string',
      minLength: 5,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    minlength_2: {
      name: 'minlength_2',
      title: '最小长度为5',
      type: 'string',
      'x-validator': {
        min: 5,
      },
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    minlength_3: {
      name: 'minlength_3',
      title: '最小长度为5',
      type: 'string',
      'x-validator': [
        {
          min: 5,
        },
      ],
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    whitespace: {
      name: 'whitespace',
      title: '排除纯空白字符',
      type: 'string',
      'x-validator': [
        {
          whitespace: true,
        },
      ],
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    enum: {
      name: 'enum',
      title: '枚举匹配',
      type: 'string',
      'x-validator': [
        {
          enum: ['1', '2', '3'],
        },
      ],
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    const: {
      name: 'const',
      title: '常量匹配',
      type: 'string',
      const: '123',
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    multipleOf: {
      name: 'multipleOf',
      title: '整除匹配',
      type: 'string',
      multipleOf: 2,
      'x-decorator': 'FormItem',
      'x-component': 'NumberPicker',
    },
  },
}

export default () => (
  <Form form={form} labelCol={6} wrapperCol={10}>
    <SchemaField schema={schema} />
  </Form>
)
```

#### 纯 JSX 案例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { Field } from '@formily/react'
import { Form, FormItem, Input, NumberPicker } from '@formily/antd'

const form = createForm()

export default () => (
  <Form form={form} labelCol={6} wrapperCol={10}>
    <Field
      name="required_1"
      title="必填"
      required
      component={[Input]}
      decorator={[FormItem]}
    />
    <Field
      name="required_2"
      title="必填"
      validator={{ required: true }}
      component={[Input]}
      decorator={[FormItem]}
    />
    <Field
      name="required_3"
      title="必填"
      validator={[{ required: true }]}
      component={[Input]}
      decorator={[FormItem]}
    />
    <Field
      name="max_1"
      title="最大值(>5报错)"
      validator={{ maximum: 5 }}
      component={[NumberPicker]}
      decorator={[FormItem]}
    />
    <Field
      name="max_2"
      title="最大值(>5报错)"
      validator={[{ maximum: 5 }]}
      component={[NumberPicker]}
      decorator={[FormItem]}
    />
    <Field
      name="max_3"
      title="最大值(>=5报错)"
      validator={{ exclusiveMaximum: 5 }}
      component={[NumberPicker]}
      decorator={[FormItem]}
    />
    <Field
      name="max_4"
      title="最大值(>=5报错)"
      validator={[{ exclusiveMaximum: 5 }]}
      component={[NumberPicker]}
      decorator={[FormItem]}
    />
    <Field
      name="min_1"
      title="最小值(<5报错)"
      validator={{ minimum: 5 }}
      component={[NumberPicker]}
      decorator={[FormItem]}
    />
    <Field
      name="min_2"
      title="最小值(<5报错)"
      validator={[{ minimum: 5 }]}
      component={[NumberPicker]}
      decorator={[FormItem]}
    />
    <Field
      name="min_3"
      title="最小值(<=5报错)"
      validator={{ exclusiveMinimum: 5 }}
      component={[NumberPicker]}
      decorator={[FormItem]}
    />
    <Field
      name="min_4"
      title="最小值(<=5报错)"
      validator={[{ exclusiveMinimum: 5 }]}
      component={[NumberPicker]}
      decorator={[FormItem]}
    />

    <Field
      name="length_1"
      title="长度为5"
      validator={{ len: 5 }}
      component={[Input]}
      decorator={[FormItem]}
    />
    <Field
      name="length_2"
      title="长度为5"
      validator={[{ len: 5 }]}
      component={[Input]}
      decorator={[FormItem]}
    />
    <Field
      name="maxlength_1"
      title="最大长度为5"
      validator={{ max: 5 }}
      component={[Input]}
      decorator={[FormItem]}
    />
    <Field
      name="maxlength_2"
      title="最大长度为5"
      validator={[{ max: 5 }]}
      component={[Input]}
      decorator={[FormItem]}
    />
    <Field
      name="minlength_1"
      title="最小长度为5"
      validator={{ min: 5 }}
      component={[Input]}
      decorator={[FormItem]}
    />
    <Field
      name="minlength_2"
      title="最小长度为5"
      validator={[{ min: 5 }]}
      component={[Input]}
      decorator={[FormItem]}
    />

    <Field
      name="whitespace"
      title="排除纯空白字符"
      validator={[{ whitespace: true }]}
      component={[Input]}
      decorator={[FormItem]}
    />
  </Form>
)
```

## 内置格式校验

#### Markup Schema 案例

```tsx
import React, { Fragment } from 'react'
import { createForm } from '@formily/core'
import { createSchemaField } from '@formily/react'
import { Form, FormItem, Input } from '@formily/antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const renderFormat = (format: string, key: number) => {
  return (
    <Fragment key={key}>
      <SchemaField.String
        name={`${format}_1`}
        title={`${format}格式`}
        format={format}
        required
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name={`${format}_2`}
        title={`${format}格式`}
        required
        x-validator={format}
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name={`${format}_3`}
        title={`${format}格式`}
        required
        x-validator={{ format }}
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name={`${format}_4`}
        title={`${format}格式`}
        required
        x-validator={[format]}
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name={`${format}_5`}
        title={`${format}格式`}
        required
        x-validator={[{ format }]}
        x-component="Input"
        x-decorator="FormItem"
      />
    </Fragment>
  )
}

const FORMATS = [
  'url',
  'email',
  'phone',
  'ipv6',
  'ipv4',
  'number',
  'integer',
  'qq',
  'idcard',
  'money',
  'zh',
  'date',
  'zip',
]

export default () => (
  <Form form={form} labelCol={6} wrapperCol={10}>
    <SchemaField>{FORMATS.map(renderFormat)}</SchemaField>
  </Form>
)
```

#### JSON Schema 案例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField } from '@formily/react'
import { Form, FormItem, Input } from '@formily/antd'

const form = createForm()

const schema = {
  type: 'object',
  properties: {},
}

const FORMATS = [
  'url',
  'email',
  'phone',
  'ipv6',
  'ipv4',
  'number',
  'integer',
  'qq',
  'idcard',
  'money',
  'zh',
  'date',
  'zip',
]

FORMATS.forEach((key) => {
  Object.assign(schema.properties, {
    [`${key}_1`]: {
      title: `${key}格式`,
      type: 'string',
      required: true,
      format: key,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    [`${key}_2`]: {
      title: `${key}格式`,
      type: 'string',
      required: true,
      'x-validator': key,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    [`${key}_3`]: {
      title: `${key}格式`,
      type: 'string',
      required: true,
      'x-validator': {
        format: key,
      },
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    [`${key}_4`]: {
      title: `${key}格式`,
      type: 'string',
      required: true,
      'x-validator': [key],
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },

    [`${key}_5`]: {
      title: `${key}格式`,
      type: 'string',
      required: true,
      'x-validator': [
        {
          format: key,
        },
      ],
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
  })
})

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

export default () => (
  <Form form={form} labelCol={6} wrapperCol={10}>
    <SchemaField schema={schema} />
  </Form>
)
```

#### 纯 JSX 案例

```tsx
import React, { Fragment } from 'react'
import { createForm } from '@formily/core'
import { Field } from '@formily/react'
import { Form, FormItem, Input } from '@formily/antd'

const form = createForm()

const renderFormat = (format: string, key: number) => {
  return (
    <Fragment key={key}>
      <Field
        name={`${format}_1`}
        title={`${format}格式`}
        required
        validator={format}
        component={[Input]}
        decorator={[FormItem]}
      />
      <Field
        name={`${format}_2`}
        title={`${format}格式`}
        required
        validator={{ format }}
        component={[Input]}
        decorator={[FormItem]}
      />
      <Field
        name={`${format}_3`}
        title={`${format}格式`}
        required
        validator={[format]}
        component={[Input]}
        decorator={[FormItem]}
      />
      <Field
        name={`${format}_4`}
        title={`${format}格式`}
        required
        validator={[{ format }]}
        component={[Input]}
        decorator={[FormItem]}
      />
    </Fragment>
  )
}

const FORMATS = [
  'url',
  'email',
  'phone',
  'ipv6',
  'ipv4',
  'number',
  'integer',
  'qq',
  'idcard',
  'money',
  'zh',
  'date',
  'zip',
]

export default () => (
  <Form form={form} labelCol={6} wrapperCol={10}>
    {FORMATS.map(renderFormat)}
  </Form>
)
```

## 自定义规则校验

#### Markup Schema 案例

```tsx
import React from 'react'
import { createForm, registerValidateRules } from '@formily/core'
import { createSchemaField } from '@formily/react'
import { Form, FormItem, Input, NumberPicker } from '@formily/antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
    NumberPicker,
  },
})

registerValidateRules({
  global_1(value) {
    if (!value) return ''
    return value !== '123' ? '错误了❎' : ''
  },
  global_2(value, rule) {
    if (!value) return ''
    return value !== '123' ? rule.message : ''
  },
  global_3(value) {
    if (!value) return ''
    return value === '123'
  },
  global_4(value) {
    if (!value) return ''
    if (value < 10) {
      return {
        type: 'error',
        message: '数值不能小于10',
      }
    } else if (value < 100) {
      return {
        type: 'warning',
        message: '数值在100以内',
      }
    } else if (value < 1000) {
      return {
        type: 'success',
        message: '数值大于100小于1000',
      }
    }
  },
})

export default () => (
  <Form form={form} labelCol={6} wrapperCol={10}>
    <SchemaField>
      <SchemaField.String
        name="global_style_1"
        title="全局注册风格"
        required
        x-validator={{
          global_1: true,
        }}
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="global_style_2"
        title="全局注册风格"
        required
        x-validator={{
          global_2: true,
          message: '错误了❎',
        }}
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="global_style_3"
        title="全局注册风格"
        required
        x-validator={{
          global_3: true,
          message: '错误了❎',
        }}
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.Number
        name="global_style_4"
        title="全局注册风格"
        required
        x-validator={{
          global_4: true,
        }}
        x-component="NumberPicker"
        x-decorator="FormItem"
      />

      <SchemaField.String
        name="validator_style_1"
        title="局部定义风格"
        required
        x-validator={(value) => {
          if (!value) return ''
          return value !== '123' ? '错误了❎' : ''
        }}
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="validator_style_2"
        title="局部定义风格"
        required
        x-validator={{
          validator(value, rule) {
            if (!value) return ''
            return value !== '123' ? rule.message : ''
          },
          message: '错误了❎',
        }}
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="validator_style_3"
        title="局部定义风格"
        required
        x-validator={{
          validator(value) {
            if (!value) return ''
            return value === '123'
          },
          message: '错误了❎',
        }}
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.Number
        name="validator_style_4"
        title="局部定义风格"
        required
        x-validator={(value) => {
          if (!value) return ''
          if (value < 10) {
            return {
              type: 'error',
              message: '数值不能小于10',
            }
          } else if (value < 100) {
            return {
              type: 'warning',
              message: '数值在100以内',
            }
          } else if (value < 1000) {
            return {
              type: 'success',
              message: '数值大于100小于1000',
            }
          }
        }}
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
    </SchemaField>
  </Form>
)
```

#### JSON Schema 案例

```tsx
import React from 'react'
import { createForm, registerValidateRules } from '@formily/core'
import { createSchemaField } from '@formily/react'
import { Form, FormItem, Input, NumberPicker } from '@formily/antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
    NumberPicker,
  },
})

registerValidateRules({
  global_1(value) {
    if (!value) return ''
    return value !== '123' ? '错误了❎' : ''
  },
  global_2(value, rule) {
    if (!value) return ''
    return value !== '123' ? rule.message : ''
  },
  global_3(value) {
    if (!value) return ''
    return value === '123'
  },
  global_4(value) {
    if (!value) return ''
    if (value < 10) {
      return {
        type: 'error',
        message: '数值不能小于10',
      }
    } else if (value < 100) {
      return {
        type: 'warning',
        message: '数值在100以内',
      }
    } else if (value < 1000) {
      return {
        type: 'success',
        message: '数值大于100小于1000',
      }
    }
  },
})

const schema = {
  type: 'object',
  properties: {
    global_style_1: {
      title: '全局注册风格',
      required: true,
      'x-validator': {
        global_1: true,
      },
      'x-component': 'Input',
      'x-decorator': 'FormItem',
    },
    global_style_2: {
      title: '全局注册风格',
      required: true,
      'x-validator': {
        global_2: true,
        message: '错误了❎',
      },
      'x-component': 'Input',
      'x-decorator': 'FormItem',
    },
    global_style_3: {
      title: '全局注册风格',
      required: true,
      'x-validator': {
        global_3: true,
        message: '错误了❎',
      },
      'x-component': 'Input',
      'x-decorator': 'FormItem',
    },
    global_style_4: {
      title: '全局注册风格',
      required: true,
      'x-validator': {
        global_4: true,
      },
      'x-component': 'Input',
      'x-decorator': 'FormItem',
    },

    validator_style_1: {
      title: '局部定义风格',
      required: true,
      'x-validator': `{{(value)=> {
            if (!value) return ''
            return value !== '123' ? '错误了❎' : ''
          }}}`,
      'x-component': 'Input',
      'x-decorator': 'FormItem',
    },
    validator_style_2: {
      title: '局部定义风格',
      required: true,
      'x-validator': {
        validator: `{{(value, rule)=> {
            if (!value) return ''
            return value !== '123' ? rule.message : ''
          }}}`,
        message: '错误了❎',
      },
      'x-component': 'Input',
      'x-decorator': 'FormItem',
    },
    validator_style_3: {
      title: '局部定义风格',
      required: true,
      'x-validator': {
        validator: `{{(value, rule)=> {
          if (!value) return ''
          return value === '123'
        }}}`,
        message: '错误了❎',
      },
      'x-component': 'Input',
      'x-decorator': 'FormItem',
    },
    validator_style_4: {
      title: '局部定义风格',
      required: true,
      'x-validator': `{{(value, rule)=> {
          if (!value) return ''
          if (value < 10) {
            return {
              type: 'error',
              message: '数值不能小于10',
            }
          } else if (value < 100) {
            return {
              type: 'warning',
              message: '数值在100以内',
            }
          } else if (value < 1000) {
            return {
              type: 'success',
              message: '数值大于100小于1000',
            }
          }
        }}}`,
      'x-component': 'Input',
      'x-decorator': 'FormItem',
    },
  },
}

export default () => (
  <Form form={form} labelCol={6} wrapperCol={10}>
    <SchemaField schema={schema} />
  </Form>
)
```

#### 纯 JSX 案例

```tsx
import React from 'react'
import { createForm, registerValidateRules } from '@formily/core'
import { Field } from '@formily/react'
import { Form, FormItem, Input, NumberPicker } from '@formily/antd'

const form = createForm()

registerValidateRules({
  global_1(value) {
    if (!value) return ''
    return value !== '123' ? '错误了❎' : ''
  },
  global_2(value, rule) {
    if (!value) return ''
    return value !== '123' ? rule.message : ''
  },
  global_3(value) {
    if (!value) return ''
    return value === '123'
  },
  global_4(value) {
    if (!value) return ''
    if (value < 10) {
      return {
        type: 'error',
        message: '数值不能小于10',
      }
    } else if (value < 100) {
      return {
        type: 'warning',
        message: '数值在100以内',
      }
    } else if (value < 1000) {
      return {
        type: 'success',
        message: '数值大于100小于1000',
      }
    }
  },
})

export default () => (
  <Form form={form} labelCol={6} wrapperCol={10}>
    <Field
      name="global_style_1"
      title="全局注册风格"
      required
      validator={{
        global_1: true,
      }}
      component={[Input]}
      decorator={[FormItem]}
    />
    <Field
      name="global_style_2"
      title="全局注册风格"
      required
      validator={{
        global_2: true,
        message: '错误了❎',
      }}
      component={[Input]}
      decorator={[FormItem]}
    />
    <Field
      name="global_style_3"
      title="全局注册风格"
      required
      validator={{
        global_3: true,
        message: '错误了❎',
      }}
      component={[Input]}
      decorator={[FormItem]}
    />
    <Field
      name="global_style_4"
      title="全局注册风格"
      required
      validator={{
        global_4: true,
      }}
      component={[NumberPicker]}
      decorator={[FormItem]}
    />

    <Field
      name="validator_style_1"
      title="局部定义风格"
      required
      validator={(value) => {
        if (!value) return ''
        return value !== '123' ? '错误了❎' : ''
      }}
      component={[Input]}
      decorator={[FormItem]}
    />
    <Field
      name="validator_style_2"
      title="局部定义风格"
      required
      validator={{
        validator(value, rule) {
          if (!value) return ''
          return value !== '123' ? rule.message : ''
        },
        message: '错误了❎',
      }}
      component={[Input]}
      decorator={[FormItem]}
    />
    <Field
      name="validator_style_3"
      title="局部定义风格"
      required
      validator={{
        validator(value) {
          if (!value) return ''
          return value === '123'
        },
        message: '错误了❎',
      }}
      component={[Input]}
      decorator={[FormItem]}
    />
    <Field
      name="validator_style_4"
      title="局部定义风格"
      required
      validator={(value) => {
        if (!value) return ''
        if (value < 10) {
          return {
            type: 'error',
            message: '数值不能小于10',
          }
        } else if (value < 100) {
          return {
            type: 'warning',
            message: '数值在100以内',
          }
        } else if (value < 1000) {
          return {
            type: 'success',
            message: '数值大于100小于1000',
          }
        }
      }}
      component={[NumberPicker]}
      decorator={[FormItem]}
    />
  </Form>
)
```

## 使用第三方校验库

凭借 Formily 极为强大的校验引擎，能够极为便捷地适配诸如 yup 等第三方校验库。其使用示例如下：

#### JSON Schema 案例

```tsx
import React from 'react'
import { createForm, registerValidateRules } from '@formily/core'
import { createSchemaField } from '@formily/react'
import { Form, FormItem, Input, NumberPicker } from '@formily/antd'
import { string } from 'yup'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
    NumberPicker,
  },
})

registerValidateRules({
  yup: async (value, rule) => {
    try {
      await rule.yup().validate(value)
      return '' // 验证成功时返回空字符串
    } catch (err) {
      return err.errors.join(',') // 验证失败时返回错误信息
    }
  },
})

const schema = {
  type: 'object',
  properties: {
    global_style_1: {
      title: '最大长度为 2',
      'x-validator': [
        {
          triggerType: 'onBlur',
          yup: () => string().required('必填'),
        },
        {
          triggerType: 'onBlur',
          yup: () => string().max(2, '最大长度为 2'),
        },
      ],
      'x-component': 'Input',
      'x-decorator': 'FormItem',
    },
    global_style_2: {
      title: 'email',
      required: true,
      'x-validator': {
        triggerType: 'onBlur',
        yup: () => string().email(),
      },
      'x-component': 'Input',
      'x-decorator': 'FormItem',
    },
  },
}

export default () => (
  <Form form={form} labelCol={6} wrapperCol={10}>
    <SchemaField schema={schema} />
  </Form>
)
```

#### 纯 JSX 案例

```tsx
import React from 'react'
import { createForm, registerValidateRules } from '@formily/core'
import { Field } from '@formily/react'
import { Form, FormItem, Input, NumberPicker } from '@formily/antd'
import { string, number } from 'yup'

const form = createForm()

registerValidateRules({
  yup: async (value, rule) => {
    try {
      await rule.yup().validate(value)
      return '' // 验证成功时返回空字符串
    } catch (err) {
      return err.errors.join(',') // 验证失败时返回错误信息
    }
  },
})

export default () => (
  <Form form={form} labelCol={6} wrapperCol={10}>
    <Field
      name="global_style_1"
      title="email"
      required
      validator={{
        yup: () => string().email(),
      }}
      component={[Input]}
      decorator={[FormItem]}
    />
    <Field
      name="global_style_2"
      title="最大值 30"
      required
      validator={{
        yup: () => number().max(30),
      }}
      component={[NumberPicker]}
      decorator={[FormItem]}
    />
    <Field
      name="global_style_3"
      title="email"
      required
      validator={{
        yup: () => string().email(),
      }}
      component={[Input]}
      decorator={[FormItem]}
    />
  </Form>
)
```

## 自定义格式校验

#### Markup Schema 案例

```tsx
import React from 'react'
import { createForm, registerValidateFormats } from '@formily/core'
import { createSchemaField } from '@formily/react'
import { Form, FormItem, Input } from '@formily/antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

registerValidateFormats({
  custom_format: /123/,
})

export default () => (
  <Form form={form} labelCol={6} wrapperCol={10}>
    <SchemaField>
      <SchemaField.String
        name="global_style_1"
        title="全局注册风格"
        required
        x-validator={{
          format: 'custom_format',
          message: '错误❎',
        }}
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="global_style_2"
        title="全局注册风格"
        required
        x-validator={'custom_format'}
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="global_style_3"
        title="全局注册风格"
        required
        x-validator={['custom_format']}
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.Number
        name="global_style_4"
        title="全局注册风格"
        required
        x-validator={{
          format: 'custom_format',
          message: '错误❎',
        }}
        x-component="Input"
        x-decorator="FormItem"
      />

      <SchemaField.String
        name="validator_style_1"
        title="局部定义风格"
        required
        pattern={/123/}
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="validator_style_2"
        title="局部定义风格"
        required
        pattern="123"
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="validator_style_3"
        title="局部定义风格"
        required
        x-validator={{
          pattern: /123/,
          message: '错误了❎',
        }}
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="validator_style_4"
        title="局部定义风格"
        required
        x-validator={{
          pattern: '123',
          message: '错误了❎',
        }}
        x-component="Input"
        x-decorator="FormItem"
      />
    </SchemaField>
  </Form>
)
```

#### JSON Schema 案例

```tsx
import React from 'react'
import { createForm, registerValidateFormats } from '@formily/core'
import { createSchemaField } from '@formily/react'
import { Form, FormItem, Input } from '@formily/antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

registerValidateFormats({
  custom_format: /123/,
})

const schema = {
  type: 'object',
  properties: {
    global_style_1: {
      title: '全局注册风格',
      required: true,
      'x-validator': {
        format: 'custom_format',
        message: '错误❎',
      },
      'x-component': 'Input',
      'x-decorator': 'FormItem',
    },
    global_style_2: {
      title: '全局注册风格',
      required: true,
      'x-validator': 'custom_format',
      'x-component': 'Input',
      'x-decorator': 'FormItem',
    },
    global_style_3: {
      title: '全局注册风格',
      required: true,
      'x-validator': ['custom_format'],
      'x-component': 'Input',
      'x-decorator': 'FormItem',
    },
    global_style_4: {
      title: '全局注册风格',
      required: true,
      'x-validator': {
        format: 'custom_format',
        message: '错误❎',
      },
      'x-component': 'Input',
      'x-decorator': 'FormItem',
    },
    validator_style_1: {
      title: '局部定义风格',
      required: true,
      pattern: /123/,
      'x-component': 'Input',
      'x-decorator': 'FormItem',
    },
    validator_style_2: {
      title: '局部定义风格',
      required: true,
      pattern: '123',
      'x-component': 'Input',
      'x-decorator': 'FormItem',
    },
    validator_style_3: {
      title: '局部定义风格',
      required: true,
      'x-validator': {
        pattern: /123/,
        message: '错误了❎',
      },
      'x-component': 'Input',
      'x-decorator': 'FormItem',
    },
    validator_style_4: {
      title: '局部定义风格',
      required: true,
      'x-validator': {
        pattern: '123',
        message: '错误了❎',
      },
      'x-component': 'Input',
      'x-decorator': 'FormItem',
    },
  },
}

export default () => (
  <Form form={form} labelCol={6} wrapperCol={10}>
    <SchemaField schema={schema} />
  </Form>
)
```

#### 纯 JSX 案例

```tsx
import React from 'react'
import { createForm, registerValidateFormats } from '@formily/core'
import { Field } from '@formily/react'
import { Form, FormItem, Input } from '@formily/antd'

const form = createForm()

registerValidateFormats({
  custom_format: /123/,
})

export default () => (
  <Form form={form} labelCol={6} wrapperCol={10}>
    <Field
      name="global_style_1"
      title="全局注册风格"
      required
      validator={{
        format: 'custom_format',
        message: '错误❎',
      }}
      component={[Input]}
      decorator={[FormItem]}
    />
    <Field
      name="global_style_2"
      title="全局注册风格"
      required
      validator={'custom_format'}
      component={[Input]}
      decorator={[FormItem]}
    />
    <Field
      name="global_style_3"
      title="全局注册风格"
      required
      validator={['custom_format']}
      component={[Input]}
      decorator={[FormItem]}
    />
    <Field
      name="global_style_4"
      title="全局注册风格"
      required
      validator={{
        format: 'custom_format',
        message: '错误❎',
      }}
      component={[Input]}
      decorator={[FormItem]}
    />
    <Field
      name="validator_style_1"
      title="局部定义风格"
      required
      validator={{
        pattern: /123/,
        message: '错误了❎',
      }}
      component={[Input]}
      decorator={[FormItem]}
    />
    <Field
      name="validator_style_2"
      title="局部定义风格"
      required
      validator={{
        pattern: '123',
        message: '错误了❎',
      }}
      component={[Input]}
      decorator={[FormItem]}
    />
  </Form>
)
```

## 异步校验

#### Markup Schema 案例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField } from '@formily/react'
import { Form, FormItem, Input } from '@formily/antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

export default () => (
  <Form form={form} labelCol={6} wrapperCol={10}>
    <SchemaField>
      <SchemaField.String
        name="async_validate"
        title="异步校验"
        required
        x-validator={(value) => {
          return new Promise((resolve) => {
            setTimeout(() => {
              if (!value) {
                resolve('')
              }
              if (value === '123') {
                resolve('')
              } else {
                resolve('错误❎')
              }
            }, 1000)
          })
        }}
        x-component="Input"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="async_validate_2"
        title="异步校验(onBlur触发)"
        required
        x-validator={{
          triggerType: 'onBlur',
          validator: (value) => {
            return new Promise((resolve) => {
              setTimeout(() => {
                if (!value) {
                  resolve('')
                }
                if (value === '123') {
                  resolve('')
                } else {
                  resolve('错误❎')
                }
              }, 1000)
            })
          },
        }}
        x-component="Input"
        x-decorator="FormItem"
      />
    </SchemaField>
  </Form>
)
```

#### JSON Schema 案例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField } from '@formily/react'
import { Form, FormItem, Input } from '@formily/antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const schema = {
  type: 'object',
  properties: {
    async_validate: {
      title: '异步校验',
      required: true,
      'x-validator': `{{(value) => {
        return new Promise((resolve) => {
          setTimeout(() => {
            if (!value) {
              resolve('')
            }
            if (value === '123') {
              resolve('')
            } else {
              resolve('错误❎')
            }
          }, 1000)
        })
      }}}`,
      'x-component': 'Input',
      'x-decorator': 'FormItem',
    },
    async_validate_2: {
      title: '异步校验(onBlur触发)',
      required: true,
      'x-validator': {
        triggerType: 'onBlur',
        validator: `{{(value) => {
        return new Promise((resolve) => {
          setTimeout(() => {
            if (!value) {
              resolve('')
            }
            if (value === '123') {
              resolve('')
            } else {
              resolve('错误❎')
            }
          }, 1000)
        })
      }}}`,
      },
      'x-component': 'Input',
      'x-decorator': 'FormItem',
    },
  },
}

export default () => (
  <Form form={form} labelCol={6} wrapperCol={10}>
    <SchemaField schema={schema} />
  </Form>
)
```

#### 纯 JSX 案例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { Field } from '@formily/react'
import { Form, FormItem, Input } from '@formily/antd'

const form = createForm()

export default () => (
  <Form form={form} labelCol={6} wrapperCol={10}>
    <Field
      name="async_validate"
      title="异步校验"
      required
      validator={(value) => {
        return new Promise((resolve) => {
          setTimeout(() => {
            if (!value) {
              resolve('')
            }
            if (value === '123') {
              resolve('')
            } else {
              resolve('错误❎')
            }
          }, 1000)
        })
      }}
      component={[Input]}
      decorator={[FormItem]}
    />
    <Field
      name="async_validate_2"
      title="异步校验(onBlur触发)"
      required
      validator={{
        triggerType: 'onBlur',
        validator: (value) => {
          return new Promise((resolve) => {
            setTimeout(() => {
              if (!value) {
                resolve('')
              }
              if (value === '123') {
                resolve('')
              } else {
                resolve('错误❎')
              }
            }, 1000)
          })
        },
      }}
      component={[Input]}
      decorator={[FormItem]}
    />
  </Form>
)
```

## 联动校验

#### Markup Schema 案例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField } from '@formily/react'
import { Form, FormItem, NumberPicker } from '@formily/antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    NumberPicker,
    FormItem,
  },
})

export default () => (
  <Form form={form} labelCol={6} wrapperCol={10}>
    <SchemaField>
      <SchemaField.String
        name="aa"
        title="AA"
        required
        x-reactions={(field) => {
          field.selfErrors =
            field.query('bb').value() >= field.value ? 'AA必须大于BB' : ''
        }}
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
      <SchemaField.String
        name="bb"
        title="BB"
        required
        x-reactions={(field) => {
          field.selfErrors =
            field.query('aa').value() <= field.value ? 'AA必须大于BB' : ''
        }}
        x-component="NumberPicker"
        x-decorator="FormItem"
      />
    </SchemaField>
  </Form>
)
```

#### JSON Schema 案例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField } from '@formily/react'
import { Form, FormItem, NumberPicker } from '@formily/antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    NumberPicker,
    FormItem,
  },
})

const schema = {
  type: 'object',
  properties: {
    aa: {
      title: 'AA',
      required: true,
      'x-reactions': `{{(field) => {
          field.selfErrors =
            field.query('bb').value() >= field.value ? 'AA必须大于BB' : ''
      }}}`,
      'x-component': 'NumberPicker',
      'x-decorator': 'FormItem',
    },
    bb: {
      title: 'BB',
      required: true,
      'x-reactions': {
        dependencies: ['aa'],
        fulfill: {
          state: {
            selfErrors: "{{$deps[0] <= $self.value ? 'AA必须大于BB' : ''}}",
          },
        },
      },
      'x-component': 'NumberPicker',
      'x-decorator': 'FormItem',
    },
  },
}

export default () => (
  <Form form={form} labelCol={6} wrapperCol={10}>
    <SchemaField schema={schema} />
  </Form>
)
```

#### 纯 JSX 案例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { Field } from '@formily/react'
import { Form, FormItem, NumberPicker } from '@formily/antd'

const form = createForm()

export default () => (
  <Form form={form} labelCol={6} wrapperCol={10}>
    <Field
      name="aa"
      title="AA"
      required
      reactions={(field) => {
        field.selfErrors =
          field.query('bb').value() >= field.value ? 'AA必须大于BB' : ''
      }}
      component={[NumberPicker]}
      decorator={[FormItem]}
    />
    <Field
      name="bb"
      title="BB"
      required
      reactions={(field) => {
        field.selfErrors =
          field.query('aa').value() <= field.value ? 'AA必须大于BB' : ''
      }}
      component={[NumberPicker]}
      decorator={[FormItem]}
    />
  </Form>
)
```

## 定制校验文案

主要通过[registerValidateLocale](https://core.formilyjs.org/zh-CN/api/entry/form-validator-registry#registervalidatelocale)来定制内置校验文案

```tsx
import React from 'react'
import {
  createForm,
  registerValidateLocale,
  setValidateLanguage,
} from '@formily/core'
import { createSchemaField } from '@formily/react'
import { Form, FormItem, Input } from '@formily/antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
  },
})

setValidateLanguage('zh-CN')

registerValidateLocale({
  'zh-CN': {
    required: '定制的必填校验文案',
  },
})

export default () => (
  <Form form={form} labelCol={6} wrapperCol={10}>
    <SchemaField>
      <SchemaField.String
        name="aa"
        title="AA"
        required
        x-component="Input"
        x-decorator="FormItem"
      />
    </SchemaField>
  </Form>
)
```
</file>

<file path="docs/guide/scenes/dialog-drawer.zh-CN.md">
# 弹窗与抽屉

主要使用[@formily/antd](https://antd.formilyjs.org/zh-CN) 或 [@formily/next](https://fusion.formilyjs.org/zh-CN) 中的[FormDialog](https://antd.formilyjs.org/zh-CN/components/form-dialog)函数 和 [FormDrawer](https://antd.formilyjs.org/zh-CN/components/form-drawer)函数
</file>

<file path="docs/guide/scenes/edit-detail.zh-CN.md">
# 编辑详情

## 编辑

#### Markup Schema 案例

```tsx
import React, { useState, useEffect } from 'react'
import { createForm } from '@formily/core'
import { createSchemaField } from '@formily/react'
import {
  Form,
  FormItem,
  FormLayout,
  Input,
  Select,
  Cascader,
  DatePicker,
  Submit,
  FormGrid,
  Upload,
  ArrayItems,
  Editable,
  FormButtonGroup,
} from '@formily/antd'
import { action } from '@formily/reactive'
import { Card, Button, Spin } from 'antd'
import { UploadOutlined } from '@ant-design/icons'

const form = createForm({
  validateFirst: true,
})

const IDUpload = (props) => {
  return (
    <Upload
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
      headers={{
        authorization: 'authorization-text',
      }}
    >
      <Button icon={<UploadOutlined />}>上传复印件</Button>
    </Upload>
  )
}

const SchemaField = createSchemaField({
  components: {
    FormItem,
    FormGrid,
    FormLayout,
    Input,
    DatePicker,
    Cascader,
    Select,
    IDUpload,
    ArrayItems,
    Editable,
  },
  scope: {
    fetchAddress: (field) => {
      const transform = (data = {}) => {
        return Object.entries(data).reduce((buf, [key, value]) => {
          if (typeof value === 'string')
            return buf.concat({
              label: value,
              value: key,
            })
          const { name, code, cities, districts } = value
          const _cities = transform(cities)
          const _districts = transform(districts)
          return buf.concat({
            label: name,
            value: code,
            children: _cities.length
              ? _cities
              : _districts.length
              ? _districts
              : undefined,
          })
        }, [])
      }

      field.loading = true
      fetch('//unpkg.com/china-location/dist/location.json')
        .then((res) => res.json())
        .then(
          action.bound((data) => {
            field.dataSource = transform(data)
            field.loading = false
          })
        )
    },
  },
})

export default () => {
  const [loading, setLoading] = useState(true)
  useEffect(() => {
    setTimeout(() => {
      form.setInitialValues({
        username: 'Aston Martin',
        firstName: 'Aston',
        lastName: 'Martin',
        email: 'aston_martin@aston.com',
        gender: 1,
        birthday: '1836-01-03',
        address: ['110000', '110000', '110101'],
        idCard: [
          {
            name: 'this is image',
            thumbUrl:
              'https://zos.alipayobjects.com/rmsportal/jkjgkEfvpUPVyRjUImniVslZfWPnJuuZ.png',
            uid: 'rc-upload-1615825692847-2',
            url: 'https://zos.alipayobjects.com/rmsportal/jkjgkEfvpUPVyRjUImniVslZfWPnJuuZ.png',
          },
        ],
        contacts: [
          { name: '张三', phone: '13245633378', email: 'zhangsan@gmail.com' },
          { name: '李四', phone: '16873452678', email: 'lisi@gmail.com' },
        ],
      })
      setLoading(false)
    }, 2000)
  }, [])
  return (
    <div
      style={{
        display: 'flex',
        justifyContent: 'center',
        background: '#eee',
        padding: '40px 0',
      }}
    >
      <Card title="编辑用户" style={{ width: 620 }}>
        <Spin spinning={loading}>
          <Form
            form={form}
            labelCol={5}
            wrapperCol={16}
            onAutoSubmit={console.log}
          >
            <SchemaField>
              <SchemaField.String
                name="username"
                title="用户名"
                required
                x-decorator="FormItem"
                x-component="Input"
              />
              <SchemaField.Void
                title="姓名"
                x-decorator="FormItem"
                x-decorator-props={{
                  asterisk: true,
                  feedbackLayout: 'none',
                }}
                x-component="FormGrid"
              >
                <SchemaField.String
                  name="firstName"
                  x-decorator="FormItem"
                  x-component="Input"
                  x-component-props={{
                    placeholder: '姓',
                  }}
                  required
                />
                <SchemaField.String
                  name="lastName"
                  x-decorator="FormItem"
                  x-component="Input"
                  x-component-props={{
                    placeholder: '名',
                  }}
                  required
                />
              </SchemaField.Void>
              <SchemaField.String
                name="email"
                title="邮箱"
                required
                x-validator="email"
                x-decorator="FormItem"
                x-component="Input"
              />
              <SchemaField.String
                name="gender"
                title="性别"
                x-decorator="FormItem"
                x-component="Select"
                enum={[
                  {
                    label: '男',
                    value: 1,
                  },
                  {
                    label: '女',
                    value: 2,
                  },
                  {
                    label: '第三性别',
                    value: 3,
                  },
                ]}
                required
              />
              <SchemaField.String
                name="birthday"
                title="生日"
                required
                x-decorator="FormItem"
                x-component="DatePicker"
              />
              <SchemaField.String
                name="address"
                title="地址"
                required
                x-decorator="FormItem"
                x-component="Cascader"
                x-reactions="{{fetchAddress}}"
              />
              <SchemaField.String
                name="idCard"
                title="身份证复印件"
                required
                x-decorator="FormItem"
                x-component="IDUpload"
              />
              <SchemaField.Array
                name="contacts"
                title="联系人信息"
                required
                x-decorator="FormItem"
                x-component="ArrayItems"
              >
                <SchemaField.Object x-component="ArrayItems.Item">
                  <SchemaField.Void
                    x-decorator="FormItem"
                    x-component="ArrayItems.SortHandle"
                  />
                  <SchemaField.Void
                    name="popover"
                    title="维护联系人信息"
                    x-decorator="Editable.Popover"
                    x-component="FormLayout"
                    x-component-props={{
                      layout: 'vertical',
                    }}
                    x-reactions={[
                      {
                        fulfill: {
                          schema: {
                            title: '{{$self.query(".name").value() }}',
                          },
                        },
                      },
                    ]}
                  >
                    <SchemaField.String
                      name="name"
                      required
                      title="姓名"
                      x-decorator="FormItem"
                      x-component="Input"
                      x-component-props={{
                        style: {
                          width: 300,
                        },
                      }}
                    />
                    <SchemaField.String
                      name="email"
                      title="邮箱"
                      x-validator={[{ required: true }, 'email']}
                      x-decorator="FormItem"
                      x-component="Input"
                      x-component-props={{
                        style: {
                          width: 300,
                        },
                      }}
                    />
                    <SchemaField.String
                      name="phone"
                      required
                      title="手机号"
                      x-validator="phone"
                      x-decorator="FormItem"
                      x-component="Input"
                      x-component-props={{
                        style: {
                          width: 300,
                        },
                      }}
                    />
                  </SchemaField.Void>
                  <SchemaField.Void
                    x-decorator="FormItem"
                    x-component="ArrayItems.Remove"
                  />
                </SchemaField.Object>
                <SchemaField.Void
                  x-component="ArrayItems.Addition"
                  title="新增联系人"
                />
              </SchemaField.Array>
            </SchemaField>
            <FormButtonGroup.FormItem>
              <Submit block size="large">
                提交
              </Submit>
            </FormButtonGroup.FormItem>
          </Form>
        </Spin>
      </Card>
    </div>
  )
}
```

#### JSON Schema 案例

```tsx
import React, { useState, useEffect } from 'react'
import { createForm } from '@formily/core'
import { createSchemaField } from '@formily/react'
import {
  Form,
  FormItem,
  FormLayout,
  Input,
  Select,
  Cascader,
  DatePicker,
  Submit,
  FormGrid,
  Upload,
  ArrayItems,
  Editable,
  FormButtonGroup,
} from '@formily/antd'
import { action } from '@formily/reactive'
import { Card, Button, Spin } from 'antd'
import { UploadOutlined } from '@ant-design/icons'

const form = createForm({
  validateFirst: true,
})

const IDUpload = (props) => {
  return (
    <Upload
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
      headers={{
        authorization: 'authorization-text',
      }}
    >
      <Button icon={<UploadOutlined />}>上传复印件</Button>
    </Upload>
  )
}

const SchemaField = createSchemaField({
  components: {
    FormItem,
    FormGrid,
    FormLayout,
    Input,
    DatePicker,
    Cascader,
    Select,
    IDUpload,
    ArrayItems,
    Editable,
  },
  scope: {
    fetchAddress: (field) => {
      const transform = (data = {}) => {
        return Object.entries(data).reduce((buf, [key, value]) => {
          if (typeof value === 'string')
            return buf.concat({
              label: value,
              value: key,
            })
          const { name, code, cities, districts } = value
          const _cities = transform(cities)
          const _districts = transform(districts)
          return buf.concat({
            label: name,
            value: code,
            children: _cities.length
              ? _cities
              : _districts.length
              ? _districts
              : undefined,
          })
        }, [])
      }

      field.loading = true
      fetch('//unpkg.com/china-location/dist/location.json')
        .then((res) => res.json())
        .then(
          action.bound((data) => {
            field.dataSource = transform(data)
            field.loading = false
          })
        )
    },
  },
})

const schema = {
  type: 'object',
  properties: {
    username: {
      type: 'string',
      title: '用户名',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    name: {
      type: 'void',
      title: '姓名',
      'x-decorator': 'FormItem',
      'x-decorator-props': {
        asterisk: true,
        feedbackLayout: 'none',
      },
      'x-component': 'FormGrid',
      properties: {
        firstName: {
          type: 'string',
          required: true,
          'x-decorator': 'FormItem',
          'x-component': 'Input',
          'x-component-props': {
            placeholder: '姓',
          },
        },
        lastName: {
          type: 'string',
          required: true,
          'x-decorator': 'FormItem',
          'x-component': 'Input',
          'x-component-props': {
            placeholder: '名',
          },
        },
      },
    },
    email: {
      type: 'string',
      title: '邮箱',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
      'x-validator': 'email',
    },
    gender: {
      type: 'string',
      title: '性别',
      enum: [
        {
          label: '男',
          value: 1,
        },
        {
          label: '女',
          value: 2,
        },
        {
          label: '第三性别',
          value: 3,
        },
      ],
      'x-decorator': 'FormItem',
      'x-component': 'Select',
    },
    birthday: {
      type: 'string',
      required: true,
      title: '生日',
      'x-decorator': 'FormItem',
      'x-component': 'DatePicker',
    },
    address: {
      type: 'string',
      required: true,
      title: '地址',
      'x-decorator': 'FormItem',
      'x-component': 'Cascader',
      'x-reactions': '{{fetchAddress}}',
    },
    idCard: {
      type: 'string',
      required: true,
      title: '身份证复印件',
      'x-decorator': 'FormItem',
      'x-component': 'IDUpload',
    },
    contacts: {
      type: 'array',
      required: true,
      title: '联系人信息',
      'x-decorator': 'FormItem',
      'x-component': 'ArrayItems',
      items: {
        type: 'object',
        'x-component': 'ArrayItems.Item',
        properties: {
          sort: {
            type: 'void',
            'x-decorator': 'FormItem',
            'x-component': 'ArrayItems.SortHandle',
          },
          popover: {
            type: 'void',
            title: '完善联系人信息',
            'x-decorator': 'Editable.Popover',
            'x-component': 'FormLayout',
            'x-component-props': {
              layout: 'vertical',
            },
            'x-reactions': [
              {
                fulfill: {
                  schema: {
                    title: '{{$self.query(".name").value() }}',
                  },
                },
              },
            ],
            properties: {
              name: {
                type: 'string',
                title: '姓名',
                required: true,
                'x-decorator': 'FormItem',
                'x-component': 'Input',
                'x-component-props': {
                  style: {
                    width: 300,
                  },
                },
              },
              email: {
                type: 'string',
                title: '邮箱',
                'x-decorator': 'FormItem',
                'x-component': 'Input',
                'x-validator': [{ required: true }, 'email'],
                'x-component-props': {
                  style: {
                    width: 300,
                  },
                },
              },
              phone: {
                type: 'string',
                title: '手机号',
                'x-decorator': 'FormItem',
                'x-component': 'Input',
                'x-validator': [{ required: true }, 'phone'],
                'x-component-props': {
                  style: {
                    width: 300,
                  },
                },
              },
            },
          },
          remove: {
            type: 'void',
            'x-decorator': 'FormItem',
            'x-component': 'ArrayItems.Remove',
          },
        },
      },
      properties: {
        addition: {
          type: 'void',
          title: '新增联系人',
          'x-component': 'ArrayItems.Addition',
        },
      },
    },
  },
}

export default () => {
  const [loading, setLoading] = useState(true)
  useEffect(() => {
    setTimeout(() => {
      form.setInitialValues({
        username: 'Aston Martin',
        firstName: 'Aston',
        lastName: 'Martin',
        email: 'aston_martin@aston.com',
        gender: 1,
        birthday: '1836-01-03',
        address: ['110000', '110000', '110101'],
        idCard: [
          {
            name: 'this is image',
            thumbUrl:
              'https://zos.alipayobjects.com/rmsportal/jkjgkEfvpUPVyRjUImniVslZfWPnJuuZ.png',
            uid: 'rc-upload-1615825692847-2',
            url: 'https://zos.alipayobjects.com/rmsportal/jkjgkEfvpUPVyRjUImniVslZfWPnJuuZ.png',
          },
        ],
        contacts: [
          { name: '张三', phone: '13245633378', email: 'zhangsan@gmail.com' },
          { name: '李四', phone: '16873452678', email: 'lisi@gmail.com' },
        ],
      })
      setLoading(false)
    }, 2000)
  }, [])
  return (
    <div
      style={{
        display: 'flex',
        justifyContent: 'center',
        background: '#eee',
        padding: '40px 0',
      }}
    >
      <Card title="编辑用户" style={{ width: 620 }}>
        <Spin spinning={loading}>
          <Form
            form={form}
            labelCol={5}
            wrapperCol={16}
            onAutoSubmit={console.log}
          >
            <SchemaField schema={schema} />
            <FormButtonGroup.FormItem>
              <Submit block size="large">
                提交
              </Submit>
            </FormButtonGroup.FormItem>
          </Form>
        </Spin>
      </Card>
    </div>
  )
}
```

#### 纯 JSX 案例

```tsx
import React, { useState, useEffect } from 'react'
import { createForm } from '@formily/core'
import { Field, VoidField, ArrayField } from '@formily/react'
import {
  Form,
  FormItem,
  FormLayout,
  Input,
  Select,
  Cascader,
  DatePicker,
  Submit,
  FormGrid,
  Upload,
  ArrayBase,
  Editable,
  FormButtonGroup,
} from '@formily/antd'
import { action } from '@formily/reactive'
import { Card, Button, Spin } from 'antd'
import { UploadOutlined } from '@ant-design/icons'
import './index.less'

const form = createForm({
  validateFirst: true,
})

const IDUpload = (props) => {
  return (
    <Upload
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
      headers={{
        authorization: 'authorization-text',
      }}
    >
      <Button icon={<UploadOutlined />}>上传复印件</Button>
    </Upload>
  )
}

const fetchAddress = (field) => {
  const transform = (data = {}) => {
    return Object.entries(data).reduce((buf, [key, value]) => {
      if (typeof value === 'string')
        return buf.concat({
          label: value,
          value: key,
        })
      const { name, code, cities, districts } = value
      const _cities = transform(cities)
      const _districts = transform(districts)
      return buf.concat({
        label: name,
        value: code,
        children: _cities.length
          ? _cities
          : _districts.length
          ? _districts
          : undefined,
      })
    }, [])
  }

  field.loading = true
  fetch('//unpkg.com/china-location/dist/location.json')
    .then((res) => res.json())
    .then(
      action.bound((data) => {
        field.dataSource = transform(data)
        field.loading = false
      })
    )
}

export default () => {
  const [loading, setLoading] = useState(true)
  useEffect(() => {
    setTimeout(() => {
      form.setInitialValues({
        username: 'Aston Martin',
        firstName: 'Aston',
        lastName: 'Martin',
        email: 'aston_martin@aston.com',
        gender: 1,
        birthday: '1836-01-03',
        address: ['110000', '110000', '110101'],
        idCard: [
          {
            name: 'this is image',
            thumbUrl:
              'https://zos.alipayobjects.com/rmsportal/jkjgkEfvpUPVyRjUImniVslZfWPnJuuZ.png',
            uid: 'rc-upload-1615825692847-2',
            url: 'https://zos.alipayobjects.com/rmsportal/jkjgkEfvpUPVyRjUImniVslZfWPnJuuZ.png',
          },
        ],
        contacts: [
          { name: '张三', phone: '13245633378', email: 'zhangsan@gmail.com' },
          { name: '李四', phone: '16873452678', email: 'lisi@gmail.com' },
        ],
      })
      setLoading(false)
    }, 2000)
  }, [])
  return (
    <div
      style={{
        display: 'flex',
        justifyContent: 'center',
        background: '#eee',
        padding: '40px 0',
      }}
    >
      <Card title="编辑用户" style={{ width: 620 }}>
        <Spin spinning={loading}>
          <Form
            form={form}
            labelCol={5}
            wrapperCol={16}
            onAutoSubmit={console.log}
          >
            <Field
              name="username"
              title="用户名"
              required
              decorator={[FormItem]}
              component={[Input]}
            />
            <VoidField
              name="name"
              title="姓名"
              decorator={[
                FormItem,
                {
                  asterisk: true,
                  feedbackLayout: 'none',
                },
              ]}
              component={[FormGrid]}
            >
              <Field
                name="firstName"
                decorator={[FormItem]}
                component={[
                  Input,
                  {
                    placeholder: '姓',
                  },
                ]}
                required
              />
              <Field
                name="lastName"
                decorator={[FormItem]}
                component={[
                  Input,
                  {
                    placeholder: '名',
                  },
                ]}
                required
              />
            </VoidField>
            <Field
              name="email"
              title="邮箱"
              required
              validator="email"
              decorator={[FormItem]}
              component={[Input]}
            />
            <Field
              name="gender"
              title="性别"
              decorator={[FormItem]}
              component={[Select]}
              dataSource={[
                {
                  label: '男',
                  value: 1,
                },
                {
                  label: '女',
                  value: 2,
                },
                {
                  label: '第三性别',
                  value: 3,
                },
              ]}
              required
            />
            <Field
              name="birthday"
              title="生日"
              required
              decorator={[FormItem]}
              component={[DatePicker]}
            />
            <Field
              name="address"
              title="地址"
              required
              decorator={[FormItem]}
              component={[Cascader]}
              reactions={fetchAddress}
            />
            <Field
              name="idCard"
              title="身份证复印件"
              required
              decorator={[FormItem]}
              component={[IDUpload]}
            />
            <ArrayField
              name="contacts"
              title="联系人信息"
              decorator={[FormItem]}
            >
              {(field) => (
                <ArrayBase>
                  {field.value?.map((item, index) => (
                    <div key={index} className="array-items-item">
                      <Field
                        name={`${index}`}
                        title="完善联系人信息"
                        component={[Editable.Popover]}
                        reactions={(field) => {
                          field.title =
                            field.query('.[].name').value() || field.title
                        }}
                      >
                        <VoidField
                          name="layout"
                          component={[FormLayout, { layout: 'vertical' }]}
                        >
                          <Field
                            name="name"
                            title="姓名"
                            required
                            decorator={[FormItem]}
                            component={[
                              Input,
                              {
                                style: {
                                  width: 300,
                                },
                              },
                            ]}
                          />
                          <Field
                            name="email"
                            title="邮箱"
                            required
                            validator="email"
                            decorator={[FormItem]}
                            component={[
                              Input,
                              {
                                style: {
                                  width: 300,
                                },
                              },
                            ]}
                          />
                          <Field
                            name="phone"
                            title="手机号"
                            required
                            validator="phone"
                            decorator={[FormItem]}
                            component={[
                              Input,
                              {
                                style: {
                                  width: 300,
                                },
                              },
                            ]}
                          />
                        </VoidField>
                      </Field>
                      <FormItem.BaseItem>
                        <ArrayBase.Remove index={index} />
                        <ArrayBase.MoveDown index={index} />
                        <ArrayBase.MoveUp index={index} />
                      </FormItem.BaseItem>
                    </div>
                  ))}
                  <ArrayBase.Addition title="新增联系人" />
                </ArrayBase>
              )}
            </ArrayField>
            <FormButtonGroup.FormItem>
              <Submit block size="large">
                提交
              </Submit>
            </FormButtonGroup.FormItem>
          </Form>
        </Spin>
      </Card>
    </div>
  )
}
```

## 详情

#### Markup Schema 案例

```tsx
import React, { useState, useEffect } from 'react'
import { createForm } from '@formily/core'
import { createSchemaField, useField } from '@formily/react'
import {
  Form,
  FormItem,
  FormLayout,
  Input,
  Select,
  Cascader,
  DatePicker,
  FormGrid,
  Upload,
  ArrayItems,
  Editable,
  PreviewText,
} from '@formily/antd'
import { action } from '@formily/reactive'
import { Card, Button, Spin } from 'antd'
import { UploadOutlined } from '@ant-design/icons'

const form = createForm({
  readPretty: true,
  validateFirst: true,
})

const IDUpload = (props) => {
  const field = useField()
  return (
    <Upload
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
      headers={{
        authorization: 'authorization-text',
      }}
    >
      {field.editable && <Button icon={<UploadOutlined />}>上传复印件</Button>}
    </Upload>
  )
}

const SchemaField = createSchemaField({
  components: {
    FormItem,
    FormGrid,
    FormLayout,
    Input,
    DatePicker,
    Cascader,
    Select,
    IDUpload,
    ArrayItems,
    Editable,
  },
  scope: {
    fetchAddress: (field) => {
      const transform = (data = {}) => {
        return Object.entries(data).reduce((buf, [key, value]) => {
          if (typeof value === 'string')
            return buf.concat({
              label: value,
              value: key,
            })
          const { name, code, cities, districts } = value
          const _cities = transform(cities)
          const _districts = transform(districts)
          return buf.concat({
            label: name,
            value: code,
            children: _cities.length
              ? _cities
              : _districts.length
              ? _districts
              : undefined,
          })
        }, [])
      }

      field.loading = true
      fetch('//unpkg.com/china-location/dist/location.json')
        .then((res) => res.json())
        .then(
          action.bound((data) => {
            field.dataSource = transform(data)
            field.loading = false
          })
        )
    },
  },
})

export default () => {
  const [loading, setLoading] = useState(true)
  useEffect(() => {
    setTimeout(() => {
      form.setInitialValues({
        username: 'Aston Martin',
        firstName: 'Aston',
        lastName: 'Martin',
        email: 'aston_martin@aston.com',
        gender: 1,
        birthday: '1836-01-03',
        address: ['110000', '110000', '110101'],
        idCard: [
          {
            name: 'this is image',
            thumbUrl:
              'https://zos.alipayobjects.com/rmsportal/jkjgkEfvpUPVyRjUImniVslZfWPnJuuZ.png',
            uid: 'rc-upload-1615825692847-2',
            url: 'https://zos.alipayobjects.com/rmsportal/jkjgkEfvpUPVyRjUImniVslZfWPnJuuZ.png',
          },
        ],
        contacts: [
          { name: '张三', phone: '13245633378', email: 'zhangsan@gmail.com' },
          { name: '李四', phone: '16873452678', email: 'lisi@gmail.com' },
        ],
      })
      setLoading(false)
    }, 2000)
  }, [])
  return (
    <div
      style={{
        display: 'flex',
        justifyContent: 'center',
        background: '#eee',
        padding: '40px 0',
      }}
    >
      <PreviewText.Placeholder value="-">
        <Card title="用户详情" style={{ width: 620 }}>
          <Spin spinning={loading}>
            <Form
              form={form}
              labelCol={5}
              wrapperCol={16}
              onAutoSubmit={console.log}
            >
              <SchemaField>
                <SchemaField.String
                  name="username"
                  title="用户名"
                  required
                  x-decorator="FormItem"
                  x-component="Input"
                />
                <SchemaField.Void
                  title="姓名"
                  x-decorator="FormItem"
                  x-decorator-props={{
                    feedbackLayout: 'none',
                  }}
                  x-component="FormGrid"
                >
                  <SchemaField.String
                    name="firstName"
                    x-decorator="FormItem"
                    x-component="Input"
                    x-component-props={{
                      placeholder: '姓',
                    }}
                    required
                  />
                  <SchemaField.String
                    name="lastName"
                    x-decorator="FormItem"
                    x-component="Input"
                    x-component-props={{
                      placeholder: '名',
                    }}
                    required
                  />
                </SchemaField.Void>
                <SchemaField.String
                  name="email"
                  title="邮箱"
                  required
                  x-validator="email"
                  x-decorator="FormItem"
                  x-component="Input"
                />
                <SchemaField.String
                  name="gender"
                  title="性别"
                  x-decorator="FormItem"
                  x-component="Select"
                  enum={[
                    {
                      label: '男',
                      value: 1,
                    },
                    {
                      label: '女',
                      value: 2,
                    },
                    {
                      label: '第三性别',
                      value: 3,
                    },
                  ]}
                  required
                />
                <SchemaField.String
                  name="birthday"
                  title="生日"
                  required
                  x-decorator="FormItem"
                  x-component="DatePicker"
                />
                <SchemaField.String
                  name="address"
                  title="地址"
                  required
                  x-decorator="FormItem"
                  x-component="Cascader"
                  x-reactions="{{fetchAddress}}"
                />
                <SchemaField.String
                  name="idCard"
                  title="身份证复印件"
                  required
                  x-decorator="FormItem"
                  x-component="IDUpload"
                />
                <SchemaField.Array
                  name="contacts"
                  title="联系人信息"
                  required
                  x-decorator="FormItem"
                  x-component="ArrayItems"
                >
                  <SchemaField.Object x-component="ArrayItems.Item">
                    <SchemaField.Void
                      x-decorator="FormItem"
                      x-component="ArrayItems.SortHandle"
                    />
                    <SchemaField.Void
                      name="popover"
                      title="维护联系人信息"
                      x-decorator="Editable.Popover"
                      x-component="FormLayout"
                      x-component-props={{
                        layout: 'vertical',
                      }}
                      x-reactions={[
                        {
                          fulfill: {
                            schema: {
                              title: '{{$self.query(".name").value() }}',
                            },
                          },
                        },
                      ]}
                    >
                      <SchemaField.String
                        name="name"
                        required
                        title="姓名"
                        x-decorator="FormItem"
                        x-component="Input"
                        x-component-props={{
                          style: {
                            width: 300,
                          },
                        }}
                      />
                      <SchemaField.String
                        name="email"
                        title="邮箱"
                        x-validator={[{ required: true }, 'email']}
                        x-decorator="FormItem"
                        x-component="Input"
                        x-component-props={{
                          style: {
                            width: 300,
                          },
                        }}
                      />
                      <SchemaField.String
                        name="phone"
                        required
                        title="手机号"
                        x-validator="phone"
                        x-decorator="FormItem"
                        x-component="Input"
                        x-component-props={{
                          style: {
                            width: 300,
                          },
                        }}
                      />
                    </SchemaField.Void>
                    <SchemaField.Void
                      x-decorator="FormItem"
                      x-component="ArrayItems.Remove"
                    />
                  </SchemaField.Object>
                  <SchemaField.Void
                    x-component="ArrayItems.Addition"
                    title="新增联系人"
                  />
                </SchemaField.Array>
              </SchemaField>
            </Form>
          </Spin>
        </Card>
      </PreviewText.Placeholder>
    </div>
  )
}
```

#### JSON Schema 案例

```tsx
import React, { useState, useEffect } from 'react'
import { createForm } from '@formily/core'
import { createSchemaField, useField } from '@formily/react'
import {
  Form,
  FormItem,
  FormLayout,
  Input,
  Select,
  Cascader,
  DatePicker,
  FormGrid,
  Upload,
  ArrayItems,
  Editable,
  PreviewText,
} from '@formily/antd'
import { action } from '@formily/reactive'
import { Card, Button, Spin } from 'antd'
import { UploadOutlined } from '@ant-design/icons'

const form = createForm({
  readPretty: true,
  validateFirst: true,
})

const IDUpload = (props) => {
  const field = useField()
  return (
    <Upload
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
      headers={{
        authorization: 'authorization-text',
      }}
    >
      {field.editable && <Button icon={<UploadOutlined />}>上传复印件</Button>}
    </Upload>
  )
}

const SchemaField = createSchemaField({
  components: {
    FormItem,
    FormGrid,
    FormLayout,
    Input,
    DatePicker,
    Cascader,
    Select,
    IDUpload,
    ArrayItems,
    Editable,
  },
  scope: {
    fetchAddress: (field) => {
      const transform = (data = {}) => {
        return Object.entries(data).reduce((buf, [key, value]) => {
          if (typeof value === 'string')
            return buf.concat({
              label: value,
              value: key,
            })
          const { name, code, cities, districts } = value
          const _cities = transform(cities)
          const _districts = transform(districts)
          return buf.concat({
            label: name,
            value: code,
            children: _cities.length
              ? _cities
              : _districts.length
              ? _districts
              : undefined,
          })
        }, [])
      }

      field.loading = true
      fetch('//unpkg.com/china-location/dist/location.json')
        .then((res) => res.json())
        .then(
          action.bound((data) => {
            field.dataSource = transform(data)
            field.loading = false
          })
        )
    },
  },
})

const schema = {
  type: 'object',
  properties: {
    username: {
      type: 'string',
      title: '用户名',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    name: {
      type: 'void',
      title: '姓名',
      'x-decorator': 'FormItem',
      'x-decorator-props': {
        asterisk: true,
        feedbackLayout: 'none',
      },
      'x-component': 'FormGrid',
      properties: {
        firstName: {
          type: 'string',
          required: true,
          'x-decorator': 'FormItem',
          'x-component': 'Input',
          'x-component-props': {
            placeholder: '姓',
          },
        },
        lastName: {
          type: 'string',
          required: true,
          'x-decorator': 'FormItem',
          'x-component': 'Input',
          'x-component-props': {
            placeholder: '名',
          },
        },
      },
    },
    email: {
      type: 'string',
      title: '邮箱',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
      'x-validator': 'email',
    },
    gender: {
      type: 'string',
      title: '性别',
      enum: [
        {
          label: '男',
          value: 1,
        },
        {
          label: '女',
          value: 2,
        },
        {
          label: '第三性别',
          value: 3,
        },
      ],
      'x-decorator': 'FormItem',
      'x-component': 'Select',
    },
    birthday: {
      type: 'string',
      required: true,
      title: '生日',
      'x-decorator': 'FormItem',
      'x-component': 'DatePicker',
    },
    address: {
      type: 'string',
      required: true,
      title: '地址',
      'x-decorator': 'FormItem',
      'x-component': 'Cascader',
      'x-reactions': '{{fetchAddress}}',
    },
    idCard: {
      type: 'string',
      required: true,
      title: '身份证复印件',
      'x-decorator': 'FormItem',
      'x-component': 'IDUpload',
    },
    contacts: {
      type: 'array',
      required: true,
      title: '联系人信息',
      'x-decorator': 'FormItem',
      'x-component': 'ArrayItems',
      items: {
        type: 'object',
        'x-component': 'ArrayItems.Item',
        properties: {
          sort: {
            type: 'void',
            'x-decorator': 'FormItem',
            'x-component': 'ArrayItems.SortHandle',
          },
          popover: {
            type: 'void',
            title: '完善联系人信息',
            'x-decorator': 'Editable.Popover',
            'x-component': 'FormLayout',
            'x-component-props': {
              layout: 'vertical',
            },
            'x-reactions': [
              {
                fulfill: {
                  schema: {
                    title: '{{$self.query(".name").value() }}',
                  },
                },
              },
            ],
            properties: {
              name: {
                type: 'string',
                title: '姓名',
                required: true,
                'x-decorator': 'FormItem',
                'x-component': 'Input',
                'x-component-props': {
                  style: {
                    width: 300,
                  },
                },
              },
              email: {
                type: 'string',
                title: '邮箱',
                'x-decorator': 'FormItem',
                'x-component': 'Input',
                'x-validator': [{ required: true }, 'email'],
                'x-component-props': {
                  style: {
                    width: 300,
                  },
                },
              },
              phone: {
                type: 'string',
                title: '手机号',
                'x-decorator': 'FormItem',
                'x-component': 'Input',
                'x-validator': [{ required: true }, 'phone'],
                'x-component-props': {
                  style: {
                    width: 300,
                  },
                },
              },
            },
          },
          remove: {
            type: 'void',
            'x-decorator': 'FormItem',
            'x-component': 'ArrayItems.Remove',
          },
        },
      },
      properties: {
        addition: {
          type: 'void',
          title: '新增联系人',
          'x-component': 'ArrayItems.Addition',
        },
      },
    },
  },
}

export default () => {
  const [loading, setLoading] = useState(true)
  useEffect(() => {
    setTimeout(() => {
      form.setInitialValues({
        username: 'Aston Martin',
        firstName: 'Aston',
        lastName: 'Martin',
        email: 'aston_martin@aston.com',
        gender: 1,
        birthday: '1836-01-03',
        address: ['110000', '110000', '110101'],
        idCard: [
          {
            name: 'this is image',
            thumbUrl:
              'https://zos.alipayobjects.com/rmsportal/jkjgkEfvpUPVyRjUImniVslZfWPnJuuZ.png',
            uid: 'rc-upload-1615825692847-2',
            url: 'https://zos.alipayobjects.com/rmsportal/jkjgkEfvpUPVyRjUImniVslZfWPnJuuZ.png',
          },
        ],
        contacts: [
          { name: '张三', phone: '13245633378', email: 'zhangsan@gmail.com' },
          { name: '李四', phone: '16873452678', email: 'lisi@gmail.com' },
        ],
      })
      setLoading(false)
    }, 2000)
  }, [])
  return (
    <div
      style={{
        display: 'flex',
        justifyContent: 'center',
        background: '#eee',
        padding: '40px 0',
      }}
    >
      <PreviewText.Placeholder value="-">
        <Card title="用户详情" style={{ width: 620 }}>
          <Spin spinning={loading}>
            <Form
              form={form}
              labelCol={5}
              wrapperCol={16}
              onAutoSubmit={console.log}
            >
              <SchemaField schema={schema} />
            </Form>
          </Spin>
        </Card>
      </PreviewText.Placeholder>
    </div>
  )
}
```

#### 纯 JSX 案例

```tsx
import React, { useState, useEffect } from 'react'
import { createForm } from '@formily/core'
import { Field, VoidField, ArrayField, useField } from '@formily/react'
import {
  Form,
  FormItem,
  FormLayout,
  Input,
  Select,
  Cascader,
  DatePicker,
  FormGrid,
  ArrayBase,
  Upload,
  PreviewText,
  Editable,
} from '@formily/antd'
import { action } from '@formily/reactive'
import { Card, Button, Spin } from 'antd'
import { UploadOutlined } from '@ant-design/icons'
import './index.less'

const form = createForm({
  validateFirst: true,
  readPretty: true,
})

const IDUpload = (props) => {
  const field = useField()
  return (
    <Upload
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
      headers={{
        authorization: 'authorization-text',
      }}
    >
      {field.editable && <Button icon={<UploadOutlined />}>上传复印件</Button>}
    </Upload>
  )
}

const fetchAddress = (field) => {
  const transform = (data = {}) => {
    return Object.entries(data).reduce((buf, [key, value]) => {
      if (typeof value === 'string')
        return buf.concat({
          label: value,
          value: key,
        })
      const { name, code, cities, districts } = value
      const _cities = transform(cities)
      const _districts = transform(districts)
      return buf.concat({
        label: name,
        value: code,
        children: _cities.length
          ? _cities
          : _districts.length
          ? _districts
          : undefined,
      })
    }, [])
  }

  field.loading = true
  fetch('//unpkg.com/china-location/dist/location.json')
    .then((res) => res.json())
    .then(
      action.bound((data) => {
        field.dataSource = transform(data)
        field.loading = false
      })
    )
}

export default () => {
  const [loading, setLoading] = useState(true)
  useEffect(() => {
    setTimeout(() => {
      form.setInitialValues({
        username: 'Aston Martin',
        firstName: 'Aston',
        lastName: 'Martin',
        email: 'aston_martin@aston.com',
        gender: 1,
        birthday: '1836-01-03',
        address: ['110000', '110000', '110101'],
        idCard: [
          {
            name: 'this is image',
            thumbUrl:
              'https://zos.alipayobjects.com/rmsportal/jkjgkEfvpUPVyRjUImniVslZfWPnJuuZ.png',
            uid: 'rc-upload-1615825692847-2',
            url: 'https://zos.alipayobjects.com/rmsportal/jkjgkEfvpUPVyRjUImniVslZfWPnJuuZ.png',
          },
        ],
        contacts: [
          { name: '张三', phone: '13245633378', email: 'zhangsan@gmail.com' },
          { name: '李四', phone: '16873452678', email: 'lisi@gmail.com' },
        ],
      })
      setLoading(false)
    }, 2000)
  }, [])
  return (
    <div
      style={{
        display: 'flex',
        justifyContent: 'center',
        background: '#eee',
        padding: '40px 0',
      }}
    >
      <PreviewText.Placeholder value="-">
        <Card title="编辑用户" style={{ width: 620 }}>
          <Spin spinning={loading}>
            <Form
              form={form}
              labelCol={5}
              wrapperCol={16}
              onAutoSubmit={console.log}
            >
              <Field
                name="username"
                title="用户名"
                required
                decorator={[FormItem]}
                component={[Input]}
              />
              <VoidField
                name="name"
                title="姓名"
                decorator={[
                  FormItem,
                  {
                    feedbackLayout: 'none',
                  },
                ]}
                component={[FormGrid]}
              >
                <Field
                  name="firstName"
                  decorator={[FormItem]}
                  component={[
                    Input,
                    {
                      placeholder: '姓',
                    },
                  ]}
                  required
                />
                <Field
                  name="lastName"
                  decorator={[FormItem]}
                  component={[
                    Input,
                    {
                      placeholder: '名',
                    },
                  ]}
                  required
                />
              </VoidField>
              <Field
                name="email"
                title="邮箱"
                required
                validator="email"
                decorator={[FormItem]}
                component={[Input]}
              />
              <Field
                name="gender"
                title="性别"
                decorator={[FormItem]}
                component={[Select]}
                dataSource={[
                  {
                    label: '男',
                    value: 1,
                  },
                  {
                    label: '女',
                    value: 2,
                  },
                  {
                    label: '第三性别',
                    value: 3,
                  },
                ]}
                required
              />
              <Field
                name="birthday"
                title="生日"
                required
                decorator={[FormItem]}
                component={[DatePicker]}
              />
              <Field
                name="address"
                title="地址"
                required
                decorator={[FormItem]}
                component={[Cascader]}
                reactions={fetchAddress}
              />
              <Field
                name="idCard"
                title="身份证复印件"
                required
                decorator={[FormItem]}
                component={[IDUpload]}
              />
              <ArrayField
                name="contacts"
                title="联系人信息"
                decorator={[FormItem]}
              >
                {(field) => (
                  <ArrayBase>
                    {field.value?.map((item, index) => (
                      <div key={index} className="array-items-item">
                        <Field
                          name={`${index}`}
                          title="完善联系人信息"
                          component={[Editable.Popover]}
                          reactions={(field) => {
                            field.title =
                              field.query('.[].name').value() || field.title
                          }}
                        >
                          <VoidField
                            name="layout"
                            component={[FormLayout, { layout: 'vertical' }]}
                          >
                            <Field
                              name="name"
                              title="姓名"
                              required
                              decorator={[FormItem]}
                              component={[
                                Input,
                                {
                                  style: {
                                    width: 300,
                                  },
                                },
                              ]}
                            />
                            <Field
                              name="email"
                              title="邮箱"
                              required
                              validator="email"
                              decorator={[FormItem]}
                              component={[
                                Input,
                                {
                                  style: {
                                    width: 300,
                                  },
                                },
                              ]}
                            />
                            <Field
                              name="phone"
                              title="手机号"
                              required
                              validator="phone"
                              decorator={[FormItem]}
                              component={[
                                Input,
                                {
                                  style: {
                                    width: 300,
                                  },
                                },
                              ]}
                            />
                          </VoidField>
                        </Field>
                      </div>
                    ))}
                    <ArrayBase.Addition title="新增联系人" />
                  </ArrayBase>
                )}
              </ArrayField>
            </Form>
          </Spin>
        </Card>
      </PreviewText.Placeholder>
    </div>
  )
}
```
</file>

<file path="docs/guide/scenes/login-register.zh-CN.md">
# 登录注册

## 登录

#### Markup Schema 案例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField } from '@formily/react'
import { Form, FormItem, Input, Password, Submit } from '@formily/antd'
import { Tabs, Card } from 'antd'
import * as ICONS from '@ant-design/icons'
import { VerifyCode } from './VerifyCode'

const normalForm = createForm({
  validateFirst: true,
})

const phoneForm = createForm({
  validateFirst: true,
})

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    Password,
    VerifyCode,
  },
  scope: {
    icon(name) {
      return React.createElement(ICONS[name])
    },
  },
})

export default () => {
  return (
    <div
      style={{
        display: 'flex',
        justifyContent: 'center',
        background: '#eee',
        padding: '40px 0',
      }}
    >
      <Card style={{ width: 400 }}>
        <Tabs style={{ overflow: 'visible', marginTop: -10 }}>
          <Tabs.TabPane key="1" tab="账密登录">
            <Form
              form={normalForm}
              layout="vertical"
              size="large"
              onAutoSubmit={console.log}
            >
              <SchemaField>
                <SchemaField.String
                  name="username"
                  title="用户名"
                  required
                  x-decorator="FormItem"
                  x-component="Input"
                  x-validator={{
                    required: true,
                  }}
                  x-component-props={{
                    prefix: "{{icon('UserOutlined')}}",
                  }}
                />
                <SchemaField.String
                  name="password"
                  title="密码"
                  required
                  x-decorator="FormItem"
                  x-component="Password"
                  x-component-props={{
                    prefix: "{{icon('LockOutlined')}}",
                  }}
                />
              </SchemaField>
              <Submit block size="large">
                登录
              </Submit>
            </Form>
          </Tabs.TabPane>
          <Tabs.TabPane key="2" tab="手机登录">
            <Form
              form={phoneForm}
              layout="vertical"
              size="large"
              onAutoSubmit={console.log}
            >
              <SchemaField>
                <SchemaField.String
                  name="phone"
                  title="手机号"
                  required
                  x-validator="phone"
                  x-decorator="FormItem"
                  x-component="Input"
                  x-component-props={{
                    prefix: "{{icon('PhoneOutlined')}}",
                  }}
                />
                <SchemaField.String
                  name="verifyCode"
                  title="验证码"
                  required
                  x-decorator="FormItem"
                  x-component="VerifyCode"
                  x-component-props={{
                    prefix: "{{icon('LockOutlined')}}",
                  }}
                  x-reactions={[
                    {
                      dependencies: ['.phone#value', '.phone#valid'],
                      fulfill: {
                        state: {
                          'component[1].readyPost': '{{$deps[0] && $deps[1]}}',
                          'component[1].phoneNumber': '{{$deps[0]}}',
                        },
                      },
                    },
                  ]}
                />
              </SchemaField>
              <Submit block size="large">
                登录
              </Submit>
            </Form>
          </Tabs.TabPane>
        </Tabs>
        <div
          style={{
            display: 'flex',
            justifyContent: 'space-between',
          }}
        >
          <a href="#新用户注册">新用户注册</a>
          <a href="#忘记密码">忘记密码?</a>
        </div>
      </Card>
    </div>
  )
}
```

#### JSON Schema 案例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField } from '@formily/react'
import { Form, FormItem, Input, Password, Submit } from '@formily/antd'
import { Tabs, Card } from 'antd'
import * as ICONS from '@ant-design/icons'
import { VerifyCode } from './VerifyCode'

const normalForm = createForm({
  validateFirst: true,
})

const phoneForm = createForm({
  validateFirst: true,
})

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    Password,
    VerifyCode,
  },
  scope: {
    icon(name) {
      return React.createElement(ICONS[name])
    },
  },
})

const normalSchema = {
  type: 'object',
  properties: {
    username: {
      type: 'string',
      title: '用户名',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
      'x-component-props': {
        prefix: "{{icon('UserOutlined')}}",
      },
    },
    password: {
      type: 'string',
      title: '密码',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Password',
      'x-component-props': {
        prefix: "{{icon('LockOutlined')}}",
      },
    },
  },
}

const phoneSchema = {
  type: 'object',
  properties: {
    phone: {
      type: 'string',
      title: '手机号',
      required: true,
      'x-validator': 'phone',
      'x-decorator': 'FormItem',
      'x-component': 'Input',
      'x-component-props': {
        prefix: "{{icon('PhoneOutlined')}}",
      },
    },
    verifyCode: {
      type: 'string',
      title: '验证码',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'VerifyCode',
      'x-component-props': {
        prefix: "{{icon('LockOutlined')}}",
      },
      'x-reactions': [
        {
          dependencies: ['.phone#value', '.phone#valid'],
          fulfill: {
            state: {
              'component[1].readyPost': '{{$deps[0] && $deps[1]}}',
              'component[1].phoneNumber': '{{$deps[0]}}',
            },
          },
        },
      ],
    },
  },
}

export default () => {
  return (
    <div
      style={{
        display: 'flex',
        justifyContent: 'center',
        background: '#eee',
        padding: '40px 0',
      }}
    >
      <Card style={{ width: 400 }}>
        <Tabs style={{ overflow: 'visible', marginTop: -10 }}>
          <Tabs.TabPane key="1" tab="账密登录">
            <Form
              form={normalForm}
              layout="vertical"
              size="large"
              onAutoSubmit={console.log}
            >
              <SchemaField schema={normalSchema} />
              <Submit block size="large">
                登录
              </Submit>
            </Form>
          </Tabs.TabPane>
          <Tabs.TabPane key="2" tab="手机登录">
            <Form
              form={phoneForm}
              layout="vertical"
              size="large"
              onAutoSubmit={console.log}
            >
              <SchemaField schema={phoneSchema} />
              <Submit block size="large">
                登录
              </Submit>
            </Form>
          </Tabs.TabPane>
        </Tabs>
        <div
          style={{
            display: 'flex',
            justifyContent: 'space-between',
          }}
        >
          <a href="#新用户注册">新用户注册</a>
          <a href="#忘记密码">忘记密码?</a>
        </div>
      </Card>
    </div>
  )
}
```

#### 纯 JSX 案例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { Field } from '@formily/react'
import { Form, FormItem, Input, Password, Submit } from '@formily/antd'
import { Tabs, Card } from 'antd'
import { UserOutlined, LockOutlined, PhoneOutlined } from '@ant-design/icons'
import { VerifyCode } from './VerifyCode'

const normalForm = createForm({
  validateFirst: true,
})

const phoneForm = createForm({
  validateFirst: true,
})

export default () => {
  return (
    <div
      style={{
        display: 'flex',
        justifyContent: 'center',
        background: '#eee',
        padding: '40px 0',
      }}
    >
      <Card style={{ width: 400 }}>
        <Tabs style={{ overflow: 'visible', marginTop: -10 }}>
          <Tabs.TabPane key="1" tab="账密登录">
            <Form
              form={normalForm}
              layout="vertical"
              size="large"
              onAutoSubmit={console.log}
            >
              <Field
                name="username"
                title="用户名"
                required
                decorator={[FormItem]}
                component={[
                  Input,
                  {
                    prefix: <UserOutlined />,
                  },
                ]}
              />
              <Field
                name="password"
                title="密码"
                required
                decorator={[FormItem]}
                component={[
                  Password,
                  {
                    prefix: <LockOutlined />,
                  },
                ]}
              />
              <Submit block size="large">
                登录
              </Submit>
            </Form>
          </Tabs.TabPane>
          <Tabs.TabPane key="2" tab="手机登录">
            <Form
              form={phoneForm}
              layout="vertical"
              size="large"
              onAutoSubmit={console.log}
            >
              <Field
                name="phone"
                title="手机号"
                required
                validator="phone"
                decorator={[FormItem]}
                component={[
                  Input,
                  {
                    prefix: <PhoneOutlined />,
                  },
                ]}
              />
              <Field
                name="verifyCode"
                title="验证码"
                required
                reactions={(field) => {
                  const phone = field.query('.phone')
                  field.setComponentProps({
                    readyPost: phone.get('valid') && phone.get('value'),
                    phoneNumber: phone.get('value'),
                  })
                }}
                decorator={[FormItem]}
                component={[
                  VerifyCode,
                  {
                    prefix: <LockOutlined />,
                  },
                ]}
              />
              <Submit block size="large">
                登录
              </Submit>
            </Form>
          </Tabs.TabPane>
        </Tabs>
        <div
          style={{
            display: 'flex',
            justifyContent: 'space-between',
          }}
        >
          <a href="#新用户注册">新用户注册</a>
          <a href="#忘记密码">忘记密码?</a>
        </div>
      </Card>
    </div>
  )
}
```

## 新用户注册

#### Markup Schema 案例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField } from '@formily/react'
import {
  Form,
  FormItem,
  FormLayout,
  Input,
  Select,
  Password,
  Cascader,
  DatePicker,
  Submit,
  Space,
  FormGrid,
  Upload,
  ArrayItems,
  Editable,
  FormButtonGroup,
} from '@formily/antd'
import { action } from '@formily/reactive'
import { Card, Button } from 'antd'
import { UploadOutlined } from '@ant-design/icons'

const form = createForm({
  validateFirst: true,
})

const IDUpload = (props) => {
  return (
    <Upload
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
      headers={{
        authorization: 'authorization-text',
      }}
    >
      <Button icon={<UploadOutlined />}>上传复印件</Button>
    </Upload>
  )
}

const SchemaField = createSchemaField({
  components: {
    FormItem,
    FormGrid,
    FormLayout,
    Input,
    DatePicker,
    Cascader,
    Select,
    Password,
    IDUpload,
    Space,
    ArrayItems,
    Editable,
  },
  scope: {
    fetchAddress: (field) => {
      const transform = (data = {}) => {
        return Object.entries(data).reduce((buf, [key, value]) => {
          if (typeof value === 'string')
            return buf.concat({
              label: value,
              value: key,
            })
          const { name, code, cities, districts } = value
          const _cities = transform(cities)
          const _districts = transform(districts)
          return buf.concat({
            label: name,
            value: code,
            children: _cities.length
              ? _cities
              : _districts.length
              ? _districts
              : undefined,
          })
        }, [])
      }

      field.loading = true
      fetch('//unpkg.com/china-location/dist/location.json')
        .then((res) => res.json())
        .then(
          action.bound((data) => {
            field.dataSource = transform(data)
            field.loading = false
          })
        )
    },
  },
})

export default () => {
  return (
    <div
      style={{
        display: 'flex',
        justifyContent: 'center',
        background: '#eee',
        padding: '40px 0',
      }}
    >
      <Card title="新用户注册" style={{ width: 620 }}>
        <Form
          form={form}
          labelCol={5}
          wrapperCol={16}
          onAutoSubmit={console.log}
        >
          <SchemaField>
            <SchemaField.String
              name="username"
              title="用户名"
              required
              x-decorator="FormItem"
              x-component="Input"
            />
            <SchemaField.String
              name="password"
              title="密码"
              required
              x-decorator="FormItem"
              x-component="Password"
              x-component-props={{
                checkStrength: true,
              }}
              x-reactions={[
                {
                  dependencies: ['.confirm_password'],
                  fulfill: {
                    state: {
                      selfErrors:
                        '{{$deps[0] && $self.value && $self.value !== $deps[0] ? "确认密码不匹配" : ""}}',
                    },
                  },
                },
              ]}
            />
            <SchemaField.String
              name="confirm_password"
              title="确认密码"
              required
              x-decorator="FormItem"
              x-component="Password"
              x-component-props={{
                checkStrength: true,
              }}
              x-reactions={[
                {
                  dependencies: ['.password'],
                  fulfill: {
                    state: {
                      selfErrors:
                        '{{$deps[0] && $self.value && $self.value !== $deps[0] ? "确认密码不匹配" : ""}}',
                    },
                  },
                },
              ]}
            />
            <SchemaField.Void
              title="姓名"
              x-decorator="FormItem"
              x-decorator-props={{
                asterisk: true,
                feedbackLayout: 'none',
              }}
              x-component="FormGrid"
            >
              <SchemaField.String
                name="firstName"
                x-decorator="FormItem"
                x-component="Input"
                x-component-props={{
                  placeholder: '姓',
                }}
                required
              />
              <SchemaField.String
                name="lastName"
                x-decorator="FormItem"
                x-component="Input"
                x-component-props={{
                  placeholder: '名',
                }}
                required
              />
            </SchemaField.Void>
            <SchemaField.String
              name="email"
              title="邮箱"
              required
              x-validator="email"
              x-decorator="FormItem"
              x-component="Input"
            />
            <SchemaField.String
              name="gender"
              title="性别"
              x-decorator="FormItem"
              x-component="Select"
              enum={[
                {
                  label: '男',
                  value: 1,
                },
                {
                  label: '女',
                  value: 2,
                },
                {
                  label: '第三性别',
                  value: 3,
                },
              ]}
              required
            />
            <SchemaField.String
              name="birthday"
              title="生日"
              required
              x-decorator="FormItem"
              x-component="DatePicker"
            />
            <SchemaField.String
              name="address"
              title="地址"
              required
              x-decorator="FormItem"
              x-component="Cascader"
              x-reactions="{{fetchAddress}}"
            />
            <SchemaField.String
              name="idCard"
              title="身份证复印件"
              required
              x-decorator="FormItem"
              x-component="IDUpload"
            />
            <SchemaField.Array
              name="contacts"
              title="联系人信息"
              required
              x-decorator="FormItem"
              x-component="ArrayItems"
            >
              <SchemaField.Object x-component="ArrayItems.Item">
                <SchemaField.Void
                  x-decorator="FormItem"
                  x-component="ArrayItems.SortHandle"
                />
                <SchemaField.Void
                  name="popover"
                  title="维护联系人信息"
                  x-decorator="Editable.Popover"
                  x-component="FormLayout"
                  x-component-props={{
                    layout: 'vertical',
                  }}
                  x-reactions={[
                    {
                      dependencies: ['.popover.name'],
                      fulfill: {
                        schema: {
                          title: '{{$deps[0]}}',
                        },
                      },
                    },
                  ]}
                >
                  <SchemaField.String
                    name="name"
                    required
                    title="姓名"
                    x-decorator="FormItem"
                    x-component="Input"
                    x-component-props={{
                      style: {
                        width: 300,
                      },
                    }}
                  />
                  <SchemaField.String
                    name="email"
                    title="邮箱"
                    x-validator={[{ required: true }, 'email']}
                    x-decorator="FormItem"
                    x-component="Input"
                    x-component-props={{
                      style: {
                        width: 300,
                      },
                    }}
                  />
                  <SchemaField.String
                    name="phone"
                    required
                    title="手机号"
                    x-validator="phone"
                    x-decorator="FormItem"
                    x-component="Input"
                    x-component-props={{
                      style: {
                        width: 300,
                      },
                    }}
                  />
                </SchemaField.Void>
                <SchemaField.Void
                  x-decorator="FormItem"
                  x-component="ArrayItems.Remove"
                />
              </SchemaField.Object>
              <SchemaField.Void
                x-component="ArrayItems.Addition"
                title="新增联系人"
              />
            </SchemaField.Array>
          </SchemaField>
          <FormButtonGroup.FormItem>
            <Submit block size="large">
              注册
            </Submit>
          </FormButtonGroup.FormItem>
        </Form>
      </Card>
    </div>
  )
}
```

#### JSON Schema 案例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField } from '@formily/react'
import {
  Form,
  FormItem,
  FormLayout,
  Input,
  Select,
  Password,
  Cascader,
  DatePicker,
  Submit,
  Space,
  FormGrid,
  Upload,
  ArrayItems,
  Editable,
  FormButtonGroup,
} from '@formily/antd'
import { action } from '@formily/reactive'
import { Card, Button } from 'antd'
import { UploadOutlined } from '@ant-design/icons'

const form = createForm({
  validateFirst: true,
})

const IDUpload = (props) => {
  return (
    <Upload
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
      headers={{
        authorization: 'authorization-text',
      }}
    >
      <Button icon={<UploadOutlined />}>上传复印件</Button>
    </Upload>
  )
}

const SchemaField = createSchemaField({
  components: {
    FormItem,
    FormGrid,
    FormLayout,
    Input,
    DatePicker,
    Cascader,
    Select,
    Password,
    IDUpload,
    Space,
    ArrayItems,
    Editable,
  },
  scope: {
    fetchAddress: (field) => {
      const transform = (data = {}) => {
        return Object.entries(data).reduce((buf, [key, value]) => {
          if (typeof value === 'string')
            return buf.concat({
              label: value,
              value: key,
            })
          const { name, code, cities, districts } = value
          const _cities = transform(cities)
          const _districts = transform(districts)
          return buf.concat({
            label: name,
            value: code,
            children: _cities.length
              ? _cities
              : _districts.length
              ? _districts
              : undefined,
          })
        }, [])
      }

      field.loading = true
      fetch('//unpkg.com/china-location/dist/location.json')
        .then((res) => res.json())
        .then(
          action.bound((data) => {
            field.dataSource = transform(data)
            field.loading = false
          })
        )
    },
  },
})

const schema = {
  type: 'object',
  properties: {
    username: {
      type: 'string',
      title: '用户名',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    password: {
      type: 'string',
      title: '密码',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Password',
      'x-component-props': {
        checkStrength: true,
      },
      'x-reactions': [
        {
          dependencies: ['.confirm_password'],
          fulfill: {
            state: {
              selfErrors:
                '{{$deps[0] && $self.value && $self.value !== $deps[0] ? "确认密码不匹配" : ""}}',
            },
          },
        },
      ],
    },
    confirm_password: {
      type: 'string',
      title: '确认密码',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Password',
      'x-component-props': {
        checkStrength: true,
      },
      'x-reactions': [
        {
          dependencies: ['.password'],
          fulfill: {
            state: {
              selfErrors:
                '{{$deps[0] && $self.value && $self.value !== $deps[0] ? "确认密码不匹配" : ""}}',
            },
          },
        },
      ],
    },
    name: {
      type: 'void',
      title: '姓名',
      'x-decorator': 'FormItem',
      'x-decorator-props': {
        asterisk: true,
        feedbackLayout: 'none',
      },
      'x-component': 'FormGrid',
      properties: {
        firstName: {
          type: 'string',
          required: true,
          'x-decorator': 'FormItem',
          'x-component': 'Input',
          'x-component-props': {
            placeholder: '姓',
          },
        },
        lastName: {
          type: 'string',
          required: true,
          'x-decorator': 'FormItem',
          'x-component': 'Input',
          'x-component-props': {
            placeholder: '名',
          },
        },
      },
    },
    email: {
      type: 'string',
      title: '邮箱',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
      'x-validator': 'email',
    },
    gender: {
      type: 'string',
      title: '性别',
      enum: [
        {
          label: '男',
          value: 1,
        },
        {
          label: '女',
          value: 2,
        },
        {
          label: '第三性别',
          value: 3,
        },
      ],
      'x-decorator': 'FormItem',
      'x-component': 'Select',
    },
    birthday: {
      type: 'string',
      required: true,
      title: '生日',
      'x-decorator': 'FormItem',
      'x-component': 'DatePicker',
    },
    address: {
      type: 'string',
      required: true,
      title: '地址',
      'x-decorator': 'FormItem',
      'x-component': 'Cascader',
      'x-reactions': '{{fetchAddress}}',
    },
    idCard: {
      type: 'string',
      required: true,
      title: '身份证复印件',
      'x-decorator': 'FormItem',
      'x-component': 'IDUpload',
    },
    contacts: {
      type: 'array',
      required: true,
      title: '联系人信息',
      'x-decorator': 'FormItem',
      'x-component': 'ArrayItems',
      items: {
        type: 'object',
        'x-component': 'ArrayItems.Item',
        properties: {
          sort: {
            type: 'void',
            'x-decorator': 'FormItem',
            'x-component': 'ArrayItems.SortHandle',
          },
          popover: {
            type: 'void',
            title: '完善联系人信息',
            'x-decorator': 'Editable.Popover',
            'x-component': 'FormLayout',
            'x-component-props': {
              layout: 'vertical',
            },
            'x-reactions': [
              {
                dependencies: ['.popover.name'],
                fulfill: {
                  schema: {
                    title: '{{$deps[0]}}',
                  },
                },
              },
            ],
            properties: {
              name: {
                type: 'string',
                title: '姓名',
                required: true,
                'x-decorator': 'FormItem',
                'x-component': 'Input',
                'x-component-props': {
                  style: {
                    width: 300,
                  },
                },
              },
              email: {
                type: 'string',
                title: '邮箱',
                'x-decorator': 'FormItem',
                'x-component': 'Input',
                'x-validator': [{ required: true }, 'email'],
                'x-component-props': {
                  style: {
                    width: 300,
                  },
                },
              },
              phone: {
                type: 'string',
                title: '手机号',
                'x-decorator': 'FormItem',
                'x-component': 'Input',
                'x-validator': [{ required: true }, 'phone'],
                'x-component-props': {
                  style: {
                    width: 300,
                  },
                },
              },
            },
          },
          remove: {
            type: 'void',
            'x-decorator': 'FormItem',
            'x-component': 'ArrayItems.Remove',
          },
        },
      },
      properties: {
        addition: {
          type: 'void',
          title: '新增联系人',
          'x-component': 'ArrayItems.Addition',
        },
      },
    },
  },
}

export default () => {
  return (
    <div
      style={{
        display: 'flex',
        justifyContent: 'center',
        background: '#eee',
        padding: '40px 0',
      }}
    >
      <Card title="新用户注册" style={{ width: 620 }}>
        <Form
          form={form}
          labelCol={5}
          wrapperCol={16}
          onAutoSubmit={console.log}
        >
          <SchemaField schema={schema} />
          <FormButtonGroup.FormItem>
            <Submit block size="large">
              注册
            </Submit>
          </FormButtonGroup.FormItem>
        </Form>
      </Card>
    </div>
  )
}
```

#### 纯 JSX 案例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { Field, VoidField, ArrayField } from '@formily/react'
import {
  Form,
  FormItem,
  Input,
  Select,
  Password,
  Cascader,
  DatePicker,
  Submit,
  FormGrid,
  Upload,
  FormButtonGroup,
  ArrayBase,
  Editable,
  FormLayout,
} from '@formily/antd'
import { action } from '@formily/reactive'
import { Card, Button } from 'antd'
import { UploadOutlined } from '@ant-design/icons'

const form = createForm({
  validateFirst: true,
})

const IDUpload = (props) => {
  return (
    <Upload
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
      headers={{
        authorization: 'authorization-text',
      }}
    >
      <Button icon={<UploadOutlined />}>上传复印件</Button>
    </Upload>
  )
}

export default () => {
  return (
    <div
      style={{
        display: 'flex',
        justifyContent: 'center',
        background: '#eee',
        padding: '40px 0',
      }}
    >
      <Card title="新用户注册" style={{ width: 620 }}>
        <Form
          form={form}
          labelCol={5}
          wrapperCol={16}
          onAutoSubmit={console.log}
        >
          <Field
            name="username"
            title="用户名"
            required
            decorator={[FormItem]}
            component={[Input]}
          />
          <Field
            name="password"
            title="密码"
            required
            decorator={[FormItem]}
            component={[
              Password,
              {
                checkStrength: true,
              },
            ]}
            reactions={(field) => {
              const confirm = field.query('.confirm_password')
              field.selfErrors =
                confirm.get('value') &&
                field.value &&
                field.value !== confirm.get('value')
                  ? '确认密码不匹配'
                  : ''
            }}
          />
          <Field
            name="confirm_password"
            title="确认密码"
            required
            decorator={[FormItem]}
            component={[
              Password,
              {
                checkStrength: true,
              },
            ]}
            reactions={(field) => {
              const password = field.query('.password')
              field.selfErrors =
                password.get('value') &&
                field.value &&
                field.value !== password.get('value')
                  ? '确认密码不匹配'
                  : ''
            }}
          />
          <VoidField
            name="name"
            title="姓名"
            decorator={[
              FormItem,
              {
                asterisk: true,
                feedbackLayout: 'none',
              },
            ]}
            component={[FormGrid]}
          >
            <Field
              name="firstName"
              decorator={[FormItem]}
              component={[
                Input,
                {
                  placeholder: '姓',
                },
              ]}
              required
            />
            <Field
              name="lastName"
              decorator={[FormItem]}
              component={[
                Input,
                {
                  placeholder: '名',
                },
              ]}
              required
            />
          </VoidField>
          <Field
            name="email"
            title="邮箱"
            required
            validator="email"
            decorator={[FormItem]}
            component={[Input]}
          />
          <Field
            name="gender"
            title="性别"
            decorator={[FormItem]}
            component={[Select]}
            dataSource={[
              {
                label: '男',
                value: 1,
              },
              {
                label: '女',
                value: 2,
              },
              {
                label: '第三性别',
                value: 3,
              },
            ]}
            required
          />
          <Field
            name="birthday"
            title="生日"
            required
            decorator={[FormItem]}
            component={[DatePicker]}
          />
          <Field
            name="address"
            title="地址"
            required
            decorator={[FormItem]}
            component={[Cascader]}
            reactions={(field) => {
              const transform = (data = {}) => {
                return Object.entries(data).reduce((buf, [key, value]) => {
                  if (typeof value === 'string')
                    return buf.concat({
                      label: value,
                      value: key,
                    })
                  const { name, code, cities, districts } = value
                  const _cities = transform(cities)
                  const _districts = transform(districts)
                  return buf.concat({
                    label: name,
                    value: code,
                    children: _cities.length
                      ? _cities
                      : _districts.length
                      ? _districts
                      : undefined,
                  })
                }, [])
              }

              field.loading = true
              fetch('//unpkg.com/china-location/dist/location.json')
                .then((res) => res.json())
                .then(
                  action.bound((data) => {
                    field.dataSource = transform(data)
                    field.loading = false
                  })
                )
            }}
          />
          <Field
            name="idCard"
            title="身份证复印件"
            required
            decorator={[FormItem]}
            component={[IDUpload]}
          />
          <ArrayField name="contacts" title="联系人信息" decorator={[FormItem]}>
            {(field) => (
              <ArrayBase>
                {field.value?.map((item, index) => (
                  <div key={index} className="array-items-item">
                    <Field
                      name={`${index}`}
                      title="完善联系人信息"
                      component={[Editable.Popover]}
                      reactions={(field) => {
                        field.title =
                          field.query('.[].name').value() || field.title
                      }}
                    >
                      <VoidField
                        name="layout"
                        component={[FormLayout, { layout: 'vertical' }]}
                      >
                        <Field
                          name="name"
                          title="姓名"
                          required
                          decorator={[FormItem]}
                          component={[
                            Input,
                            {
                              style: {
                                width: 300,
                              },
                            },
                          ]}
                        />
                        <Field
                          name="email"
                          title="邮箱"
                          required
                          validator="email"
                          decorator={[FormItem]}
                          component={[
                            Input,
                            {
                              style: {
                                width: 300,
                              },
                            },
                          ]}
                        />
                        <Field
                          name="phone"
                          title="手机号"
                          required
                          validator="phone"
                          decorator={[FormItem]}
                          component={[
                            Input,
                            {
                              style: {
                                width: 300,
                              },
                            },
                          ]}
                        />
                      </VoidField>
                    </Field>
                    <FormItem.BaseItem>
                      <ArrayBase.Remove index={index} />
                      <ArrayBase.MoveDown index={index} />
                      <ArrayBase.MoveUp index={index} />
                    </FormItem.BaseItem>
                  </div>
                ))}
                <ArrayBase.Addition title="新增联系人" />
              </ArrayBase>
            )}
          </ArrayField>
          <FormButtonGroup.FormItem>
            <Submit block size="large">
              注册
            </Submit>
          </FormButtonGroup.FormItem>
        </Form>
      </Card>
    </div>
  )
}
```

## 忘记密码

#### Markup Schema 案例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField } from '@formily/react'
import {
  Form,
  FormItem,
  Input,
  Password,
  Submit,
  FormButtonGroup,
} from '@formily/antd'
import { Card } from 'antd'

const form = createForm({
  validateFirst: true,
})

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    Password,
  },
})

export default () => {
  return (
    <div
      style={{
        display: 'flex',
        justifyContent: 'center',
        background: '#eee',
        padding: '40px 0',
      }}
    >
      <Card title="变更密码" style={{ width: 620 }}>
        <Form
          form={form}
          labelCol={5}
          wrapperCol={16}
          onAutoSubmit={console.log}
        >
          <SchemaField>
            <SchemaField.String
              name="username"
              title="用户名"
              required
              x-decorator="FormItem"
              x-component="Input"
            />
            <SchemaField.String
              name="email"
              title="邮箱"
              required
              x-validator="email"
              x-decorator="FormItem"
              x-component="Input"
            />
            <SchemaField.String
              name="old_password"
              title="原始密码"
              required
              x-decorator="FormItem"
              x-component="Password"
            />
            <SchemaField.String
              name="password"
              title="新密码"
              required
              x-decorator="FormItem"
              x-component="Password"
              x-component-props={{
                checkStrength: true,
              }}
              x-reactions={[
                {
                  dependencies: ['.confirm_password'],
                  fulfill: {
                    state: {
                      selfErrors:
                        '{{$deps[0] && $self.value && $self.value !== $deps[0] ? "确认密码不匹配" : ""}}',
                    },
                  },
                },
              ]}
            />
            <SchemaField.String
              name="confirm_password"
              title="确认密码"
              required
              x-decorator="FormItem"
              x-component="Password"
              x-component-props={{
                checkStrength: true,
              }}
              x-reactions={[
                {
                  dependencies: ['.password'],
                  fulfill: {
                    state: {
                      selfErrors:
                        '{{$deps[0] && $self.value && $self.value !== $deps[0] ? "确认密码不匹配" : ""}}',
                    },
                  },
                },
              ]}
            />
          </SchemaField>
          <FormButtonGroup.FormItem>
            <Submit block size="large">
              确认变更
            </Submit>
          </FormButtonGroup.FormItem>
        </Form>
      </Card>
    </div>
  )
}
```

#### JSON Schema 案例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { createSchemaField } from '@formily/react'
import {
  Form,
  FormItem,
  Input,
  Password,
  Submit,
  FormButtonGroup,
} from '@formily/antd'
import { Card } from 'antd'

const form = createForm({
  validateFirst: true,
})

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    Password,
  },
})

const schema = {
  type: 'object',
  properties: {
    username: {
      type: 'string',
      title: '用户名',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    email: {
      type: 'string',
      title: '邮箱',
      required: true,
      'x-validator': 'email',
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    oldPassword: {
      type: 'string',
      title: '原始密码',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Password',
    },
    password: {
      type: 'string',
      title: '新密码',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Password',
      'x-component-props': {
        checkStrength: true,
      },
      'x-reactions': [
        {
          dependencies: ['.confirm_password'],
          fulfill: {
            state: {
              selfErrors:
                '{{$deps[0] && $self.value && $self.value !== $deps[0] ? "确认密码不匹配" : ""}}',
            },
          },
        },
      ],
    },
    confirm_password: {
      type: 'string',
      title: '确认密码',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Password',
      'x-component-props': {
        checkStrength: true,
      },
      'x-reactions': [
        {
          dependencies: ['.password'],
          fulfill: {
            state: {
              selfErrors:
                '{{$deps[0] && $self.value && $self.value !== $deps[0] ? "确认密码不匹配" : ""}}',
            },
          },
        },
      ],
    },
  },
}

export default () => {
  return (
    <div
      style={{
        display: 'flex',
        justifyContent: 'center',
        background: '#eee',
        padding: '40px 0',
      }}
    >
      <Card title="变更密码" style={{ width: 620 }}>
        <Form
          form={form}
          labelCol={5}
          wrapperCol={16}
          onAutoSubmit={console.log}
        >
          <SchemaField schema={schema} />
          <FormButtonGroup.FormItem>
            <Submit block size="large">
              确认变更
            </Submit>
          </FormButtonGroup.FormItem>
        </Form>
      </Card>
    </div>
  )
}
```

#### 纯 JSX 案例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { Field } from '@formily/react'
import {
  Form,
  FormItem,
  Input,
  Password,
  Submit,
  FormButtonGroup,
} from '@formily/antd'
import { Card } from 'antd'

const form = createForm({
  validateFirst: true,
})

export default () => {
  return (
    <div
      style={{
        display: 'flex',
        justifyContent: 'center',
        background: '#eee',
        padding: '40px 0',
      }}
    >
      <Card title="变更密码" style={{ width: 620 }}>
        <Form
          form={form}
          labelCol={5}
          wrapperCol={16}
          onAutoSubmit={console.log}
        >
          <Field
            name="username"
            title="用户名"
            required
            decorator={[FormItem]}
            component={[Input]}
          />
          <Field
            name="email"
            title="邮箱"
            required
            validator="email"
            decorator={[FormItem]}
            component={[Input]}
          />
          <Field
            name="old_password"
            title="原始密码"
            required
            decorator={[FormItem]}
            component={[Password]}
          />
          <Field
            name="password"
            title="新密码"
            required
            decorator={[FormItem]}
            component={[
              Password,
              {
                checkStrength: true,
              },
            ]}
            reactions={(field) => {
              const confirm = field.query('.confirm_password')
              field.selfErrors =
                confirm.get('value') &&
                field.value &&
                field.value !== confirm.get('value')
                  ? '确认密码不匹配'
                  : ''
            }}
          />
          <Field
            name="confirm_password"
            title="确认密码"
            required
            decorator={[FormItem]}
            component={[
              Password,
              {
                checkStrength: true,
              },
            ]}
            reactions={(field) => {
              const confirm = field.query('.password')
              field.selfErrors =
                confirm.get('value') &&
                field.value &&
                field.value !== confirm.get('value')
                  ? '确认密码不匹配'
                  : ''
            }}
          />
          <FormButtonGroup.FormItem>
            <Submit block size="large">
              确认变更
            </Submit>
          </FormButtonGroup.FormItem>
        </Form>
      </Card>
    </div>
  )
}
```
</file>

<file path="docs/guide/scenes/more.zh-CN.md">
# 更多场景

因为 Formily 在表单层面上是一个非常完备的方案，而且还很灵活，支持的场景非常多，但是场景案例，我们无法一一列举。

所以，还是希望社区能帮助 Formily 完善更多场景案例！我们会不胜感激！😀
</file>

<file path="docs/guide/scenes/query-list.zh-CN.md">
# 查询列表

因为 Formily Schema 是可以完全描述 UI 的，所以我们可以简单的抽象出 QueryList/QueryForm/QueryTable 几个组件来组合实现查询列表组件,以下只是给出伪代码，因为查询列表场景通常都会涉及大量业务封装，目前 Formily 还没想好怎么既考虑通用性又能考虑业务快速上手，所以暂时不开放出具体组件。

不过可以先看看伪代码，如果官方实现这几个组件，那使用方式肯定会是这样：

```tsx pure
import React from 'react'
import { Void, Object, Array, String } from './MySchemaField'
export default () => (
  <Void
    x-component="QueryList"
    x-component-props={{
      service: (params) => fetchRecords(params),
    }}
  >
    <Object name="query" x-component="QueryForm">
      <String name="name" x-component="Input" />
      <String name="id" x-component="Input" />
    </Object>
    <Void name="toolbar" x-component="QueryToolbar"></Void>
    <Array name="list" x-component="QueryTable">
      <Object>
        <Void x-component="QueryTable.Column">
          <String name="name" x-component="PreviewText" />
        </Void>
        <Void x-component="QueryTable.Column">
          <String name="id" x-component="PreviewText" />
        </Void>
      </Object>
    </Array>
  </Void>
)
```

## 思路

- QueryList
  - 主要负责在顶层发请求，通过 React Context 下发 query 方法给 QueryForm 和 QueryTable 消费
  - 查询参数需要调用`form.query('query')`找到 QueryForm 的字段，然后取出字段的 value，用于发请求
  - 当查询完数据了，需要调用`form.query('list')`找到 QueryTable 的字段，然后给字段模型的 value 填 table 数据
- QueryTable
  - 思路跟 ArrayTable 非常相似，主要就是解析 Schema 子树，自己拼装出 Table 需要的 Columns 数据，如果想支持列合并，行合并，就需要解析更复杂的数据
  - 基于 props.value 用于渲染 Table 结构
  - 依赖 RecursionField 用于渲染 Table Column 内部数据
  - 依赖上下文传下来的 query 方法实现分页查询
- QueryForm
  - 没什么特殊逻辑，主要就是组合 Form+FormGrid 实现一个查询表单布局
  - 依赖上下文传下来的 query 方法实现查询表单查询
</file>

<file path="docs/guide/scenes/step-form.zh-CN.md">
# 分步表单

主要使用[@formily/antd](https://antd.formilyjs.org/zh-CN) 或 [@formily/next](https://fusion.formilyjs.org/zh-CN) 中的[FormStep](https://antd.formilyjs.org/zh-CN/components/form-step)组件
</file>

<file path="docs/guide/scenes/tab-form.zh-CN.md">
# 选项卡/手风琴表单

主要使用[@formily/antd](https://antd.formilyjs.org/zh-CN) 或 [@formily/next](https://fusion.formilyjs.org/zh-CN) 中的[FormTab](https://antd.formilyjs.org/zh-CN/components/form-tab)组件 与 [FormCollapse](https://antd.formilyjs.org/zh-CN/components/form-collapse)组件
</file>

<file path="docs/guide/contribution.zh-CN.md">
# 贡献指南

## 为什么要成为贡献者？

欢迎您来到我们的社区！**Formily** 是阿里巴巴唯一官方向外公布的开源表单框架，功能和质量都有一定保证，拥有众多的社区使用者，参与贡献可以使 **Formily** 变得强大，也会让更多开发者能够享受到更好的开发表单的体验，我们非常感谢任何对本项目发起 **Pull Request** 的同学。

## 我可以贡献什么？

- features 新增/修改功能特性
- unitest 新增/修改单测
- bugfix 修复现有 issue 的问题
- doc 文档改进
- other 其他

## 如何贡献？

#### 拉取仓库

- 原始仓库：https://github.com/alibaba/formily
- 目标仓库：fork 到自己的 github 上 ![img](https://img.alicdn.com/tfs/TB1NLrjxXY7gK0jSZKzXXaikpXa-2206-490.png)

#### 拉取分支

原始分支是 alibaba/formily master，拉取后的分支应该是 quirkyshop/formily master

> 注意：建议分支名为[feat]-[name]，[feat]是这个分支的类型，可选的有[feat][unitest][docs][bugfix][other]，[name]则是名字，自定义就好了。eg. unittest-core(意为：对核心补充单测)

#### 提交代码

代码风格遵循 2 空格，无分号，非说明请不要在代码中附带任何 console 相关的方法及 debugger。 开发完成后，到自己 fork 出来的仓库提交 pull request ![img](https://img.alicdn.com/tfs/TB1HSvqxkT2gK0jSZFkXXcIQFXa-2050-898.png)![img](https://img.alicdn.com/tfs/TB1O.6mxbr1gK0jSZR0XXbP8XXa-1696-254.png)

> 注意这里的左边目标仓库(base repository 是 alibaba/formily master) ，然后右边当前分支自己仓库的 doc-wiki

#### PR 规范

参考文档：https://github.com/alibaba/formily/blob/master/.github/GIT_COMMIT_SPECIFIC.md

- PR 名称：格式：`<type>(<scope>): <subject>` 举例：`feat(core): add unit test`
- PR 内容：列举本次改动的内容
- PR 要求：增加的 feat 内容，尽量做到注释清晰，相应的单测覆盖要尽可能覆盖
- BUGFIX 要求：如果修改的问题和 issues 相关，请在内容中附上相关的 issueID。

#### 审核与合并

审核阶段会进入多 review 的流程，`@janryWang` 负责审核这个改动是否合并，其他同学也会参与讨论，讨论的经过都会留存在 github 的 PR 里，钉钉群也会收到相应的通知。

当看到 Pull requests 列表中的状态变为 Closed 即为合并成功。 ![img](https://img.alicdn.com/tfs/TB1HUnjxXY7gK0jSZKzXXaikpXa-964-104.png)

#### 同步源仓库变更到 fork 后的仓库

```
# 首先在自己的分支增加一个 upstream，即原仓库
$ git remote add upstream https://github.com/alibaba/formily.git
# 获取原仓库最新的变更
$ git fetch upstream
# 同步原仓库的改动到本地分支
$ git pull upstream master [当前本地目标分支，不填默认就是当前分支]
```

#### 项目开发

```bash
$ cd formily
$ yarn install # 安装整体项目依赖
$ yarn build # 构建所有项目
$ yarn test # 执行单元测试
```

#### 开发文档

主项目文档

```bash
$ yarn start
```

内核项目文档

```bash
$ yarn workspace @formily/core start
```

React 项目文档

```bash
$ yarn workspace @formily/react start
```

Vue 项目文档

```bash
$ yarn workspace @formily/vue start
```

Antd 项目文档

```bash
$ yarn workspace @formily/antd start
```

Fusion 项目文档

```bash
$ yarn workspace @formily/next start
```

Reactive 项目文档

```bash
$ yarn workspace @formily/reactive start
```
</file>

<file path="docs/guide/form-builder.zh-CN.md">
# 表单设计器开发指南

## 介绍

![](http://img.alicdn.com/imgextra/i2/O1CN01eI9FLz22tZek2jv7E_!!6000000007178-2-tps-3683-2272.png)

Formily 表单设计器是基于[designable](https://github.com/alibaba/designable)而扩展出来的扩展包，它在继承了 designable 的基础能力上，提供了 Formily 基础表单的搭建和配置能力。

## 核心理念

Designable 的核心理念是将设计器搭建变成模块化组合，一切可替换，Designable 本身提供了一系列开箱即用的组件给用户使用，但是如果用户对组件不满意，是可以直接替换组件，从而实现最大化灵活定制，也就是 Designable 本身是不会提供任何插槽 Plugin 相关的 API

## 安装

Ant Design 用户

```bash
npm install --save @designable/formily-antd
```

Alibaba Fusion 用户

```bash
npm install --save @designable/formily-next
```

## 快速上手

[示例源代码](https://github.com/alibaba/designable/tree/main/formily/antd/playground)

```tsx pure
import 'antd/dist/antd.less'
import React, { useMemo } from 'react'
import ReactDOM from 'react-dom'
import {
  Designer, //设计器根组件，主要用于下发上下文
  DesignerToolsWidget, //画板工具挂件
  ViewToolsWidget, //视图切换工具挂件
  Workspace, //工作区组件，核心组件，用于管理工作区内的拖拽行为，树节点数据等等...
  OutlineTreeWidget, //大纲树组件，它会自动识别当前工作区，展示出工作区内树节点
  ResourceWidget, //拖拽源挂件
  HistoryWidget, //历史记录挂件
  StudioPanel, //主布局面板
  CompositePanel, //左侧组合布局面板
  WorkspacePanel, //工作区布局面板
  ToolbarPanel, //工具栏布局面板
  ViewportPanel, //视口布局面板
  ViewPanel, //视图布局面板
  SettingsPanel, //右侧配置表单布局面板
  ComponentTreeWidget, //组件树渲染器
} from '@designable/react'
import { SettingsForm } from '@designable/react-settings-form'
import {
  createDesigner,
  GlobalRegistry,
  Shortcut,
  KeyCode,
} from '@designable/core'
import {
  LogoWidget,
  ActionsWidget,
  PreviewWidget,
  SchemaEditorWidget,
  MarkupSchemaWidget,
} from './widgets'
import { saveSchema } from './service'
import {
  Form,
  Field,
  Input,
  Select,
  TreeSelect,
  Cascader,
  Radio,
  Checkbox,
  Slider,
  Rate,
  NumberPicker,
  Transfer,
  Password,
  DatePicker,
  TimePicker,
  Upload,
  Switch,
  Text,
  Card,
  ArrayCards,
  ObjectContainer,
  ArrayTable,
  Space,
  FormTab,
  FormCollapse,
  FormLayout,
  FormGrid,
} from '../src'

GlobalRegistry.registerDesignerLocales({
  'zh-CN': {
    sources: {
      Inputs: '输入控件',
      Layouts: '布局组件',
      Arrays: '自增组件',
      Displays: '展示组件',
    },
  },
  'en-US': {
    sources: {
      Inputs: 'Inputs',
      Layouts: 'Layouts',
      Arrays: 'Arrays',
      Displays: 'Displays',
    },
  },
})

const App = () => {
  const engine = useMemo(
    () =>
      createDesigner({
        shortcuts: [
          new Shortcut({
            codes: [
              [KeyCode.Meta, KeyCode.S],
              [KeyCode.Control, KeyCode.S],
            ],
            handler(ctx) {
              saveSchema(ctx.engine)
            },
          }),
        ],
        rootComponentName: 'Form',
      }),
    []
  )
  return (
    <Designer engine={engine}>
      <StudioPanel logo={<LogoWidget />} actions={<ActionsWidget />}>
        <CompositePanel>
          <CompositePanel.Item title="panels.Component" icon="Component">
            <ResourceWidget
              title="sources.Inputs"
              sources={[
                Input,
                Password,
                NumberPicker,
                Rate,
                Slider,
                Select,
                TreeSelect,
                Cascader,
                Transfer,
                Checkbox,
                Radio,
                DatePicker,
                TimePicker,
                Upload,
                Switch,
                ObjectContainer,
              ]}
            />
            <ResourceWidget
              title="sources.Layouts"
              sources={[
                Card,
                FormGrid,
                FormTab,
                FormLayout,
                FormCollapse,
                Space,
              ]}
            />
            <ResourceWidget
              title="sources.Arrays"
              sources={[ArrayCards, ArrayTable]}
            />
            <ResourceWidget title="sources.Displays" sources={[Text]} />
          </CompositePanel.Item>
          <CompositePanel.Item title="panels.OutlinedTree" icon="Outline">
            <OutlineTreeWidget />
          </CompositePanel.Item>
          <CompositePanel.Item title="panels.History" icon="History">
            <HistoryWidget />
          </CompositePanel.Item>
        </CompositePanel>
        <Workspace id="form">
          <WorkspacePanel>
            <ToolbarPanel>
              <DesignerToolsWidget />
              <ViewToolsWidget
                use={['DESIGNABLE', 'JSONTREE', 'MARKUP', 'PREVIEW']}
              />
            </ToolbarPanel>
            <ViewportPanel>
              <ViewPanel type="DESIGNABLE">
                {() => (
                  <ComponentTreeWidget
                    components={{
                      Form,
                      Field,
                      Input,
                      Select,
                      TreeSelect,
                      Cascader,
                      Radio,
                      Checkbox,
                      Slider,
                      Rate,
                      NumberPicker,
                      Transfer,
                      Password,
                      DatePicker,
                      TimePicker,
                      Upload,
                      Switch,
                      Text,
                      Card,
                      ArrayCards,
                      ArrayTable,
                      Space,
                      FormTab,
                      FormCollapse,
                      FormGrid,
                      FormLayout,
                      ObjectContainer,
                    }}
                  />
                )}
              </ViewPanel>
              <ViewPanel type="JSONTREE" scrollable={false}>
                {(tree, onChange) => (
                  <SchemaEditorWidget tree={tree} onChange={onChange} />
                )}
              </ViewPanel>
              <ViewPanel type="MARKUP" scrollable={false}>
                {(tree) => <MarkupSchemaWidget tree={tree} />}
              </ViewPanel>
              <ViewPanel type="PREVIEW">
                {(tree) => <PreviewWidget tree={tree} />}
              </ViewPanel>
            </ViewportPanel>
          </WorkspacePanel>
        </Workspace>
        <SettingsPanel title="panels.PropertySettings">
          <SettingsForm uploadAction="https://www.mocky.io/v2/5cc8019d300000980a055e76" />
        </SettingsPanel>
      </StudioPanel>
    </Designer>
  )
}

ReactDOM.render(<App />, document.getElementById('root'))
```
</file>

<file path="docs/guide/index.zh-CN.md">
# 介绍

## 问题

众所周知，表单场景一直都是前端中后台领域最复杂的场景，它的复杂度主要在哪里呢？

- 字段数量多，如何让性能不随字段数量增加而变差？
- 字段关联逻辑复杂，如何更简单的实现复杂的联动逻辑？字段与字段关联时，如何保证不影响表单性能？

  - 一对多(异步)
  - 多对一(异步)
  - 多对多(异步)

- 表单数据管理复杂
  - 表单值转换逻辑复杂(前后端格式不一致)
  - 同步默认值与异步默认值合并逻辑复杂
  - 跨表单数据通信，如何让性能不随字段数量增加而变差？
- 表单状态管理复杂
  - 着重提自增列表场景，如何让数组数据在移动，删除过程中，字段状态能够做到跟随移动？
- 表单的场景化复用
  - 查询列表
  - 弹窗/抽屉表单
  - 分步表单
  - 选项卡表单
- 动态渲染诉求很强烈
  - 字段配置化，让非专业前端也能快速搭建复杂表单
  - 跨端渲染，一份 JSON Schema，多端适配
  - 如何在表单协议中描述布局？
    - 纵向布局
    - 横向布局
    - 网格布局
    - 弹性布局
    - 自由布局
  - 如何在表单协议中描述逻辑？

这么多问题，怎么解决，想想就头大，但是我们还是得想办法解决，不仅要解决，还要优雅的解决，阿里数字供应链团队，在经历了大量的中后台实践和探索之后，总算沉淀出了 **Formily 表单解决方案** ，以上提到的所有问题，在经历了 UForm 到 Formily1.x，直到 Formily2.x 总算做到了 **优雅解决** 的程度。那 Formily2.x 是如何解决这些问题的呢？

## 解法

为了解决以上问题，我们可以对问题做进一步提炼，得出可突破的方向。

### 精确渲染

在 React 场景下实现一个表单需求，因为要收集表单数据，实现一些联动需求，大多数都是通过 setState 来实现字段数据收集，这样实现非常简单，心智成本非常低，但是却又引入了性能问题，因为每次输入都会导致所有字段全量渲染，虽然在 DOM 更新层面是有 diff，但是 diff 也是有计算成本的，浪费了很多计算资源，如果用时间复杂度来看的话，初次渲染表单是 O(n)，字段输入时也是 O(n)，这样明显是不合理的。

历史的经验总是对人类有帮助的，几十年前，人类创造出了 MVVM 设计模式。这样的设计模式核心是将视图模型抽象出来，然后在 DSL 模板层消费，DSL 借助某种依赖收集机制，然后在视图模型中统一调度，保证每次输入都是精确渲染的，这就是工业级的 GUI 形态！

刚好，github 社区为这样的 MVVM 模型抽象出了一个叫 [Mobx](https://github.com/mobxjs/mobx) 的状态管理解决方案，Mobx 最核心的能力就是它的依赖追踪机制和响应式模型的抽象能力。

所以，借助 Mobx，完全可以解决表单字段输入过程中的 O(n)问题，而且是可以很优雅的解决，但是 Formily2.x 在实现的过程中发现 Mobx 还是存在一些不兼容 Formily 核心思想的问题，最终，只能重新造了一个轮子，延续 Mobx 的核心思想的 [@formily/reactive](https://reactive.formilyjs.org/zh-CN)

这里提一下 [react-hook-form](https://github.com/react-hook-form/react-hook-form) ，非常流行，号称业界性能第一的表单方案，我们看看它最简单的案例：

```tsx pure
import React from 'react'
import ReactDOM from 'react-dom'
import { useForm } from 'react-hook-form'

function App() {
  const { register, handleSubmit, errors } = useForm() // initialize the hook
  const onSubmit = (data) => {
    console.log(data)
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input name="firstname" ref={register} /> {/* register an input */}
      <input name="lastname" ref={register({ required: true })} />
      {errors.lastname && 'Last name is required.'}
      <input name="age" ref={register({ pattern: /\d+/ })} />
      {errors.age && 'Please enter number for age.'}
      <input type="submit" />
    </form>
  )
}

ReactDOM.render(<App />, document.getElementById('root'))
```

虽然值管理做到了精确渲染，但是在触发校验的时候，还是会导致表单全量渲染，因为 errors 状态的更新，是必须要整体受控渲染才能实现同步，这仅仅只是校验会全量渲染，其实还有联动，react-hook-form 要实现联动，同样是需要整体受控渲染才能实现联动。所以，如果要真正实现精确渲染，非 Reactive 不可！

### 领域模型

前面问题中有提到表单的联动是非常复杂的，包含了字段间的各种关系，我们想象一下，大多数表单联动，基本上都是基于某些字段的值引发的联动，但是，实际业务需求可能会比较恶心，不仅要基于某些字段值引发联动，还会基于其他副作用值引发联动，比如应用状态，服务端数据状态，页面 URL，某个字段 UI 组件内部数据，当前字段自身的其他数据状态，某些特殊异步事件等等。用张图来描述：

![image-20210202081316031](//img.alicdn.com/imgextra/i3/O1CN01LWjBSt251w5BtGHW2_!!6000000007467-55-tps-1100-432.svg)

从上图可以看到，想要达成一个联动关系，核心是将字段的某些状态属性与某些数据关联起来，这里的某些数据可以是外界数据，也可以是自身数据，比如字段的显示/隐藏与某些数据的关联，又比如字段的值与某些数据关联，还比如字段的禁用/编辑与某些数据关联，就举了 3 个例子，我们其实已经抽象出了一个最简单的 Field 模型：

```typescript
interface Field {
  value: any
  visible: boolean
  disabled: boolean
}
```

当然，Field 模型仅仅只有这 3 个属性吗？肯定不是，如果我们要表达一个字段，那么字段的路径一定要有，因为要描述整个表单树结构，同时，我们还要管理起字段对应 UI 组件的属性，比如 Input 和 Select 都有它的属性，举个例子，Input 的 placeholder 与某些数据关联，或者 Select 的下拉选项与某些数据关联，这样就能理解了吧。所以，我们的 Field 模型可以是这样：

```
interface Field {
   path:string[],
   value:any,
   visible:boolean,
   disabled:boolean,
   component:[Component,ComponentProps]
}
```

我们加了 component 属性，它代表了字段所对应的 UI 组件和 UI 组件属性，这样就实现了某些数据与字段组件属性关联，甚至是与字段组件关联的能力。还有吗？当然还有，比如字段的外包裹容器，通常我们都叫 FormItem，它主要负责字段的外围的交互样式，比如字段标题，错误提示的样式等等，如果我们想要囊括更多联动，比如某些数据与 FormItem 的联动，那就得把外包裹容器也加进去。还有很多很多属性，这里没法一一列举。

从上面的思路中我们可以看到，为了解决联动问题，不管我们怎么抽象，最终还是会抽象出字段模型，它包含了字段相关的所有状态，只要去操作这些状态就能引发联动。

关于精确渲染，我们已经确定可以选用类似 Mobx 的 Reactive 方案，虽然是重新造了一个轮子，但是，Reactive 这种模式始终还是很适合抽象响应式模型，所以基于 Reactive 的能力，Formily 经过不断试错与纠正，总算设计出了真正优雅的表单模型。这样的表单模型，解决的是表单领域问题，所以也称之为领域模型，有了这样的领域模型，我们就能让表单的联动变得可枚举可预测，这样也为后面要说的协议描述联动打下了坚实基础。

### 路径系统

前面提到了表单领域模型中的字段模型，如果设计的更完备的话，其实不止是字段模型，必须还要有一个表单模型作为顶层模型，顶层模型管理着所有字段模型，每个字段都有着自己的路径，那如何查找这些字段呢？前面说到的联动关系，更多的是被动依赖关系，但是有些场景，我们就是要基于某个异步事件动作，去修改某个字段的状态，这里就涉及到如何优雅的查找某个字段，同样也是经过了大量的试错与纠正，Formily 独创的路径系统 @formily/path 很好的解决了这个问题，不仅仅是让字段查找变得优雅，它还能通过解构表达式去处理前后端数据结构不一致的恶心问题。

### 生命周期

借助 Mobx 和路径系统，我们已经打造了一个较为完备的表单方案了，但是这样抽象了之后，我们的方案就像个黑盒，外界无法感知到方案内部状态流转过程，想要在某个过程阶段内实现一些逻辑则无法实现，所以，这里我们就需要另外一个概念了，生命周期，只要我们将整个表单生命周期作为事件钩子暴露给外界，这样就能做到了既有抽象，但又灵活的表单方案。

### 协议驱动

如果想要实现动态可配置表单，那必然是需要将表单结构变得可序列化，序列化的方式有很多种，可以是以 UI 为思路的 UI 描述协议，也可以是以数据为思路的数据描述协议，因为表单本身就是为了维护一份数据，那自然而然，对于表单场景而言，数据协议最适合不过，想要描述数据结构，现在业界最流行的就是 [JSON-Schema](https://json-schema.org/) 了，因为 JSON Schema 协议上本身就有很多校验相关的属性，这就天然和表单校验关联上了。那 UI 描述协议就真的不适合描述表单吗？No，UI 描述协议适合更通用的 UI 表达，描述表单当然不在话下，只是它会更偏前端协议，相反，JSON-Schema，在后端模型层，都是可表达的，在描述数据上更通用，所以两种协议，各有所长，只是在单纯表单领域，JSON-Schema 会更偏领域化一些。

那么，如果选用 JSON-Schema，我们怎么描述 UI，怎么描述逻辑呢？单纯的描述数据，想要输出实际业务可用的表单页面，不太现实。

[react-jsonschema-form](https://github.com/rjsf-team/react-jsonschema-form)的解法是，数据是数据，UI 是 UI，这样的好处是，各个协议都是非常纯净的协议，但是却带来了较大的维护成本和理解成本，用户要开发一个表单，需要不断的在两种协议心智上做切换，所以，如果从技术视角来看这样的拆分，其实是非常合理的，但是从产品视角来看的话，拆分则是把成本抛给了用户，所以，Formily 的表单协议会更加倾向于在 JSON-Schema 上做扩展。

那么，如何扩展呢？为了不污染标准 JSON-Schema 属性，我们统一以`x-*`格式来表达扩展属性：

```json
{
  "type": "string",
  "title": "字符串",
  "description": "这是一个字符串",
  "x-component": "Input",
  "x-component-props": {
    "placeholder": "请输入"
  }
}
```

这样看来，UI 协议与数据协议混合在一起，只要有一个统一的扩展约定，也还是能保证两种协议职责单一。

然后，如果想要在某些字段上包裹一个 UI 容器怎么办呢？这里，Formily 定义了一个新的 schema type，叫`void`。void 不陌生，W3C 规范里也有 void element，js 里也有 void 关键字，前者代表虚元素，后者代表虚指针，所以，在 JSON Schema 中，引入 void，代表一个虚数据节点，表示该节点并不占用实际数据结构。所以，我们可以这样：

```json
{
  "type": "void",
  "title": "卡片",
  "description": "这是一个卡片",
  "x-component": "Card",
  "properties": {
    "string": {
      "type": "string",
      "title": "字符串",
      "description": "这是一个字符串",
      "x-component": "Input",
      "x-component-props": {
        "placeholder": "请输入"
      }
    }
  }
}
```

这样就可以描述了一个 UI 容器了，因为可以描述 UI 容器，我们就能轻易封装一个场景化的组件了，比如 FormStep，那么我们怎么描述字段间联动呢？比如一个字段要控制另一个字段的显示隐藏。我们可以这样：

```json
{
  "type": "object",
  "properties": {
    "source": {
      "type": "string",
      "title": "Source",
      "x-component": "Input",
      "x-component-props": {
        "placeholder": "请输入"
      }
    },
    "target": {
      "type": "string",
      "title": "Target",
      "x-component": "Input",
      "x-component-props": {
        "placeholder": "请输入"
      },
      "x-reactions": [
        {
          "dependencies": ["source"],
          "when": "{{$deps[0] == '123'}}",
          "fulfill": {
            "state": {
              "visible": true
            }
          },
          "otherwise": {
            "state": {
              "visible": false
            }
          }
        }
      ]
    }
  }
}
```

借助`x-reactions`描述了 target 字段，依赖了 source 字段的值，如果值为`'123'`的时候则显示 target 字段，否则隐藏，这种联动方式是一种被动联动，那如果我们希望实现主动联动呢？可以这样：

```json
{
  "type": "object",
  "properties": {
    "source": {
      "type": "string",
      "title": "Source",
      "x-component": "Input",
      "x-component-props": {
        "placeholder": "请输入"
      },
      "x-reactions": [
        {
          "when": "{{$self.value == '123'}}",
          "target": "target",
          "fulfill": {
            "state": {
              "visible": true
            }
          },
          "otherwise": {
            "state": {
              "visible": false
            }
          }
        }
      ]
    },
    "target": {
      "type": "string",
      "title": "Target",
      "x-component": "Input",
      "x-component-props": {
        "placeholder": "请输入"
      }
    }
  }
}
```

只需要将`x-reactions`换个位置，放到 source 字段上，然后再指定一个 target 即可。

可以看到，我们的联动，其实核心是基于：

- 条件
- 条件满足的动作
- 条件不满足的动作

来实现的，因为内部状态管理借助了 类似 Mobx 的[@formily/reactive](https://reactive.formilyjs.org/zh-CN)方案，所以，Formily 很轻松的就实现了被动和主动联动场景，覆盖了绝大多数业务需求。

所以，我们的表单完全可以使用协议来描述了，不管是再复杂的布局，还是很复杂的联动，都能做到可配置。

### 分层架构

前面讲了对于一开始的各种问题的解法，那么现在我们如何设计才能让 Formily 更加自洽且优雅呢？

![](https://img.alicdn.com/imgextra/i3/O1CN01iEwHrP1NUw84xTded_!!6000000001574-55-tps-1939-1199.svg)

这张图主要将 Formily 分为了内核层，UI 桥接层，扩展组件层，和配置应用层。

内核层是 UI 无关的，它保证了用户管理的逻辑和状态是不耦合任何一个框架，这样有几个好处：

- 逻辑与 UI 框架解耦，未来做框架级别的迁移，业务代码无需大范围重构
- 学习成本统一，如果用户使用了@formily/react，以后业务迁移@formily/vue，用户不需要重新学习

JSON Schema 独立存在，给 UI 桥接层消费，保证了协议驱动在不同 UI 框架下的绝对一致性，不需要重复实现协议解析逻辑。

扩展组件层，提供一系列表单场景化组件，保证用户开箱即用。无需花大量时间做二次开发。

## 竞品对比

```tsx
/**
 * inline: true
 */
import React from 'react'
import { Table, Tooltip } from 'antd'
import { QuestionCircleOutlined } from '@ant-design/icons'

const text = (content, tooltips) => {
  if (tooltips) {
    return (
      <div>
        {content}
        <Tooltip title={tooltips}>
          <QuestionCircleOutlined style={{ marginLeft: 3 }} />
        </Tooltip>
      </div>
    )
  }
  return content
}

const dataSource = [
  {
    feature: '自定义组件接入成本',
    antd: '4.x接入成本低',
    fusion: '高',
    formik: '低',
    finalForm: '低',
    schemaForm: text('高', '因为耦合bootstrap'),
    hookForm: text('高', '因为耦合React Ref'),
    'formily1.x': '低',
    'formily2.x': '低',
  },
  {
    feature: '性能',
    antd: text('4.x性能较好', '只解决了值同步精确渲染'),
    fusion: '差',
    formik: '差',
    finalForm: text('较好', '但只解决了值同步精确渲染'),
    schemaForm: '差',
    hookForm: text('好', '但只解决了值同步精确渲染'),
    'formily1.x': text('非常好', '能解决联动过程中的精确渲染'),
    'formily2.x': text('非常好', '能解决联动过程中的精确渲染'),
  },
  {
    feature: '是否支持动态渲染',
    antd: '否',
    fusion: '否',
    formik: '否',
    finalForm: '否',
    schemaForm: '是',
    hookForm: '否',
    'formily1.x': '是',
    'formily2.x': '是',
  },
  {
    feature: '是否开箱即用',
    antd: '是',
    fusion: '是',
    formik: '否',
    finalForm: '否',
    schemaForm: '是',
    hookForm: '否',
    'formily1.x': '是',
    'formily2.x': '是',
  },
  {
    feature: '是否支持跨端',
    antd: '否',
    fusion: '否',
    formik: '否',
    finalForm: '否',
    schemaForm: '否',
    hookForm: '否',
    'formily1.x': '是',
    'formily2.x': '是',
  },
  {
    feature: '开发效率',
    antd: '一般',
    fusion: '一般',
    formik: '一般',
    finalForm: '一般',
    schemaForm: text('低', '源码开发需要手工维护JSON'),
    hookForm: '一般',
    'formily1.x': '高',
    'formily2.x': '高',
  },
  {
    feature: '学习成本',
    antd: '低',
    fusion: '低',
    formik: '低',
    finalForm: '高',
    schemaForm: '高',
    hookForm: '低',
    'formily1.x': '很高',
    'formily2.x': text('高', '概念大量减少'),
  },
  {
    feature: '视图代码可维护性',
    antd: text('低', '大量条件表达式'),
    fusion: text('低', '大量条件表达式'),
    formik: text('低', '大量条件表达式'),
    finalForm: text('低', '大量条件表达式'),
    schemaForm: '高',
    hookForm: text('低', '大量条件表达式'),
    'formily1.x': '高',
    'formily2.x': '高',
  },
  {
    feature: '场景化封装能力',
    antd: '无',
    fusion: '无',
    formik: '无',
    finalForm: '无',
    schemaForm: '有',
    hookForm: '无',
    'formily1.x': '有',
    'formily2.x': '有',
  },
  {
    feature: '是否支持表单预览态',
    antd: '否',
    fusion: '是',
    formik: '否',
    finalForm: '否',
    schemaForm: '否',
    hookForm: '否',
    'formily1.x': '是',
    'formily2.x': '是',
  },
]

export default () => {
  return (
    <Table
      dataSource={dataSource}
      pagination={false}
      bordered
      scroll={{ x: 1600 }}
      size="small"
    >
      <Table.Column title="能力" dataIndex="feature" width={160} />
      <Table.Column title="Ant Design Form" dataIndex="antd" width={160} />
      <Table.Column title="Fusion Form" dataIndex="fusion" width={160} />
      <Table.Column title="Formik" dataIndex="formik" width={160} />
      <Table.Column
        title="React Final Form"
        dataIndex="finalForm"
        width={160}
      />
      <Table.Column
        title="React Schema Form"
        dataIndex="schemaForm"
        width={160}
      />
      <Table.Column title="React Hook Form" dataIndex="hookForm" width={160} />
      <Table.Column title="Formily1.x" dataIndex="formily1.x" width={160} />
      <Table.Column title="Formily2.x" dataIndex="formily2.x" width={160} />
    </Table>
  )
}
```

## 核心优势

- 高性能
- 开箱即用
- 联动逻辑实现高效
- 跨端能力，逻辑可跨框架，跨终端复用
- 动态渲染能力

## 核心劣势

- 学习成本较高，虽然 2.x 已经在大量收敛概念，但还是存在一定的学习成本。

## 谁在使用？

- 阿里巴巴
  - 数字供应链事业部
  - 淘系技术部
  - 飞猪
  - 阿里云
  - 蚂蚁
  - 政务平台
  - 大文娱
  - 盒马
  - 阿里妈妈
  - 数据平台
  - ICBU
  - 口碑
  - 钉钉
  - 天猫超市、天猫国际、阿里健康、农村淘宝、淘宝心选
- 腾讯
- 字节跳动

## Q/A

问：有了 Vue 了，为什么还需要提供@formily/vue？

答：Vue 是一个 UI 框架，它解决的问题是更大范围的 UI 问题，虽然它的 reactive 能力在表单场景上表现出众，至少比原生 React 写表单要方便，但是如果在更复杂的表单场景上，我们还是需要做很多抽象和封装，所以@formily/vue 就是为了帮您做这些抽象封装的事情，真正让您高效便捷的开发出超复杂表单应用。

问：Formily2.x 相比于 1.x 最大的优势是什么？

答：学习成本的大大降低，对，核心是为了让用户更快速的理解 Formily，我们在 2.x 设计的过程中极力的避免出现各种隐晦逻辑，边界问题，同时因为移除了 rxjs/styled-components 的依赖，整体体积大大降低

问：Formily2.x 的浏览器兼容性如何？

答：不支持 IE，因为 Reactive 的实现强依赖 Proxy
</file>

<file path="docs/guide/issue-helper.zh-CN.md">
# 问题反馈

## 在你开始之前...

Issue List 专用于跟踪错误报告和功能请求。 这意味着我们不接受使用相关的问题。 如果您创建了不符合要求的 Issue，它将立即被关闭。

如果您面临的是使用相关的问题，您可以这样：

- 先阅读介绍和组件文档
- 确保您已在 FAQ 和 changelog 中搜索了您的问题
- 在[Discussions](https://github.com/alibaba/formily/discussions)中查找/询问问题

试着先尝试搜索您的问题

它可能已经在开发分支中得到了解决，甚至已经解决。 但是，如果发现旧的，已关闭的问题仍保留在最新版本中，则应使用下面的表单打开一个新的问题，而不是对旧问题进行评论。

```tsx
import React from 'react'
import { createForm, onFieldMount, onFieldReact } from '@formily/core'
import { Field, VoidField } from '@formily/react'
import {
  Form,
  Input,
  Select,
  Radio,
  FormItem,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import semver from 'semver'
import ReactMde from 'react-mde'
import * as Showdown from 'showdown'
import 'react-mde/lib/styles/css/react-mde-all.css'

const converter = new Showdown.Converter({
  tables: true,
  simplifiedAutoLink: true,
  strikethrough: true,
  tasklists: true,
})

const MdInput = ({ value, onChange }) => {
  const [selectedTab, setSelectedTab] = React.useState('write')
  return (
    <div style={{ fontSize: 12, lineHeight: 1 }}>
      <ReactMde
        value={value}
        onChange={onChange}
        selectedTab={selectedTab}
        onTabChange={setSelectedTab}
        generateMarkdownPreview={(markdown) =>
          Promise.resolve(
            `<div class="markdown" style="margin:0 20px;">${
              converter.makeHtml(markdown) || ''
            }</div>`
          )
        }
      />
    </div>
  )
}

const form = createForm({
  validateFirst: true,
  effects() {
    onFieldMount('version', async (field) => {
      const { versions: unsort } = await fetch(
        'https://registry.npmmirror.com/@formily/core'
      ).then((res) => res.json())

      const versions = Object.keys(unsort).sort((v1, v2) =>
        semver.gte(v1, v2) ? -1 : 1
      )
      field.dataSource = versions.map((version) => ({
        label: version,
        value: version,
      }))
    })
    onFieldMount('package', async (field) => {
      const packages = await fetch(
        'https://formilyjs.org/.netlify/functions/npm-search?q=@formily'
      ).then((res) => res.json())
      field.dataSource = packages.map(({ name }) => {
        return {
          label: name,
          value: name,
        }
      })
    })
    onFieldReact('bug-desc', (field) => {
      field.visible = field.query('type').value() === 'Bug Report'
    })
    onFieldReact('feature-desc', (field) => {
      field.visible = field.query('type').value() === 'Feature Request'
    })
  },
})

const createIssueURL = ({
  type,
  title,
  version,
  package: pkg,
  reproduceLink,
  reproduceStep,
  expected,
  actually,
  comment,
  feature,
  api,
}) => {
  const url = new URL('https://github.com/alibaba/formily/issues/new')

  const bugInfo = `
- [ ] I have searched the [issues](https://github.com/alibaba/formily/issues) of this repository and believe that this is not a duplicate.

### Reproduction link
[![Edit on CodeSandbox](https://codesandbox.io/static/img/play-codesandbox.svg)](${
    reproduceLink || ''
  })

### Steps to reproduce
${reproduceStep || ''}

### What is expected?
${expected || ''}

### What is actually happening?
${actually || ''}

### Package
${pkg}@${version}

---

${comment || ''}

<!-- generated by formily-issue-helper. DO NOT REMOVE -->
`

  const prInfo = `
- [ ] I have searched the [issues](https://github.com/alibaba/formily/issues) of this repository and believe that this is not a duplicate.

### What problem does this feature solve?
${feature || ''}

### What does the proposed API look like?
${api || ''}


<!-- generated by formily-issue-helper. DO NOT REMOVE -->
`

  url.searchParams.set('title', `[${type}] ${title}`)
  url.searchParams.set('body', type === 'Bug Report' ? bugInfo : prInfo)

  return url.href
}

export default () => {
  return (
    <Form form={form} layout="vertical" size="large">
      <Field
        title="这是一个"
        name="type"
        required
        initialValue="Bug Report"
        decorator={[FormItem]}
        component={[Radio.Group, { optionType: 'button' }]}
        dataSource={[
          { label: '错误报告', value: 'Bug Report' },
          { label: '功能要求', value: 'Feature Request' },
        ]}
      />
      <Field
        title="标题"
        name="title"
        required
        decorator={[FormItem]}
        component={[Input]}
      />
      <VoidField name="bug-desc">
        <Field
          title="所在包"
          name="package"
          required
          decorator={[FormItem]}
          component={[Select, { showSearch: true }]}
        />
        <Field
          title="包版本"
          description="请检查问题是否存在于最新版本中。"
          name="version"
          required
          decorator={[FormItem]}
          component={[Select, { showSearch: true }]}
        />
        <Field
          title="重现链接"
          name="reproduceLink"
          decorator={[FormItem]}
          component={[Input]}
          required
          validator={[
            'url',
            (value) => {
              return /\/\/(codesandbox\.io|github)/.test(value)
                ? ''
                : '必须是 Codesandbox 链接或者 Github 仓库地址'
            },
          ]}
          description={
            <div>
              This is Codesandbox templates.If you are:
              <ul>
                <li>
                  React + Antd User:
                  <ul>
                    <li>
                      <a
                        href="https://codesandbox.io/s/formily-react-antd-pure-jsx-omncis"
                        target="_blank"
                        rel="noreferrer"
                      >
                        Pure JSX
                      </a>
                    </li>
                    <li>
                      <a
                        href="https://codesandbox.io/s/formily-react-antd-markup-schema-fvpevx"
                        target="_blank"
                        rel="noreferrer"
                      >
                        Markup Schema
                      </a>
                    </li>
                    <li>
                      <a
                        href="https://codesandbox.io/s/formily-react-antd-json-schema-28p0fh"
                        target="_blank"
                        rel="noreferrer"
                      >
                        JSON Schema
                      </a>
                    </li>
                  </ul>
                </li>
                <li>
                  React + Fusion User:
                  <ul>
                    <li>
                      <a
                        href="https://codesandbox.io/s/formily-react-next-pure-jsx-ji9iiu"
                        target="_blank"
                        rel="noreferrer"
                      >
                        Pure JSX
                      </a>
                    </li>
                    <li>
                      <a
                        href="https://codesandbox.io/s/formily-react-next-markup-schema-i7dm17"
                        target="_blank"
                        rel="noreferrer"
                      >
                        Markup Schema
                      </a>
                    </li>
                    <li>
                      <a
                        href="hhttps://codesandbox.io/s/formily-react-next-json-schema-1lm35h"
                        target="_blank"
                        rel="noreferrer"
                      >
                        JSON Schema
                      </a>
                    </li>
                  </ul>
                </li>
                <li>
                  Vue3 + ant-design-vue User:
                  <ul>
                    <li>
                      <a
                        href="https://codesandbox.io/s/formily-antd-vue-pure-jsx-pp3gvv"
                        target="_blank"
                        rel="noreferrer"
                      >
                        Pure JSX
                      </a>
                    </li>
                    <li>
                      <a
                        href="https://codesandbox.io/s/formily-vue-ant-design-vue-markup-schema-donivp"
                        target="_blank"
                        rel="noreferrer"
                      >
                        Markup Schema
                      </a>
                    </li>
                    <li>
                      <a
                        href="https://codesandbox.io/s/formily-vue-ant-design-vue-json-schema-25g4z1"
                        target="_blank"
                        rel="noreferrer"
                      >
                        JSON Schema
                      </a>
                    </li>
                  </ul>
                </li>
              </ul>
            </div>
          }
        />
        <Field
          title="重现步骤"
          description="简洁清晰的重现步骤能够帮助我们更迅速地定位问题所在。"
          name="reproduceStep"
          decorator={[FormItem]}
          component={[MdInput]}
          required
        />
        <Field
          title="期望的结果是什么？"
          name="expected"
          decorator={[FormItem]}
          component={[MdInput]}
          required
        />
        <Field
          title="实际的结果是什么？"
          name="actually"
          decorator={[FormItem]}
          component={[MdInput]}
          required
        />
        <Field
          title="补充说明（可选）"
          name="comment"
          decorator={[FormItem]}
          component={[MdInput]}
        />
      </VoidField>
      <VoidField name="feature-desc">
        <Field
          title="这个功能解决了什么问题？"
          description={
            <div>
              <p>
                请尽可能详尽地说明这个需求的用例和场景。最重要的是：解释清楚是怎样的用户体验需求催生了这个功能上的需求。
              </p>
              <p>
                Formily 的一个重要设计原则是保持 API
                的简洁和直接。通常来说，我们只考虑添加在现有的 API
                下无法轻松实现的功能。新功能的用例也应当足够常见。
              </p>
            </div>
          }
          name="feature"
          required
          decorator={[FormItem]}
          component={[MdInput]}
        />

        <Field
          title="你期望的 API 是怎样的？"
          description="描述一下你期望这个新功能的 API 是如何使用的，并提供一些代码示例"
          name="api"
          required
          decorator={[FormItem]}
          component={[MdInput]}
        />
      </VoidField>
      <FormButtonGroup.Sticky align="center">
        <Submit
          size="large"
          onSubmit={(values) => {
            window.open(createIssueURL(values))
          }}
        >
          提交
        </Submit>
      </FormButtonGroup.Sticky>
    </Form>
  )
}
```
</file>

<file path="docs/guide/learn-formily.zh-CN.md">
# 如何学习 Formily

## 学习建议

Formily 用一句话来描述，它就是一个抽象了表单领域模型的 MVVM 表单解决方案，所以，如果你想深入使用 Formily，那必须学习并了解 Formily 的领域模型到底是咋样的，它到底解决了哪些问题，了解完领域模型之后，其实就是如何消费这个领域模型的视图层了，这一层就只需要看具体组件的文档即可了。

## 关于文档

因为 Formily 的学习成本还是比较高的，想要快速了解 Formily 的全貌，最重要的还是看文档，只是文档怎么看，从哪里看会比较重要，下面我们针对不同用户给出了不同的文档学习路线。

### 入门级用户

- 引言介绍，因为你要了解 Formily 的核心思路，是否适合你的业务场景。
- 快速开始，从最简单的例子学习实际 Formily 使用都是怎么使用的。
- 组件文档/核心库文档，因为 Formily 为你已经封装好了大多数开箱即用的组件，遇到组件相关的问题，就像查字典一样的去查看组件文档即可。
- 场景案例，从具体的场景出发，看看什么才是这个场景下的最佳实践。

### 进阶级用户

- 仔细消化核心概念，更深入的理解 Formily
- 进阶指南，主要学习更高级的使用方式，比如自定义组件，从简单自定义组件到超复杂自定义组件
- 随时查阅组件文档/核心库文档，加深记忆
- 对于自定义组件开发上的细节问题，最佳实践，推荐直接看@formily/antd 或者@formily/next 的源码，因为这就是样板代码，跟实际业务场景息息相关。

### 源码共建者

- 贡献指南，了解最基本的贡献姿势
- 阅读文档，如果发现文档有缺陷，可以提 PR 修复
- 阅读单元测试，了解每个测试用例所对应的实现细节，如果发现有遗漏测试用例，可以提 PR
- 阅读源码，如果发现源码有 Bug，可以提 PR

<Alert type="error">
注意修改源码，必须要带上单元测试
</Alert>

## 关于提问

如果在开发的过程中遇到问题，推荐使用文档上方的搜索功能快速搜索文档内容，快速解决，如果搜索不到的，推荐到 [论坛](https://github.com/alibaba/formily/discussions) 中提问，这里方便记录，如果遇到非常紧急的问题，可以在钉钉群里 @白玄 帮忙解决。**非常不推荐文档都不看，就直接问各种基础问题，这样很低效**

## 关于 Bug

如果在开发过程中发现不符合预期的行为，并能够以最小案例复现的，可以给 Formily 提[Issue](https://github.com/alibaba/formily/issues) ，非常不推荐将问题记录在 issue 里，会打乱 Issue 的信息流，同时一定注意，**提 Issue 的时候要带上最小可复现的链接地址**，方便开发者快速定位问题，快速修复，而不是在一堆代码里找 Bug。

## 关于 Feature Request

如果在开发过程中发现 Formily 的某些设计很不好，或者可以改进的更好的，则可以在 [论坛](https://github.com/alibaba/formily/discussions) 中提交自己的想法。
</file>

<file path="docs/guide/quick-start.zh-CN.md">
# 快速开始

## 安装依赖

### 安装内核库

使用 Formily 必须要用到[@formily/core](https://core.formilyjs.org/zh-CN)，它负责管理表单的状态，表单校验，联动等等。

```bash
$ npm install --save @formily/core
```

### 安装 UI 桥接库

单纯有了内核还不够，我们还需要一个 UI 库来接入内核数据，用来实现最终的表单交互效果，对于不同框架的用户，我们有不同的桥接库。

**React 用户**

```bash
$ npm install --save @formily/react
```

**Vue 用户**

```bash
$ npm install --save @formily/vue
```

### 安装组件库

想要快速实现漂亮的表单，通常我们都是需要使用业界优秀的组件库的，比如[Ant Design ](https://ant.design)和 [Alibaba Fusion](https://fusion.design)，但是这些优秀的组件库，在表单的某些场景上覆盖的还是不够全面，比如详情预览态的支持，Ant Design 是不支持的，还有一些场景化的组件它也是不支持的，所以 Formily 在此之上又封装了@formily/antd 和@formily/next，保证用户开箱即用。

**Ant Design 用户**

```bash
$ npm install --save antd moment @formily/antd
```

**Alibaba Fusion 用户**

```bash
$ npm install --save @alifd/next moment @formily/next
```

## 导入依赖

使用 ES Module import 语法导入依赖即可

```ts
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'
import { FormItem, Input } from '@formily/antd'
```

## 具体用例

```tsx
/**
 * defaultShowCode: true
 */
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, FormConsumer, Field } from '@formily/react'
import {
  FormItem,
  FormLayout,
  Input,
  FormButtonGroup,
  Submit,
} from '@formily/antd'

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <FormLayout layout="vertical">
        <Field
          name="input"
          title="输入框"
          required
          initialValue="Hello world"
          decorator={[FormItem]}
          component={[Input]}
        />
      </FormLayout>
      <FormConsumer>
        {() => (
          <div
            style={{
              marginBottom: 20,
              padding: 5,
              border: '1px dashed #666',
            }}
          >
            实时响应：{form.values.input}
          </div>
        )}
      </FormConsumer>
      <FormButtonGroup>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

从以上例子中，我们可以学到很多东西：

- [createForm](https://core.formilyjs.org/zh-CN/api/entry/create-form)用来创建表单核心领域模型，它是作为[MVVM](https://core.formilyjs.org/guide/mvvm)设计模式的标准 ViewModel
- [FormProvider](https://react.formilyjs.org/zh-CN/api/components/form-provider)组件是作为视图层桥接表单模型的入口，它只有一个参数，就是接收 createForm 创建出来的 Form 实例，并将 Form 实例以上下文形式传递到子组件中
- [FormLayout](https://antd.formilyjs.org/zh-CN/components/form-layout)组件是用来批量控制[FormItem](https://antd.formilyjs.org/zh-CN/components/form-item)样式的组件，这里我们指定布局为上下布局，也就是标签在上，组件在下
- [Field](https://react.formilyjs.org/zh-CN/api/components/field)组件是用来承接普通字段的组件
  - name 属性，标识字段在表单最终提交数据中的路径
  - title 属性，标识字段的标题
    - 如果 decorator 指定为 FormItem，那么在 FormItem 组件中会默认以接收 title 属性作为标签
    - 如果指定为某个自定义组件，那么 title 的消费方则由自定义组件来承接
    - 如果不指定 decorator，那么 title 则不会显示在 UI 上
  - required 属性，必填校验的极简写法，标识该字段必填
    - 如果 decorator 指定为 FormItem，那么会自动出现星号提示，同时校验失败也会有对应的状态反馈，这些都是 FormItem 内部做的默认处理
    - 如果 decorator 指定为自定义组件，那么对应的 UI 样式则需要自定义组件实现方自己实现
    - 如果不指定 decorator，那么 required 只是会阻塞提交，校验失败不会有任何 UI 反馈。
  - initialValue 属性，代表字段的默认值
  - decorator 属性，代表字段的 UI 装饰器，通常我们都会指定为 FormItem
    - 注意 decorator 属性传递的是数组形式，第一个参数代表指定组件类型，第二个参数代表指定组件属性
  - component 属性，代表字段的输入控件，可以是 Input，也可以是 Select，等等
    - 注意 component 属性传递的是数组形式，第一个参数代表指定组件类型，第二个参数代表指定组件属性
- [FormConsumer](https://react.formilyjs.org/zh-CN/api/components/form-consumer)组件是作为响应式模型的响应器而存在，它核心是一个 render props 模式，在作为 children 的回调函数中，会自动收集所有依赖，如果依赖发生变化，则会重新渲染，借助 FormConsumer 我们可以很方便的实现各种计算汇总的需求
- [FormButtonGroup](https://antd.formilyjs.org/zh-CN/components/form-button-group)组件作为表单按钮组容器而存在，主要负责按钮的布局
- [Submit](https://antd.formilyjs.org/zh-CN/components/submit)组件作为表单提交的动作触发器而存在，其实我们也可以直接使用 form.submit 方法进行提交，但是使用 Submit 的好处是不需要每次都在 Button 组件上写 onClick 事件处理器，同时它还处理了 Form 的 loading 状态，如果 onSubmit 方法返回一个 Promise，且 Promise 正在 pending 状态，那么按钮会自动进入 loading 状态
</file>

<file path="docs/guide/upgrade.zh-CN.md">
# V2 升级指南

这里着重提一下，Formily2 相比于 Formily1.x，差别非常大，存在大量 Break Change。

所以对老用户而言，基本上是需要重新学习的，V1 和 V2 是无法做到平滑升级的。

但是 Formily2 的项目初衷就是为了降低大家的学习成本，因为老用户本身已经对 Formily 的核心思想有过一定的了解，为了帮助老用户更快速的学习 Formily2，本文会列举出 V1 和 V2 的核心差异点，并不会列举新增的能力。

## 内核差异

> 这里主要指@formily/core 的差异

因为 Formily1.x 用户在使用内核 API 的时候，主要是使用 setFieldState/setFormState 与 getFieldState/getFormState，在 V2 中保留了这些 API，但是内部的模型属性是有语义上的差别的，差别如下：

**modified**

- V1: 代表字段是否已改动，其实并没有任何用处，因为字段初始化就代表已改动
- V2: 代表字段是否被手动修改，也就是组件触发 onChange 事件的时候才会设置为 true

**inputed**

- V1: 代表字段是否被手动修改
- V2: 移除，统一使用 modified

**pristine**

- V1: 代表字段 value 是否等于 initialValue
- V2: 移除，用户手动判断，该属性会导致大量脏检查

**display**

- V1: 代表字段是否显示，如果为 false，不会移除字段值
- V2: 代表字段展示模式，值为`"none" | "visible" | "hidden"`

**touched**

- V1: 冗余字段
- V2: 移除

**validating**

- V1: 代表字段是否正在校验
- V2: 移除，统一使用 validateStatus

**effectErrors/effectWarnings**

- V1: 代表用户手动操作的 errors 和 warnings
- V2: 移除，统一使用 feedbacks

**ruleErrors/ruleWarnings**

- V1: 代表校验器校验操作的 errors 与 warnings
- V2: 移除，统一使用 feedbacks

**values**

- V1: 代表 onChange 事件返回的所有参数
- V2: 移除，统一使用 inputValues

**rules**

- V1:代表校验规则
- V2:移除，统一使用 validator，因为 rules 的字面意思是规则，但是规则的含义很大，不局限于校验规则

**props**

- V1:代表组件的扩展属性，定位很不清晰，在纯 JSX 场景是代表组件属性与 FormItem 属性的集合，在 Schema 场景又是代表 Schema 字段的属性
- V2: 移除，统一使用 decorator 和 component

**VirtualField**

- V1: 代表虚拟字段
- V2: 改名，统一使用[VoidField](https://core.formilyjs.org/zh-CN/api/models/void-field)

**unmount 行为**

- V1: 字段 unmount，字段值默认会被删除
- V2: 移除，这个默认行为太隐晦，如果要删值，可以直接修改 value，同时自动删值的行为只有字段 display 为 none 时才会自动删值

## 桥接层差异

> 这里主要指@formily/react 和@formily/react-schema-renderer 的差异

**createFormActions/createAsyncFormActions**

- V1 创建一个 Form 操作器，可以调用 setFieldState/setFormState 方法
- V2 移除，统一使用@formily/core 中的[createForm](https://core.formilyjs.org/zh-CN/api/entry/create-form)创建出来的 Form 实例操作状态

**Form**

- V1 内部会创建 Form 实例，可以受控传递 values/initialValues 属性等
- V2 移除，统一使用[FormProvider](https://react.formilyjs.org/zh-CN/api/components/form-provider)

**SchemaForm**

- V1 内部会解析 json-schema 协议，同时会创建 Form 实例，支持受控模式，并渲染
- V2 移除，统一使用[createSchemaField](https://react.formilyjs.org/zh-CN/api/components/schema-field)创建出来的 SchemaField 组件，且不支持受控模式

**Field**

- V1 支持受控模式，需要使用 render props 进行组件状态映射
- V2 不支持受控模式，传入 decorator/component 属性即可快速实现状态映射

**VirtualField**

- V1 支持受控模式，需要使用 render props 进行组件状态映射
- V2 不支持受控模式，改名[VoidField](https://react.formilyjs.org/zh-CN/api/components/void-field)，传入 decorator/component 属性即可快速实现状态映射

**FieldList**

- V1 代表自增字段控制组件
- V2 改名为[ArrayField](https://react.formilyjs.org/zh-CN/api/components/array-field)

**FormSpy**

- V1 监听所有生命周期触发，并重新渲染
- V2 移除，统一使用[FormConsumer](https://react.formilyjs.org/zh-CN/api/components/form-consumer)

**SchemaMarkupField**

- V1 代表 Schema 描述标签组件
- V2 移除，统一使用[createSchemaField](https://react.formilyjs.org/zh-CN/api/components/schema-field)工厂函数创建出来的描述标签组件

**useFormQuery**

- V1 用于实现表单查询的快捷 Hook，支持中间件机制
- V2 暂时移除

**useForm**

- V1 代表创建 Form 实例
- V2 代表消费上下文中的 Form 实例，如果要创建，请使用[createForm](https://core.formilyjs.org/zh-CN/api/entry/create-form)

**useField**

- V1 代表创建 Field 实例
- V2 代表消费上下文中的 Field 实例，如果要创建，请调用[form.createField](https://core.formilyjs.org/zh-CN/api/models/form#createfield)

**useVirtualField**

- V1 代表创建 VirtualField 实例
- V2 移除，如果要创建，请调用[form.createVoidField](https://core.formilyjs.org/zh-CN/api/models/form#createvoidfield)

**useFormState**

- V1 消费上下文中的 Form 状态
- V2 移除，统一使用[useForm](https://react.formilyjs.org/zh-CN/api/hooks/use-form)

**useFieldState**

- V1 消费上下文中的 Field 状态
- V2 移除，统一使用[useField](https://react.formilyjs.org/zh-CN/api/hooks/use-field)

**useFormSpy**

- V1 创建生命周期监听器，并触发重新渲染
- V2 移除

**useSchemaProps**

- V1 消费上下文中的 SchemaField 的 Props
- V2 移除，统一使用[useFieldSchema](https://react.formilyjs.org/zh-CN/api/hooks/use-field-schema)

**connect**

- V1 标准 HOC
- V2 高阶函数改为 1 阶，属性有巨大变化，具体看[connect 文档](https://react.formilyjs.org/zh-CN/api/shared/connect)

**registerFormField/registerVirtaulBox/registerFormComponent/registerFormItemComponent**

- V1 全局注册组件
- V2 移除，不再支持全局注册

**FormEffectHooks**

- V1 RxJS 生命周期钩子
- V2 移除，统一从@formily/core 中导出，且不会返回 RxJS Observable 对象

**effects**

- V1 支持回调函数`$`选择器
- V2 移除`$`选择器

## 协议层差异

> 这里主要指 JSON Schema 协议上的差异

**editable**

- V1 直接在 Schema 描述中，代表字段是否可编辑
- V2 改名 x-editable

**visible**

- V1 代表字段是否显示
- V2 改名 x-visible

**display**

- V1 代表字段是否显示，如果为 false，代表不删值的隐藏行为
- V2 改名 x-display，代表字段展示模式，值为`"none" | "visible" | "hidden"`

**triggerType**

- V1 代表字段校验时机
- V2 移除，请使用`x-validator:[{triggerType:"onBlur",validator:()=>...}]`

**x-props**

- V1 代表 FormItem 属性
- V2 移除，请使用 x-decorator-props

**x-rules**

- V1 代表字段校验规则
- V2 改名 x-validator

**x-linkages**

- V1 代表字段联动
- V2 移除，统一使用 x-reactions

**x-mega-props**

- V1 代表 MegaLayout 组件的子组件属性
- V2 移除

## 组件库差异

在 Formily1.x 中，我们主要使用@formily/antd 和@formily/antd-components，或者@formily/next 和@formily/next-components，

在 V2 中，我们有以下几个改变：

- @formily/antd 与@formily/antd-components 合并成@formily/antd，同时目录结构全部改成纯组件库的目录结构了。

- 不会再导出@formily/react @formily/core 的内部 API
- 所有组件几乎都做了重写，无法平滑升级
- 移除 styled-components
</file>

<file path="docs/index.zh-CN.md">
---
title: Formily - 阿里巴巴统一前端表单解决方案
order: 10
hero:
  title: Alibaba Formily
  desc: 阿里巴巴统一前端表单解决方案
  actions:
    - text: 查看文档
      link: /zh-CN/guide
    - text: 快速开始
      link: /zh-CN/guide/quick-start
features:
  - icon: https://img.alicdn.com/imgextra/i2/O1CN016i72sH1c5wh1kyy9U_!!6000000003550-55-tps-800-800.svg
    title: 更易用
    desc: 开箱即用，案例丰富
  - icon: https://img.alicdn.com/imgextra/i1/O1CN01bHdrZJ1rEOESvXEi5_!!6000000005599-55-tps-800-800.svg
    title: 更高效
    desc: 傻瓜写法，超高性能
  - icon: https://img.alicdn.com/imgextra/i3/O1CN01xlETZk1G0WSQT6Xii_!!6000000000560-55-tps-800-800.svg
    title: 更专业
    desc: 完备，灵活，优雅
footer: Open-source MIT Licensed | Copyright © 2019-present<br />Powered by self
---

```tsx
/**
 * inline: true
 */
import React from 'react'
import { Section } from './site/Section'
import './site/styles.less'

export default () => (
  <Section
    title="傻瓜写法，超高性能"
    style={{ marginTop: 40 }}
    titleStyle={{ paddingBottom: 100 }}
  >
    <iframe
      className="codesandbox"
      src="https://codesandbox.io/embed/formilyyaliceshi-vbu4w?fontsize=12&module=%2FApp.tsx&theme=dark"
      allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
      sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
    ></iframe>
  </Section>
)
```

```tsx
/**
 * inline: true
 */
import React from 'react'
import { Section } from './site/Section'
import './site/styles.less'

export default () => (
  <Section
    title="拖拽搭建，高效开发"
    style={{ marginTop: 140 }}
    titleStyle={{ paddingBottom: 140 }}
    scale={1.2}
  >
    <a href="//designable-antd.formilyjs.org" target="_blank" rel="noreferrer">
      <img src="//img.alicdn.com/imgextra/i2/O1CN01eI9FLz22tZek2jv7E_!!6000000007178-2-tps-3683-2272.png" />
    </a>
  </Section>
)
```

```tsx
/**
 * inline: true
 */
import React from 'react'
import { Section } from './site/Section'
import './site/styles.less'

export default () => (
  <Section
    title="纯净内核，更易扩展"
    style={{ marginTop: 140 }}
    titleStyle={{ paddingBottom: 100 }}
  >
    <a href="//core.formilyjs.org" target="_blank" rel="noreferrer">
      <img src="//img.alicdn.com/imgextra/i3/O1CN01iEwHrP1NUw84xTded_!!6000000001574-55-tps-1939-1199.svg" />
    </a>
  </Section>
)
```

```tsx
/**
 * inline: true
 */
import React from 'react'
import { Section } from './site/Section'
import { Contributors } from './site/Contributors'
import './site/styles.less'

export default () => (
  <Section
    title="社区活跃，能者众多"
    style={{ marginTop: 100 }}
    titleStyle={{ paddingBottom: 140 }}
  >
    <Contributors />
  </Section>
)
```

```tsx
/**
 * inline: true
 */
import React from 'react'
import { Section } from './site/Section'
import { QrCode, QrCodeGroup } from './site/QrCode'
import './site/styles.less'

export default () => (
  <Section
    title="全球互助共建答疑大群"
    style={{ marginTop: 140 }}
    titleStyle={{ paddingBottom: 20, fontWeight: 'bold' }}
  >
    <QrCodeGroup>
      <QrCode link="//img.alicdn.com/imgextra/i1/O1CN011zlc5b1uu1BDUpNg1_!!6000000006096-2-tps-978-1380.png" />
    </QrCodeGroup>
  </Section>
)
```
</file>

<file path="packages/antd/docs/components/ArrayCards.md">
# ArrayCards

> Card list, it is more suitable to use ArrayCards for scenarios with a large number of fields in each row and more linkages
>
> Note: This component is only applicable to Schema scenarios

## Markup Schema example

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayCards,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    ArrayCards,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Array
          name="string_array"
          maxItems={3}
          x-decorator="FormItem"
          x-component="ArrayCards"
          x-component-props={{
            title: 'String array',
          }}
        >
          <SchemaField.Void>
            <SchemaField.Void x-component="ArrayCards.Index" />
            <SchemaField.String
              name="input"
              x-decorator="FormItem"
              title="Input"
              required
              x-component="Input"
            />
            <SchemaField.Void x-component="ArrayCards.Remove" />
            <SchemaField.Void x-component="ArrayCards.Copy" />
            <SchemaField.Void x-component="ArrayCards.MoveUp" />
            <SchemaField.Void x-component="ArrayCards.MoveDown" />
          </SchemaField.Void>
          <SchemaField.Void
            x-component="ArrayCards.Addition"
            title="Add entry"
          />
        </SchemaField.Array>
        <SchemaField.Array
          name="array"
          maxItems={3}
          x-decorator="FormItem"
          x-component="ArrayCards"
          x-component-props={{
            title: 'Object array',
          }}
        >
          <SchemaField.Object>
            <SchemaField.Void x-component="ArrayCards.Index" />
            <SchemaField.String
              name="input"
              x-decorator="FormItem"
              title="Input"
              required
              x-component="Input"
            />
            <SchemaField.Void x-component="ArrayCards.Remove" />
            <SchemaField.Void x-component="ArrayCards.MoveUp" />
            <SchemaField.Void x-component="ArrayCards.MoveDown" />
          </SchemaField.Object>
          <SchemaField.Void
            x-component="ArrayCards.Addition"
            title="Add entry"
          />
        </SchemaField.Array>
      </SchemaField>
      <FormButtonGroup>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## JSON Schema case

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayCards,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    ArrayCards,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    string_array: {
      type: 'array',
      'x-component': 'ArrayCards',
      maxItems: 3,
      'x-decorator': 'FormItem',
      'x-component-props': {
        title: 'String array',
      },
      items: {
        type: 'void',
        properties: {
          index: {
            type: 'void',
            'x-component': 'ArrayCards.Index',
          },
          input: {
            type: 'string',
            'x-decorator': 'FormItem',
            title: 'Input',
            required: true,
            'x-component': 'Input',
          },
          remove: {
            type: 'void',
            'x-component': 'ArrayCards.Remove',
          },
          moveUp: {
            type: 'void',
            'x-component': 'ArrayCards.MoveUp',
          },
          moveDown: {
            type: 'void',
            'x-component': 'ArrayCards.MoveDown',
          },
        },
      },
      properties: {
        addition: {
          type: 'void',
          title: 'Add entry',
          'x-component': 'ArrayCards.Addition',
        },
      },
    },
    array: {
      type: 'array',
      'x-component': 'ArrayCards',
      maxItems: 3,
      'x-decorator': 'FormItem',
      'x-component-props': {
        title: 'Object array',
      },
      items: {
        type: 'object',
        properties: {
          index: {
            type: 'void',
            'x-component': 'ArrayCards.Index',
          },
          input: {
            type: 'string',
            'x-decorator': 'FormItem',
            title: 'Input',
            required: true,
            'x-component': 'Input',
          },
          remove: {
            type: 'void',
            'x-component': 'ArrayCards.Remove',
          },
          moveUp: {
            type: 'void',
            'x-component': 'ArrayCards.MoveUp',
          },
          moveDown: {
            type: 'void',
            'x-component': 'ArrayCards.MoveDown',
          },
        },
      },
      properties: {
        addition: {
          type: 'void',
          title: 'Add entry',
          'x-component': 'ArrayCards.Addition',
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} />
      <FormButtonGroup>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## Effects linkage case

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayCards,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm, onFieldChange, onFieldReact } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    ArrayCards,
  },
})

const form = createForm({
  effects: () => {
    //Active linkage mode
    onFieldChange('array.*.aa', ['value'], (field, form) => {
      form.setFieldState(field.query('.bb'), (state) => {
        state.visible = field.value != '123'
      })
    })
    //Passive linkage mode
    onFieldReact('array.*.dd', (field) => {
      field.visible = field.query('.cc').get('value') != '123'
    })
  },
})

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Array
          name="array"
          maxItems={3}
          x-component="ArrayCards"
          x-decorator="FormItem"
          x-component-props={{
            title: 'Object array',
          }}
        >
          <SchemaField.Object>
            <SchemaField.Void x-component="ArrayCards.Index" />
            <SchemaField.String
              name="aa"
              x-decorator="FormItem"
              title="AA"
              required
              description="AA hide BB when entering 123"
              x-component="Input"
            />
            <SchemaField.String
              name="bb"
              x-decorator="FormItem"
              title="BB"
              required
              x-component="Input"
            />
            <SchemaField.String
              name="cc"
              x-decorator="FormItem"
              title="CC"
              required
              description="Hide DD when CC enters 123"
              x-component="Input"
            />
            <SchemaField.String
              name="dd"
              x-decorator="FormItem"
              title="DD"
              required
              x-component="Input"
            />
            <SchemaField.Void x-component="ArrayCards.Remove" />
            <SchemaField.Void x-component="ArrayCards.MoveUp" />
            <SchemaField.Void x-component="ArrayCards.MoveDown" />
          </SchemaField.Object>
          <SchemaField.Void
            x-component="ArrayCards.Addition"
            title="Add entry"
          />
        </SchemaField.Array>
      </SchemaField>
      <FormButtonGroup>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## JSON Schema linkage case

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayCards,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    ArrayCards,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    array: {
      type: 'array',
      'x-component': 'ArrayCards',
      maxItems: 3,
      title: 'Object array',
      items: {
        type: 'object',
        properties: {
          index: {
            type: 'void',
            'x-component': 'ArrayCards.Index',
          },
          aa: {
            type: 'string',
            'x-decorator': 'FormItem',
            title: 'AA',
            required: true,
            'x-component': 'Input',
            description: 'Enter 123',
          },
          bb: {
            type: 'string',
            title: 'BB',
            required: true,
            'x-decorator': 'FormItem',
            'x-component': 'Input',
            'x-reactions': [
              {
                dependencies: ['.aa'],
                when: "{{$deps[0] != '123'}}",
                fulfill: {
                  schema: {
                    title: 'BB',
                    'x-disabled': true,
                  },
                },
                otherwise: {
                  schema: {
                    title: 'Changed',
                    'x-disabled': false,
                  },
                },
              },
            ],
          },
          remove: {
            type: 'void',
            'x-component': 'ArrayCards.Remove',
          },
          moveUp: {
            type: 'void',
            'x-component': 'ArrayCards.MoveUp',
          },
          moveDown: {
            type: 'void',
            'x-component': 'ArrayCards.MoveDown',
          },
        },
      },
      properties: {
        addition: {
          type: 'void',
          title: 'Add entry',
          'x-component': 'ArrayCards.Addition',
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} />
      <FormButtonGroup>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## API

### ArrayCards

Extended attributes

| Property name | Type                      | Description     | Default value |
| ------------- | ------------------------- | --------------- | ------------- |
| onAdd         | `(index: number) => void` | add method      |               |
| onRemove      | `(index: number) => void` | remove method   |               |
| onCopy        | `(index: number) => void` | copy method     |               |
| onMoveUp      | `(index: number) => void` | moveUp method   |               |
| onMoveDown    | `(index: number) => void` | moveDown method |               |

Other Reference https://ant.design/components/card-cn/

### ArrayCards.Addition

> Add button

Extended attributes

| Property name | Type                 | Description   | Default value |
| ------------- | -------------------- | ------------- | ------------- |
| title         | ReactText            | Copywriting   |               |
| method        | `'push' \|'unshift'` | add method    | `'push'`      |
| defaultValue  | `any`                | Default value |               |

Other references https://ant.design/components/button-cn/

Note: The title attribute can receive the title mapping in the Field model, that is, uploading the title in the Field is also effective

Note: You can disable default behavior with `onClick={e => e.preventDefault()}` in props.

### ArrayCards.Copy

> Copy button

Extended attributes

| Property name | Type                 | Description | Default value |
| ------------- | -------------------- | ----------- | ------------- |
| title         | ReactText            | Copywriting |               |
| method        | `'push' \|'unshift'` | Copy method | `'push'`      |

Other references https://ant.design/components/button-cn/

Note: The title attribute can receive the title mapping in the Field model, that is, uploading the title in the Field is also effective

Note: You can disable default behavior with `onClick={e => e.preventDefault()}` in props.

### ArrayCards.Remove

> Delete button

| Property name | Type      | Description | Default value |
| ------------- | --------- | ----------- | ------------- |
| title         | ReactText | Copywriting |               |

Other references https://ant.design/components/icon-cn/

Note: The title attribute can receive the title mapping in the Field model, that is, uploading the title in the Field is also effective

Note: You can disable default behavior with `onClick={e => e.preventDefault()}` in props.

### ArrayCards.MoveDown

> Move down button

| Property name | Type      | Description | Default value |
| ------------- | --------- | ----------- | ------------- |
| title         | ReactText | Copywriting |               |

Other references https://ant.design/components/icon-cn/

Note: The title attribute can receive the title mapping in the Field model, that is, uploading the title in the Field is also effective

Note: You can disable default behavior with `onClick={e => e.preventDefault()}` in props.

### ArrayCards.MoveUp

> Move up button

| Property name | Type      | Description | Default value |
| ------------- | --------- | ----------- | ------------- |
| title         | ReactText | Copywriting |               |

Other references https://ant.design/components/icon-cn/

Note: The title attribute can receive the title mapping in the Field model, that is, uploading the title in the Field is also effective

Note: You can disable default behavior with `onClick={e => e.preventDefault()}` in props.

### ArrayCards.Index

> Index Renderer

No attributes

### ArrayCards.useIndex

> Read the React Hook of the current rendering row index

### ArrayCards.useRecord

> Read the React Hook of the current rendering row
</file>

<file path="packages/antd/docs/components/ArrayCards.zh-CN.md">
# ArrayCards

> 卡片列表，对于每行字段数量较多，联动较多的场景比较适合使用 ArrayCards
>
> 注意：该组件只适用于 Schema 场景

## Markup Schema 案例

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayCards,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    ArrayCards,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Array
          name="string_array"
          maxItems={3}
          x-decorator="FormItem"
          x-component="ArrayCards"
          x-component-props={{
            title: '字符串数组',
          }}
        >
          <SchemaField.Void>
            <SchemaField.Void x-component="ArrayCards.Index" />
            <SchemaField.String
              name="input"
              x-decorator="FormItem"
              title="Input"
              required
              x-component="Input"
            />
            <SchemaField.Void x-component="ArrayCards.Remove" />
            <SchemaField.Void x-component="ArrayCards.Copy" />
            <SchemaField.Void x-component="ArrayCards.MoveUp" />
            <SchemaField.Void x-component="ArrayCards.MoveDown" />
          </SchemaField.Void>
          <SchemaField.Void
            x-component="ArrayCards.Addition"
            title="添加条目"
          />
        </SchemaField.Array>
        <SchemaField.Array
          name="array"
          maxItems={3}
          x-decorator="FormItem"
          x-component="ArrayCards"
          x-component-props={{
            title: '对象数组',
          }}
        >
          <SchemaField.Object>
            <SchemaField.Void x-component="ArrayCards.Index" />
            <SchemaField.String
              name="input"
              x-decorator="FormItem"
              title="Input"
              required
              x-component="Input"
            />
            <SchemaField.Void x-component="ArrayCards.Remove" />
            <SchemaField.Void x-component="ArrayCards.MoveUp" />
            <SchemaField.Void x-component="ArrayCards.MoveDown" />
          </SchemaField.Object>
          <SchemaField.Void
            x-component="ArrayCards.Addition"
            title="添加条目"
          />
        </SchemaField.Array>
      </SchemaField>
      <FormButtonGroup>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## JSON Schema 案例

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayCards,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    ArrayCards,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    string_array: {
      type: 'array',
      'x-component': 'ArrayCards',
      maxItems: 3,
      'x-decorator': 'FormItem',
      'x-component-props': {
        title: '字符串数组',
      },
      items: {
        type: 'void',
        properties: {
          index: {
            type: 'void',
            'x-component': 'ArrayCards.Index',
          },
          input: {
            type: 'string',
            'x-decorator': 'FormItem',
            title: 'Input',
            required: true,
            'x-component': 'Input',
          },
          remove: {
            type: 'void',
            'x-component': 'ArrayCards.Remove',
          },
          moveUp: {
            type: 'void',
            'x-component': 'ArrayCards.MoveUp',
          },
          moveDown: {
            type: 'void',
            'x-component': 'ArrayCards.MoveDown',
          },
        },
      },
      properties: {
        addition: {
          type: 'void',
          title: '添加条目',
          'x-component': 'ArrayCards.Addition',
        },
      },
    },
    array: {
      type: 'array',
      'x-component': 'ArrayCards',
      maxItems: 3,
      'x-decorator': 'FormItem',
      'x-component-props': {
        title: '对象数组',
      },
      items: {
        type: 'object',
        properties: {
          index: {
            type: 'void',
            'x-component': 'ArrayCards.Index',
          },
          input: {
            type: 'string',
            'x-decorator': 'FormItem',
            title: 'Input',
            required: true,
            'x-component': 'Input',
          },
          remove: {
            type: 'void',
            'x-component': 'ArrayCards.Remove',
          },
          moveUp: {
            type: 'void',
            'x-component': 'ArrayCards.MoveUp',
          },
          moveDown: {
            type: 'void',
            'x-component': 'ArrayCards.MoveDown',
          },
        },
      },
      properties: {
        addition: {
          type: 'void',
          title: '添加条目',
          'x-component': 'ArrayCards.Addition',
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} />
      <FormButtonGroup>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## Effects 联动案例

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayCards,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm, onFieldChange, onFieldReact } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    ArrayCards,
  },
})

const form = createForm({
  effects: () => {
    //主动联动模式
    onFieldChange('array.*.aa', ['value'], (field, form) => {
      form.setFieldState(field.query('.bb'), (state) => {
        state.visible = field.value != '123'
      })
    })
    //被动联动模式
    onFieldReact('array.*.dd', (field) => {
      field.visible = field.query('.cc').get('value') != '123'
    })
  },
})

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Array
          name="array"
          maxItems={3}
          x-component="ArrayCards"
          x-decorator="FormItem"
          x-component-props={{
            title: '对象数组',
          }}
        >
          <SchemaField.Object>
            <SchemaField.Void x-component="ArrayCards.Index" />
            <SchemaField.String
              name="aa"
              x-decorator="FormItem"
              title="AA"
              required
              description="AA输入123时隐藏BB"
              x-component="Input"
            />
            <SchemaField.String
              name="bb"
              x-decorator="FormItem"
              title="BB"
              required
              x-component="Input"
            />
            <SchemaField.String
              name="cc"
              x-decorator="FormItem"
              title="CC"
              required
              description="CC输入123时隐藏DD"
              x-component="Input"
            />
            <SchemaField.String
              name="dd"
              x-decorator="FormItem"
              title="DD"
              required
              x-component="Input"
            />
            <SchemaField.Void x-component="ArrayCards.Remove" />
            <SchemaField.Void x-component="ArrayCards.MoveUp" />
            <SchemaField.Void x-component="ArrayCards.MoveDown" />
          </SchemaField.Object>
          <SchemaField.Void
            x-component="ArrayCards.Addition"
            title="添加条目"
          />
        </SchemaField.Array>
      </SchemaField>
      <FormButtonGroup>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## JSON Schema 联动案例

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayCards,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    ArrayCards,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    array: {
      type: 'array',
      'x-component': 'ArrayCards',
      maxItems: 3,
      title: '对象数组',
      items: {
        type: 'object',
        properties: {
          index: {
            type: 'void',
            'x-component': 'ArrayCards.Index',
          },
          aa: {
            type: 'string',
            'x-decorator': 'FormItem',
            title: 'AA',
            required: true,
            'x-component': 'Input',
            description: '输入123',
          },
          bb: {
            type: 'string',
            title: 'BB',
            required: true,
            'x-decorator': 'FormItem',
            'x-component': 'Input',
            'x-reactions': [
              {
                dependencies: ['.aa'],
                when: "{{$deps[0] != '123'}}",
                fulfill: {
                  schema: {
                    title: 'BB',
                    'x-disabled': true,
                  },
                },
                otherwise: {
                  schema: {
                    title: 'Changed',
                    'x-disabled': false,
                  },
                },
              },
            ],
          },
          remove: {
            type: 'void',
            'x-component': 'ArrayCards.Remove',
          },
          moveUp: {
            type: 'void',
            'x-component': 'ArrayCards.MoveUp',
          },
          moveDown: {
            type: 'void',
            'x-component': 'ArrayCards.MoveDown',
          },
        },
      },
      properties: {
        addition: {
          type: 'void',
          title: '添加条目',
          'x-component': 'ArrayCards.Addition',
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} />
      <FormButtonGroup>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## API

### ArrayCards

扩展属性

| 属性名     | 类型                      | 描述         | 默认值 |
| ---------- | ------------------------- | ------------ | ------ |
| onAdd      | `(index: number) => void` | 增加方法     |        |
| onRemove   | `(index: number) => void` | 删除方法     |        |
| onCopy     | `(index: number) => void` | 复制方法     |        |
| onMoveUp   | `(index: number) => void` | 向上移动方法 |        |
| onMoveDown | `(index: number) => void` | 向下移动方法 |        |

其余参考 https://ant.design/components/card-cn/

### ArrayCards.Addition

> 添加按钮

扩展属性

| 属性名       | 类型                  | 描述     | 默认值   |
| ------------ | --------------------- | -------- | -------- |
| title        | ReactText             | 文案     |          |
| method       | `'push' \| 'unshift'` | 添加方式 | `'push'` |
| defaultValue | `any`                 | 默认值   |          |

其余参考 https://ant.design/components/button-cn/

注意：title 属性可以接收 Field 模型中的 title 映射，也就是在 Field 上传 title 也是生效的

注意：使用`onClick={e => e.preventDefault()}`可禁用默认行为。

### ArrayCards.Copy

> 复制按钮

扩展属性

| 属性名 | 类型                  | 描述     | 默认值   |
| ------ | --------------------- | -------- | -------- |
| title  | ReactText             | 文案     |          |
| method | `'push' \| 'unshift'` | 添加方式 | `'push'` |

其余参考 https://ant.design/components/button-cn/

注意：title 属性可以接收 Field 模型中的 title 映射，也就是在 Field 上传 title 也是生效的

注意：使用`onClick={e => e.preventDefault()}`可禁用默认行为。

### ArrayCards.Remove

> 删除按钮

| 属性名 | 类型      | 描述 | 默认值 |
| ------ | --------- | ---- | ------ |
| title  | ReactText | 文案 |        |

其余参考 https://ant.design/components/icon-cn/

注意：title 属性可以接收 Field 模型中的 title 映射，也就是在 Field 上传 title 也是生效的

注意：使用`onClick={e => e.preventDefault()}`可禁用默认行为。

### ArrayCards.MoveDown

> 下移按钮

| 属性名 | 类型      | 描述 | 默认值 |
| ------ | --------- | ---- | ------ |
| title  | ReactText | 文案 |        |

其余参考 https://ant.design/components/icon-cn/

注意：title 属性可以接收 Field 模型中的 title 映射，也就是在 Field 上传 title 也是生效的

注意：使用`onClick={e => e.preventDefault()}`可禁用默认行为。

### ArrayCards.MoveUp

> 上移按钮

| 属性名 | 类型      | 描述 | 默认值 |
| ------ | --------- | ---- | ------ |
| title  | ReactText | 文案 |        |

其余参考 https://ant.design/components/icon-cn/

注意：title 属性可以接收 Field 模型中的 title 映射，也就是在 Field 上传 title 也是生效的

注意：使用`onClick={e => e.preventDefault()}`可禁用默认行为。

### ArrayCards.Index

> 索引渲染器

无属性

### ArrayCards.useIndex

> 读取当前渲染行索引的 React Hook

### ArrayCards.useRecord

> 读取当前渲染记录的 React Hook
</file>

<file path="packages/antd/docs/components/ArrayCollapse.md">
# ArrayCollapse

> Folding panel, it is more suitable to use ArrayCollapse for scenes with more fields in each row and more linkage
>
> Note: This component is only applicable to Schema scenarios

## Markup Schema example

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayCollapse,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Button } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    ArrayCollapse,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Array
          name="string_array"
          maxItems={3}
          x-decorator="FormItem"
          x-component="ArrayCollapse"
          x-component-props={{
            accordion: true,
            defaultOpenPanelCount: 3,
          }}
        >
          <SchemaField.Void
            x-component="ArrayCollapse.CollapsePanel"
            x-component-props={{
              header: 'String array',
            }}
          >
            <SchemaField.Void x-component="ArrayCollapse.Index" />
            <SchemaField.String
              name="input"
              x-decorator="FormItem"
              title="Input"
              required
              x-component="Input"
            />
            <SchemaField.Void x-component="ArrayCollapse.Remove" />
            <SchemaField.Void x-component="ArrayCollapse.MoveUp" />
            <SchemaField.Void x-component="ArrayCollapse.MoveDown" />
          </SchemaField.Void>
          <SchemaField.Void
            x-component="ArrayCollapse.Addition"
            title="Add entry"
          />
        </SchemaField.Array>
        <SchemaField.Array
          name="array"
          maxItems={3}
          x-decorator="FormItem"
          x-component="ArrayCollapse"
        >
          <SchemaField.Object
            x-component="ArrayCollapse.CollapsePanel"
            x-component-props={{
              header: 'Object array',
            }}
          >
            <SchemaField.Void x-component="ArrayCollapse.Index" />
            <SchemaField.String
              name="input"
              x-decorator="FormItem"
              title="Input"
              required
              x-component="Input"
            />
            <SchemaField.Void x-component="ArrayCollapse.Remove" />
            <SchemaField.Void x-component="ArrayCollapse.MoveUp" />
            <SchemaField.Void x-component="ArrayCollapse.MoveDown" />
          </SchemaField.Object>
          <SchemaField.Void
            x-component="ArrayCollapse.Addition"
            title="Add entry"
          />
        </SchemaField.Array>
        <SchemaField.Array
          name="string_array_unshift"
          maxItems={3}
          x-decorator="FormItem"
          x-component="ArrayCollapse"
          x-component-props={{
            defaultOpenPanelCount: 8,
          }}
        >
          <SchemaField.Void
            x-component="ArrayCollapse.CollapsePanel"
            x-component-props={{
              header: 'String array',
            }}
          >
            <SchemaField.Void x-component="ArrayCollapse.Index" />
            <SchemaField.String
              name="input"
              x-decorator="FormItem"
              title="Input"
              required
              x-component="Input"
            />
            <SchemaField.Void x-component="ArrayCollapse.Remove" />
            <SchemaField.Void x-component="ArrayCollapse.MoveUp" />
            <SchemaField.Void x-component="ArrayCollapse.MoveDown" />
          </SchemaField.Void>
          <SchemaField.Void
            x-component="ArrayCollapse.Addition"
            title="Add entry (unshift)"
            x-component-props={{
              method: 'unshift',
            }}
          />
        </SchemaField.Array>
      </SchemaField>
      <FormButtonGroup>
        <Button
          onClick={() => {
            form.setInitialValues({
              array: Array.from({ length: 10 }).map(() => ({
                input: 'default value',
              })),
              string_array: Array.from({ length: 10 }).map(
                () => 'default value'
              ),
              string_array_unshift: Array.from({ length: 10 }).map(
                () => 'default value'
              ),
            })
          }}
        >
          Load default data
        </Button>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## JSON Schema case

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayCollapse,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    ArrayCollapse,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    string_array: {
      type: 'array',
      'x-component': 'ArrayCollapse',
      maxItems: 3,
      'x-decorator': 'FormItem',
      items: {
        type: 'void',
        'x-component': 'ArrayCollapse.CollapsePanel',
        'x-component-props': {
          header: 'String array',
        },
        properties: {
          index: {
            type: 'void',
            'x-component': 'ArrayCollapse.Index',
          },
          input: {
            type: 'string',
            'x-decorator': 'FormItem',
            title: 'Input',
            required: true,
            'x-component': 'Input',
          },
          remove: {
            type: 'void',
            'x-component': 'ArrayCollapse.Remove',
          },
          moveUp: {
            type: 'void',
            'x-component': 'ArrayCollapse.MoveUp',
          },
          moveDown: {
            type: 'void',
            'x-component': 'ArrayCollapse.MoveDown',
          },
        },
      },
      properties: {
        addition: {
          type: 'void',
          title: 'Add entry',
          'x-component': 'ArrayCollapse.Addition',
        },
      },
    },
    array: {
      type: 'array',
      'x-component': 'ArrayCollapse',
      maxItems: 3,
      'x-decorator': 'FormItem',
      items: {
        type: 'object',
        'x-component': 'ArrayCollapse.CollapsePanel',
        'x-component-props': {
          header: 'Object array',
        },
        properties: {
          index: {
            type: 'void',
            'x-component': 'ArrayCollapse.Index',
          },
          input: {
            type: 'string',
            'x-decorator': 'FormItem',
            title: 'Input',
            required: true,
            'x-component': 'Input',
          },
          remove: {
            type: 'void',
            'x-component': 'ArrayCollapse.Remove',
          },
          moveUp: {
            type: 'void',
            'x-component': 'ArrayCollapse.MoveUp',
          },
          moveDown: {
            type: 'void',
            'x-component': 'ArrayCollapse.MoveDown',
          },
        },
      },
      properties: {
        addition: {
          type: 'void',
          title: 'Add entry',
          'x-component': 'ArrayCollapse.Addition',
        },
      },
    },
    array_unshift: {
      type: 'array',
      'x-component': 'ArrayCollapse',
      maxItems: 3,
      'x-decorator': 'FormItem',
      items: {
        type: 'object',
        'x-component': 'ArrayCollapse.CollapsePanel',
        'x-component-props': {
          header: 'Object array',
        },
        properties: {
          index: {
            type: 'void',
            'x-component': 'ArrayCollapse.Index',
          },
          input: {
            type: 'string',
            'x-decorator': 'FormItem',
            title: 'Input',
            required: true,
            'x-component': 'Input',
          },
          remove: {
            type: 'void',
            'x-component': 'ArrayCollapse.Remove',
          },
          moveUp: {
            type: 'void',
            'x-component': 'ArrayCollapse.MoveUp',
          },
          moveDown: {
            type: 'void',
            'x-component': 'ArrayCollapse.MoveDown',
          },
        },
      },
      properties: {
        addition: {
          type: 'void',
          title: 'Add entry (unshift)',
          'x-component': 'ArrayCollapse.Addition',
          'x-component-props': {
            method: 'unshift',
          },
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} />
      <FormButtonGroup>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## Effects linkage case

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayCollapse,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm, onFieldChange, onFieldReact } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    ArrayCollapse,
  },
})

const form = createForm({
  effects: () => {
    //Active linkage mode
    onFieldChange('array.*.aa', ['value'], (field, form) => {
      form.setFieldState(field.query('.bb'), (state) => {
        state.visible = field.value != '123'
      })
    })
    //Passive linkage mode
    onFieldReact('array.*.dd', (field) => {
      field.visible = field.query('.cc').get('value') != '123'
    })
  },
})

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Array
          name="array"
          maxItems={3}
          x-component="ArrayCollapse"
          x-decorator="FormItem"
          x-component-props={{
            title: 'Object array',
          }}
        >
          <SchemaField.Object
            x-component="ArrayCollapse.CollapsePanel"
            x-component-props={{
              header: 'Object array',
            }}
          >
            <SchemaField.Void x-component="ArrayCollapse.Index" />
            <SchemaField.String
              name="aa"
              x-decorator="FormItem"
              title="AA"
              required
              description="AA hide BB when entering 123"
              x-component="Input"
            />
            <SchemaField.String
              name="bb"
              x-decorator="FormItem"
              title="BB"
              required
              x-component="Input"
            />
            <SchemaField.String
              name="cc"
              x-decorator="FormItem"
              title="CC"
              required
              description="Hide DD when CC enters 123"
              x-component="Input"
            />
            <SchemaField.String
              name="dd"
              x-decorator="FormItem"
              title="DD"
              required
              x-component="Input"
            />
            <SchemaField.Void x-component="ArrayCollapse.Remove" />
            <SchemaField.Void x-component="ArrayCollapse.MoveUp" />
            <SchemaField.Void x-component="ArrayCollapse.MoveDown" />
          </SchemaField.Object>
          <SchemaField.Void
            x-component="ArrayCollapse.Addition"
            title="Add entry"
          />
        </SchemaField.Array>
      </SchemaField>
      <FormButtonGroup>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## JSON Schema linkage case

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayCollapse,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    ArrayCollapse,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    array: {
      type: 'array',
      'x-component': 'ArrayCollapse',
      maxItems: 3,
      title: 'Object array',
      items: {
        type: 'object',
        'x-component': 'ArrayCollapse.CollapsePanel',
        'x-component-props': {
          header: 'Object array',
        },
        properties: {
          index: {
            type: 'void',
            'x-component': 'ArrayCollapse.Index',
          },
          aa: {
            type: 'string',
            'x-decorator': 'FormItem',
            title: 'AA',
            required: true,
            'x-component': 'Input',
            description: 'Enter 123',
          },
          bb: {
            type: 'string',
            title: 'BB',
            required: true,
            'x-decorator': 'FormItem',
            'x-component': 'Input',
            'x-reactions': [
              {
                dependencies: ['.aa'],
                when: "{{$deps[0] != '123'}}",
                fulfill: {
                  schema: {
                    title: 'BB',
                    'x-disabled': true,
                  },
                },
                otherwise: {
                  schema: {
                    title: 'Changed',
                    'x-disabled': false,
                  },
                },
              },
            ],
          },
          remove: {
            type: 'void',
            'x-component': 'ArrayCollapse.Remove',
          },
          moveUp: {
            type: 'void',
            'x-component': 'ArrayCollapse.MoveUp',
          },
          moveDown: {
            type: 'void',
            'x-component': 'ArrayCollapse.MoveDown',
          },
        },
      },
      properties: {
        addition: {
          type: 'void',
          title: 'Add entry',
          'x-component': 'ArrayCollapse.Addition',
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} />
      <FormButtonGroup>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## API

### ArrayCollapse

Reference https://ant.design/components/collapse-cn/

### ArrayCollapse.CollapsePanel

Reference https://ant.design/components/collapse-cn/

### ArrayCollapse.Addition

> Add button

Extended attributes

| Property name | Type                 | Description   | Default value |
| ------------- | -------------------- | ------------- | ------------- |
| title         | ReactText            | Copywriting   |               |
| method        | `'push' \|'unshift'` | add method    | `'push'`      |
| defaultValue  | `any`                | Default value |               |

Other references https://ant.design/components/button-cn/

Note: The title attribute can receive the title mapping in the Field model, that is, uploading the title in the Field is also effective

Note: You can disable default behavior with `onClick={e => e.preventDefault()}` in props.

### ArrayCollapse.Remove

> Delete button

| Property name | Type      | Description | Default value |
| ------------- | --------- | ----------- | ------------- |
| title         | ReactText | Copywriting |               |

Other references https://ant.design/components/icon-cn/

Note: The title attribute can receive the title mapping in the Field model, that is, uploading the title in the Field is also effective

Note: You can disable default behavior with `onClick={e => e.preventDefault()}` in props.

### ArrayCollapse.MoveDown

> Move down button

| Property name | Type      | Description | Default value |
| ------------- | --------- | ----------- | ------------- |
| title         | ReactText | Copywriting |               |

Other references https://ant.design/components/icon-cn/

Note: The title attribute can receive the title mapping in the Field model, that is, uploading the title in the Field is also effective

Note: You can disable default behavior with `onClick={e => e.preventDefault()}` in props.

### ArrayCollapse.MoveUp

> Move up button

| Property name | Type      | Description | Default value |
| ------------- | --------- | ----------- | ------------- |
| title         | ReactText | Copywriting |               |

Other references https://ant.design/components/icon-cn/

Note: The title attribute can receive the title mapping in the Field model, that is, uploading the title in the Field is also effective

Note: You can disable default behavior with `onClick={e => e.preventDefault()}` in props.

### ArrayCollapse.Index

> Index Renderer

No attributes

### ArrayCollapse.useIndex

> Read the React Hook of the current rendering row index

### ArrayCollapse.useRecord

> Read the React Hook of the current rendering row
</file>

<file path="packages/antd/docs/components/ArrayCollapse.zh-CN.md">
# ArrayCollapse

> 折叠面板，对于每行字段数量较多，联动较多的场景比较适合使用 ArrayCollapse
>
> 注意：该组件只适用于 Schema 场景

## Markup Schema 案例

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayCollapse,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Button } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    ArrayCollapse,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Array
          name="string_array"
          maxItems={3}
          x-decorator="FormItem"
          x-component="ArrayCollapse"
          x-component-props={{
            accordion: true,
            defaultOpenPanelCount: 3,
          }}
        >
          <SchemaField.Void
            x-component="ArrayCollapse.CollapsePanel"
            x-component-props={{
              header: '字符串数组',
            }}
          >
            <SchemaField.Void x-component="ArrayCollapse.Index" />
            <SchemaField.String
              name="input"
              x-decorator="FormItem"
              title="Input"
              required
              x-component="Input"
            />
            <SchemaField.Void x-component="ArrayCollapse.Remove" />
            <SchemaField.Void x-component="ArrayCollapse.MoveUp" />
            <SchemaField.Void x-component="ArrayCollapse.MoveDown" />
          </SchemaField.Void>
          <SchemaField.Void
            x-component="ArrayCollapse.Addition"
            title="添加条目"
          />
        </SchemaField.Array>
        <SchemaField.Array
          name="array"
          maxItems={3}
          x-decorator="FormItem"
          x-component="ArrayCollapse"
        >
          <SchemaField.Object
            x-component="ArrayCollapse.CollapsePanel"
            x-component-props={{
              header: '对象数组',
            }}
          >
            <SchemaField.Void x-component="ArrayCollapse.Index" />
            <SchemaField.String
              name="input"
              x-decorator="FormItem"
              title="Input"
              required
              x-component="Input"
            />
            <SchemaField.Void x-component="ArrayCollapse.Remove" />
            <SchemaField.Void x-component="ArrayCollapse.MoveUp" />
            <SchemaField.Void x-component="ArrayCollapse.MoveDown" />
          </SchemaField.Object>
          <SchemaField.Void
            x-component="ArrayCollapse.Addition"
            title="添加条目"
          />
        </SchemaField.Array>
        <SchemaField.Array
          name="string_array_unshift"
          maxItems={3}
          x-decorator="FormItem"
          x-component="ArrayCollapse"
          x-component-props={{
            defaultOpenPanelCount: 8,
          }}
        >
          <SchemaField.Void
            x-component="ArrayCollapse.CollapsePanel"
            x-component-props={{
              header: '字符串数组',
            }}
          >
            <SchemaField.Void x-component="ArrayCollapse.Index" />
            <SchemaField.String
              name="input"
              x-decorator="FormItem"
              title="Input"
              required
              x-component="Input"
            />
            <SchemaField.Void x-component="ArrayCollapse.Remove" />
            <SchemaField.Void x-component="ArrayCollapse.MoveUp" />
            <SchemaField.Void x-component="ArrayCollapse.MoveDown" />
          </SchemaField.Void>
          <SchemaField.Void
            x-component="ArrayCollapse.Addition"
            title="添加条目（unshift）"
            x-component-props={{
              method: 'unshift',
            }}
          />
        </SchemaField.Array>
      </SchemaField>
      <FormButtonGroup>
        <Button
          onClick={() => {
            form.setInitialValues({
              array: Array.from({ length: 10 }).map(() => ({
                input: 'default value',
              })),
              string_array: Array.from({ length: 10 }).map(
                () => 'default value'
              ),
              string_array_unshift: Array.from({ length: 10 }).map(
                () => 'default value'
              ),
            })
          }}
        >
          加载默认数据
        </Button>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## JSON Schema 案例

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayCollapse,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    ArrayCollapse,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    string_array: {
      type: 'array',
      'x-component': 'ArrayCollapse',
      'x-component-props': {
        onAdd: (index: number) => {
          console.log('Adding ' + index + ' item')
        },
      },
      maxItems: 3,
      'x-decorator': 'FormItem',
      items: {
        type: 'void',
        'x-component': 'ArrayCollapse.CollapsePanel',
        'x-component-props': {
          header: '字符串数组',
        },
        properties: {
          index: {
            type: 'void',
            'x-component': 'ArrayCollapse.Index',
          },
          input: {
            type: 'string',
            'x-decorator': 'FormItem',
            title: 'Input',
            required: true,
            'x-component': 'Input',
          },
          remove: {
            type: 'void',
            'x-component': 'ArrayCollapse.Remove',
          },
          moveUp: {
            type: 'void',
            'x-component': 'ArrayCollapse.MoveUp',
          },
          moveDown: {
            type: 'void',
            'x-component': 'ArrayCollapse.MoveDown',
          },
        },
      },
      properties: {
        addition: {
          type: 'void',
          title: '添加条目',
          'x-component': 'ArrayCollapse.Addition',
        },
      },
    },
    array: {
      type: 'array',
      'x-component': 'ArrayCollapse',
      maxItems: 3,
      'x-decorator': 'FormItem',
      items: {
        type: 'object',
        'x-component': 'ArrayCollapse.CollapsePanel',
        'x-component-props': {
          header: '对象数组',
        },
        properties: {
          index: {
            type: 'void',
            'x-component': 'ArrayCollapse.Index',
          },
          input: {
            type: 'string',
            'x-decorator': 'FormItem',
            title: 'Input',
            required: true,
            'x-component': 'Input',
          },
          remove: {
            type: 'void',
            'x-component': 'ArrayCollapse.Remove',
          },
          moveUp: {
            type: 'void',
            'x-component': 'ArrayCollapse.MoveUp',
          },
          moveDown: {
            type: 'void',
            'x-component': 'ArrayCollapse.MoveDown',
          },
        },
      },
      properties: {
        addition: {
          type: 'void',
          title: '添加条目',
          'x-component': 'ArrayCollapse.Addition',
        },
      },
    },
    array_unshift: {
      type: 'array',
      'x-component': 'ArrayCollapse',
      maxItems: 3,
      'x-decorator': 'FormItem',
      items: {
        type: 'object',
        'x-component': 'ArrayCollapse.CollapsePanel',
        'x-component-props': {
          header: '对象数组',
        },
        properties: {
          index: {
            type: 'void',
            'x-component': 'ArrayCollapse.Index',
          },
          input: {
            type: 'string',
            'x-decorator': 'FormItem',
            title: 'Input',
            required: true,
            'x-component': 'Input',
          },
          remove: {
            type: 'void',
            'x-component': 'ArrayCollapse.Remove',
          },
          moveUp: {
            type: 'void',
            'x-component': 'ArrayCollapse.MoveUp',
          },
          moveDown: {
            type: 'void',
            'x-component': 'ArrayCollapse.MoveDown',
          },
        },
      },
      properties: {
        addition: {
          type: 'void',
          title: '添加条目(unshift)',
          'x-component': 'ArrayCollapse.Addition',
          'x-component-props': {
            method: 'unshift',
          },
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} />
      <FormButtonGroup>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## Effects 联动案例

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayCollapse,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm, onFieldChange, onFieldReact } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    ArrayCollapse,
  },
})

const form = createForm({
  effects: () => {
    //主动联动模式
    onFieldChange('array.*.aa', ['value'], (field, form) => {
      form.setFieldState(field.query('.bb'), (state) => {
        state.visible = field.value != '123'
      })
    })
    //被动联动模式
    onFieldReact('array.*.dd', (field) => {
      field.visible = field.query('.cc').get('value') != '123'
    })
  },
})

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Array
          name="array"
          maxItems={3}
          x-component="ArrayCollapse"
          x-decorator="FormItem"
          x-component-props={{
            title: '对象数组',
          }}
        >
          <SchemaField.Object
            x-component="ArrayCollapse.CollapsePanel"
            x-component-props={{
              header: '对象数组',
            }}
          >
            <SchemaField.Void x-component="ArrayCollapse.Index" />
            <SchemaField.String
              name="aa"
              x-decorator="FormItem"
              title="AA"
              required
              description="AA输入123时隐藏BB"
              x-component="Input"
            />
            <SchemaField.String
              name="bb"
              x-decorator="FormItem"
              title="BB"
              required
              x-component="Input"
            />
            <SchemaField.String
              name="cc"
              x-decorator="FormItem"
              title="CC"
              required
              description="CC输入123时隐藏DD"
              x-component="Input"
            />
            <SchemaField.String
              name="dd"
              x-decorator="FormItem"
              title="DD"
              required
              x-component="Input"
            />
            <SchemaField.Void x-component="ArrayCollapse.Remove" />
            <SchemaField.Void x-component="ArrayCollapse.MoveUp" />
            <SchemaField.Void x-component="ArrayCollapse.MoveDown" />
          </SchemaField.Object>
          <SchemaField.Void
            x-component="ArrayCollapse.Addition"
            title="添加条目"
          />
        </SchemaField.Array>
      </SchemaField>
      <FormButtonGroup>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## JSON Schema 联动案例

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayCollapse,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    ArrayCollapse,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    array: {
      type: 'array',
      'x-component': 'ArrayCollapse',
      maxItems: 3,
      title: '对象数组',
      items: {
        type: 'object',
        'x-component': 'ArrayCollapse.CollapsePanel',
        'x-component-props': {
          header: '对象数组',
        },
        properties: {
          index: {
            type: 'void',
            'x-component': 'ArrayCollapse.Index',
          },
          aa: {
            type: 'string',
            'x-decorator': 'FormItem',
            title: 'AA',
            required: true,
            'x-component': 'Input',
            description: '输入123',
          },
          bb: {
            type: 'string',
            title: 'BB',
            required: true,
            'x-decorator': 'FormItem',
            'x-component': 'Input',
            'x-reactions': [
              {
                dependencies: ['.aa'],
                when: "{{$deps[0] != '123'}}",
                fulfill: {
                  schema: {
                    title: 'BB',
                    'x-disabled': true,
                  },
                },
                otherwise: {
                  schema: {
                    title: 'Changed',
                    'x-disabled': false,
                  },
                },
              },
            ],
          },
          remove: {
            type: 'void',
            'x-component': 'ArrayCollapse.Remove',
          },
          moveUp: {
            type: 'void',
            'x-component': 'ArrayCollapse.MoveUp',
          },
          moveDown: {
            type: 'void',
            'x-component': 'ArrayCollapse.MoveDown',
          },
        },
      },
      properties: {
        addition: {
          type: 'void',
          title: '添加条目',
          'x-component': 'ArrayCollapse.Addition',
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} />
      <FormButtonGroup>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## API

### ArrayCollapse

参考 https://ant.design/components/collapse-cn/

### ArrayCollapse.CollapsePanel

参考 https://ant.design/components/collapse-cn/

### ArrayCollapse.Addition

> 添加按钮

扩展属性

| 属性名       | 类型                  | 描述     | 默认值   |
| ------------ | --------------------- | -------- | -------- |
| title        | ReactText             | 文案     |          |
| method       | `'push' \| 'unshift'` | 添加方式 | `'push'` |
| defaultValue | `any`                 | 默认值   |          |

其余参考 https://ant.design/components/button-cn/

注意：title 属性可以接收 Field 模型中的 title 映射，也就是在 Field 上传 title 也是生效的

注意：使用`onClick={e => e.preventDefault()}`可禁用默认行为。

### ArrayCollapse.Remove

> 删除按钮

| 属性名 | 类型      | 描述 | 默认值 |
| ------ | --------- | ---- | ------ |
| title  | ReactText | 文案 |        |

其余参考 https://ant.design/components/icon-cn/

注意：title 属性可以接收 Field 模型中的 title 映射，也就是在 Field 上传 title 也是生效的

注意：使用`onClick={e => e.preventDefault()}`可禁用默认行为。

### ArrayCollapse.MoveDown

> 下移按钮

| 属性名 | 类型      | 描述 | 默认值 |
| ------ | --------- | ---- | ------ |
| title  | ReactText | 文案 |        |

其余参考 https://ant.design/components/icon-cn/

注意：title 属性可以接收 Field 模型中的 title 映射，也就是在 Field 上传 title 也是生效的

注意：使用`onClick={e => e.preventDefault()}`可禁用默认行为。

### ArrayCollapse.MoveUp

> 上移按钮

| 属性名 | 类型      | 描述 | 默认值 |
| ------ | --------- | ---- | ------ |
| title  | ReactText | 文案 |        |

其余参考 https://ant.design/components/icon-cn/

注意：title 属性可以接收 Field 模型中的 title 映射，也就是在 Field 上传 title 也是生效的

注意：使用`onClick={e => e.preventDefault()}`可禁用默认行为。

### ArrayCollapse.Index

> 索引渲染器

无属性

### ArrayCollapse.useIndex

> 读取当前渲染行索引的 React Hook

### ArrayCollapse.useRecord

> 读取当前渲染记录的 React Hook
</file>

<file path="packages/antd/docs/components/ArrayItems.md">
# ArrayItems

> Self-increment list, suitable for simple self-increment editing scenes, or for scenes with high space requirements
>
> Note: This component is only applicable to Schema scenarios

## Markup Schema example

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  Editable,
  Select,
  DatePicker,
  ArrayItems,
  FormButtonGroup,
  Submit,
  Space,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    DatePicker,
    Editable,
    Space,
    Input,
    Select,
    ArrayItems,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Array
          name="string_array"
          title="string array"
          x-decorator="FormItem"
          x-component="ArrayItems"
        >
          <SchemaField.Void x-component="Space">
            <SchemaField.Void
              x-decorator="FormItem"
              x-component="ArrayItems.SortHandle"
            />
            <SchemaField.String
              x-decorator="FormItem"
              required
              name="input"
              x-component="Input"
            />
            <SchemaField.Void
              x-decorator="FormItem"
              x-component="ArrayItems.Remove"
            />
            <SchemaField.Void
              x-decorator="FormItem"
              x-component="ArrayItems.Copy"
            />
          </SchemaField.Void>
          <SchemaField.Void
            x-component="ArrayItems.Addition"
            title="Add entry"
          />
        </SchemaField.Array>
        <SchemaField.Array
          name="array"
          title="Object array"
          x-decorator="FormItem"
          x-component="ArrayItems"
        >
          <SchemaField.Object>
            <SchemaField.Void x-component="Space">
              <SchemaField.Void
                x-decorator="FormItem"
                x-component="ArrayItems.SortHandle"
              />
              <SchemaField.String
                x-decorator="FormItem"
                required
                title="date"
                name="date"
                x-component="DatePicker.RangePicker"
                x-component-props={{
                  style: {
                    width: 160,
                  },
                }}
              />
              <SchemaField.String
                x-decorator="FormItem"
                required
                title="input box"
                name="input"
                x-component="Input"
              />
              <SchemaField.String
                x-decorator="FormItem"
                required
                title="select box"
                name="select"
                enum={[
                  { label: 'Option 1', value: 1 },
                  { label: 'Option 2', value: 2 },
                ]}
                x-component="Select"
                x-component-props={{
                  style: {
                    width: 160,
                  },
                }}
              />
              <SchemaField.Void
                x-decorator="FormItem"
                x-component="ArrayItems.Remove"
              />
            </SchemaField.Void>
          </SchemaField.Object>
          <SchemaField.Void
            x-component="ArrayItems.Addition"
            title="Add entry"
          />
        </SchemaField.Array>
        <SchemaField.Array
          name="array2"
          title="Object array"
          x-decorator="FormItem"
          x-component="ArrayItems"
          x-component-props={{ style: { width: 300 } }}
        >
          <SchemaField.Object x-decorator="ArrayItems.Item">
            <SchemaField.Void
              x-decorator="FormItem"
              x-component="ArrayItems.SortHandle"
            />
            <SchemaField.String
              x-decorator="Editable"
              title="input box"
              name="input"
              x-component="Input"
              x-component-props={{ bordered: false }}
            />
            <SchemaField.Object
              name="config"
              x-component="Editable.Popover"
              required
              title="Configure complex data"
              x-reactions={(field) => {
                field.title = field.value?.input || field.title
              }}
            >
              <SchemaField.String
                x-decorator="FormItem"
                required
                title="date"
                name="date"
                x-component="DatePicker.RangePicker"
                x-component-props={{ style: { width: '100%' } }}
              />
              <SchemaField.String
                x-decorator="FormItem"
                required
                title="input box"
                name="input"
                x-component="Input"
              />
            </SchemaField.Object>
            <SchemaField.Void
              x-decorator="FormItem"
              x-component="ArrayItems.Remove"
            />
          </SchemaField.Object>
          <SchemaField.Void
            x-component="ArrayItems.Addition"
            title="Add entry"
          />
        </SchemaField.Array>
      </SchemaField>
      <FormButtonGroup>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## JSON Schema case

```tsx
import React from 'react'
import {
  FormItem,
  Editable,
  Input,
  Select,
  Radio,
  DatePicker,
  ArrayItems,
  FormButtonGroup,
  Submit,
  Space,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Editable,
    DatePicker,
    Space,
    Radio,
    Input,
    Select,
    ArrayItems,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    string_array: {
      type: 'array',
      'x-component': 'ArrayItems',
      'x-decorator': 'FormItem',
      title: 'String array',
      items: {
        type: 'void',
        'x-component': 'Space',
        properties: {
          sort: {
            type: 'void',
            'x-decorator': 'FormItem',
            'x-component': 'ArrayItems.SortHandle',
          },
          input: {
            type: 'string',
            'x-decorator': 'FormItem',
            'x-component': 'Input',
          },
          remove: {
            type: 'void',
            'x-decorator': 'FormItem',
            'x-component': 'ArrayItems.Remove',
          },
        },
      },
      properties: {
        add: {
          type: 'void',
          title: 'Add entry',
          'x-component': 'ArrayItems.Addition',
        },
      },
    },
    array: {
      type: 'array',
      'x-component': 'ArrayItems',
      'x-decorator': 'FormItem',
      title: 'Object array',
      items: {
        type: 'object',
        properties: {
          space: {
            type: 'void',
            'x-component': 'Space',
            properties: {
              sort: {
                type: 'void',
                'x-decorator': 'FormItem',
                'x-component': 'ArrayItems.SortHandle',
              },
              date: {
                type: 'string',
                title: 'Date',
                'x-decorator': 'FormItem',
                'x-component': 'DatePicker.RangePicker',
                'x-component-props': {
                  style: {
                    width: 160,
                  },
                },
              },
              input: {
                type: 'string',
                title: 'input box',
                'x-decorator': 'FormItem',
                'x-component': 'Input',
              },
              select: {
                type: 'string',
                title: 'drop-down box',
                enum: [
                  { label: 'Option 1', value: 1 },
                  { label: 'Option 2', value: 2 },
                ],
                'x-decorator': 'FormItem',
                'x-component': 'Select',
                'x-component-props': {
                  style: {
                    width: 160,
                  },
                },
              },
              remove: {
                type: 'void',
                'x-decorator': 'FormItem',
                'x-component': 'ArrayItems.Remove',
              },
            },
          },
        },
      },
      properties: {
        add: {
          type: 'void',
          title: 'Add entry',
          'x-component': 'ArrayItems.Addition',
        },
      },
    },
    array2: {
      type: 'array',
      'x-component': 'ArrayItems',
      'x-decorator': 'FormItem',
      'x-component-props': { style: { width: 300 } },
      title: 'Object array',
      items: {
        type: 'object',
        'x-decorator': 'ArrayItems.Item',
        properties: {
          sort: {
            type: 'void',
            'x-decorator': 'FormItem',
            'x-component': 'ArrayItems.SortHandle',
          },

          input: {
            type: 'string',
            title: 'input box',
            'x-decorator': 'Editable',
            'x-component': 'Input',
            'x-component-props': {
              bordered: false,
            },
          },
          config: {
            type: 'object',
            title: 'Configure complex data',
            'x-component': 'Editable.Popover',
            'x-reactions':
              '{{(field)=>field.title = field.value && field.value.input || field.title}}',
            properties: {
              date: {
                type: 'string',
                title: 'Date',
                'x-decorator': 'FormItem',
                'x-component': 'DatePicker.RangePicker',
                'x-component-props': {
                  style: {
                    width: 160,
                  },
                },
              },
              input: {
                type: 'string',
                title: 'input box',
                'x-decorator': 'FormItem',
                'x-component': 'Input',
              },
              select: {
                type: 'string',
                title: 'drop-down box',
                enum: [
                  { label: 'Option 1', value: 1 },
                  { label: 'Option 2', value: 2 },
                ],
                'x-decorator': 'FormItem',
                'x-component': 'Select',
                'x-component-props': {
                  style: {
                    width: 160,
                  },
                },
              },
            },
          },
          remove: {
            type: 'void',
            'x-decorator': 'FormItem',
            'x-component': 'ArrayItems.Remove',
          },
        },
      },
      properties: {
        add: {
          type: 'void',
          title: 'Add entry',
          'x-component': 'ArrayItems.Addition',
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} />
      <FormButtonGroup>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## Effects linkage case

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayItems,
  Editable,
  FormButtonGroup,
  Submit,
  Space,
} from '@formily/antd'
import { createForm, onFieldChange, onFieldReact } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Space,
    Editable,
    FormItem,
    Input,
    ArrayItems,
  },
})

const form = createForm({
  effects: () => {
    //Active linkage mode
    onFieldChange('array.*.aa', ['value'], (field, form) => {
      form.setFieldState(field.query('.bb'), (state) => {
        state.visible = field.value != '123'
      })
    })
    //Passive linkage mode
    onFieldReact('array.*.dd', (field) => {
      field.visible = field.query('.cc').get('value') != '123'
    })
  },
})

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Array
          name="array"
          title="Object array"
          maxItems={3}
          x-decorator="FormItem"
          x-component="ArrayItems"
          x-component-props={{
            style: {
              width: 300,
            },
          }}
        >
          <SchemaField.Object x-decorator="ArrayItems.Item">
            <SchemaField.Void x-component="Space">
              <SchemaField.Void
                x-decorator="FormItem"
                x-component="ArrayItems.SortHandle"
              />
              <SchemaField.Void
                x-decorator="FormItem"
                x-component="ArrayItems.Index"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="Editable.Popover"
              title="Configuration data"
            >
              <SchemaField.String
                name="aa"
                x-decorator="FormItem"
                title="AA"
                required
                description="AA hide BB when entering 123"
                x-component="Input"
              />
              <SchemaField.String
                name="bb"
                x-decorator="FormItem"
                title="BB"
                required
                x-component="Input"
              />
              <SchemaField.String
                name="cc"
                x-decorator="FormItem"
                title="CC"
                required
                description="Hide DD when CC enters 123"
                x-component="Input"
              />
              <SchemaField.String
                name="dd"
                x-decorator="FormItem"
                title="DD"
                required
                x-component="Input"
              />
            </SchemaField.Void>
            <SchemaField.Void x-component="Space">
              <SchemaField.Void
                x-decorator="FormItem"
                x-component="ArrayItems.Remove"
              />
              <SchemaField.Void
                x-decorator="FormItem"
                x-component="ArrayItems.MoveUp"
              />
              <SchemaField.Void
                x-decorator="FormItem"
                x-component="ArrayItems.MoveDown"
              />
            </SchemaField.Void>
          </SchemaField.Object>
          <SchemaField.Void
            x-component="ArrayItems.Addition"
            title="Add entry"
          />
        </SchemaField.Array>
      </SchemaField>
      <FormButtonGroup>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## JSON Schema linkage case

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayItems,
  Editable,
  FormButtonGroup,
  Submit,
  Space,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Space,
    Editable,
    FormItem,
    Input,
    ArrayItems,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    array: {
      type: 'array',
      'x-component': 'ArrayItems',
      'x-decorator': 'FormItem',
      maxItems: 3,
      title: 'Object array',
      'x-component-props': { style: { width: 300 } },
      items: {
        type: 'object',
        'x-decorator': 'ArrayItems.Item',
        properties: {
          left: {
            type: 'void',
            'x-component': 'Space',
            properties: {
              sort: {
                type: 'void',
                'x-decorator': 'FormItem',
                'x-component': 'ArrayItems.SortHandle',
              },
              index: {
                type: 'void',
                'x-decorator': 'FormItem',
                'x-component': 'ArrayItems.Index',
              },
            },
          },
          edit: {
            type: 'void',
            'x-component': 'Editable.Popover',
            title: 'Configuration data',
            properties: {
              aa: {
                type: 'string',
                'x-decorator': 'FormItem',
                title: 'AA',
                required: true,
                'x-component': 'Input',
                description: 'Enter 123',
              },
              bb: {
                type: 'string',
                title: 'BB',
                required: true,
                'x-decorator': 'FormItem',
                'x-component': 'Input',
                'x-reactions': [
                  {
                    dependencies: ['.aa'],
                    when: "{{$deps[0] != '123'}}",
                    fulfill: {
                      schema: {
                        title: 'BB',
                        'x-disabled': true,
                      },
                    },
                    otherwise: {
                      schema: {
                        title: 'Changed',
                        'x-disabled': false,
                      },
                    },
                  },
                ],
              },
            },
          },
          right: {
            type: 'void',
            'x-component': 'Space',
            properties: {
              remove: {
                type: 'void',
                'x-component': 'ArrayItems.Remove',
              },
              moveUp: {
                type: 'void',
                'x-component': 'ArrayItems.MoveUp',
              },
              moveDown: {
                type: 'void',
                'x-component': 'ArrayItems.MoveDown',
              },
            },
          },
        },
      },
      properties: {
        addition: {
          type: 'void',
          title: 'Add entry',
          'x-component': 'ArrayItems.Addition',
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} />
      <FormButtonGroup>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## API

### ArrayItems

Extended attributes

| Property name | Type                      | Description     | Default value |
| ------------- | ------------------------- | --------------- | ------------- |
| onAdd         | `(index: number) => void` | add method      |               |
| onRemove      | `(index: number) => void` | remove method   |               |
| onCopy        | `(index: number) => void` | copy method     |               |
| onMoveUp      | `(index: number) => void` | moveUp method   |               |
| onMoveDown    | `(index: number) => void` | moveDown method |               |

Other Inherit HTMLDivElement Props

### ArrayItems.Item

> List block

Inherit HTMLDivElement Props

Extended attributes

| Property name | Type                | Description           | Default value |
| ------------- | ------------------- | --------------------- | ------------- |
| type          | `'card' \|'divide'` | card or dividing line |               |

### ArrayItems.SortHandle

> Drag handle

Reference https://ant.design/components/icon-cn/

### ArrayItems.Addition

> Add button

Extended attributes

| Property name | Type                 | Description   | Default value |
| ------------- | -------------------- | ------------- | ------------- |
| title         | ReactText            | Copywriting   |               |
| method        | `'push' \|'unshift'` | add method    | `'push'`      |
| defaultValue  | `any`                | Default value |               |

Other references https://ant.design/components/button-cn/

Note: The title attribute can receive the title mapping in the Field model, that is, uploading the title in the Field is also effective

Note: You can disable default behavior with `onClick={e => e.preventDefault()}` in props.

### ArrayItems.Copy

> Copy button

Extended attributes

| Property name | Type                 | Description | Default value |
| ------------- | -------------------- | ----------- | ------------- |
| title         | ReactText            | Copywriting |               |
| method        | `'push' \|'unshift'` | Copy method | `'push'`      |

Other references https://ant.design/components/button-cn/

Note: The title attribute can receive the title mapping in the Field model, that is, uploading the title in the Field is also effective

Note: You can disable default behavior with `onClick={e => e.preventDefault()}` in props.

### ArrayItems.Remove

> Delete button

| Property name | Type      | Description | Default value |
| ------------- | --------- | ----------- | ------------- |
| title         | ReactText | Copywriting |               |

Other references https://ant.design/components/icon-cn/

Note: The title attribute can receive the title mapping in the Field model, that is, uploading the title in the Field is also effective

Note: You can disable default behavior with `onClick={e => e.preventDefault()}` in props.

### ArrayItems.MoveDown

> Move down button

| Property name | Type      | Description | Default value |
| ------------- | --------- | ----------- | ------------- |
| title         | ReactText | Copywriting |               |

Other references https://ant.design/components/icon-cn/

Note: The title attribute can receive the title mapping in the Field model, that is, uploading the title in the Field is also effective

Note: You can disable default behavior with `onClick={e => e.preventDefault()}` in props.

### ArrayItems.MoveUp

> Move up button

| Property name | Type      | Description | Default value |
| ------------- | --------- | ----------- | ------------- |
| title         | ReactText | Copywriting |               |

Other references https://ant.design/components/icon-cn/

Note: The title attribute can receive the title mapping in the Field model, that is, uploading the title in the Field is also effective

Note: You can disable default behavior with `onClick={e => e.preventDefault()}` in props.

### ArrayItems.Index

> Index Renderer

No attributes

### ArrayItems.useIndex

> Read the React Hook of the current rendering row index

### ArrayItems.useRecord

> Read the React Hook of the current rendering row
</file>

<file path="packages/antd/docs/components/ArrayItems.zh-CN.md">
# ArrayItems

> 自增列表，对于简单的自增编辑场景比较适合，或者对于空间要求高的场景比较适合
>
> 注意：该组件只适用于 Schema 场景

## Markup Schema 案例

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  Editable,
  Select,
  DatePicker,
  ArrayItems,
  FormButtonGroup,
  Submit,
  Space,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    DatePicker,
    Editable,
    Space,
    Input,
    Select,
    ArrayItems,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Array
          name="string_array"
          title="字符串数组"
          x-decorator="FormItem"
          x-component="ArrayItems"
        >
          <SchemaField.Void x-component="Space">
            <SchemaField.Void
              x-decorator="FormItem"
              x-component="ArrayItems.SortHandle"
            />
            <SchemaField.String
              x-decorator="FormItem"
              required
              name="input"
              x-component="Input"
            />
            <SchemaField.Void
              x-decorator="FormItem"
              x-component="ArrayItems.Remove"
            />
            <SchemaField.Void
              x-decorator="FormItem"
              x-component="ArrayItems.Copy"
            />
          </SchemaField.Void>
          <SchemaField.Void
            x-component="ArrayItems.Addition"
            title="添加条目"
          />
        </SchemaField.Array>
        <SchemaField.Array
          name="array"
          title="对象数组"
          x-decorator="FormItem"
          x-component="ArrayItems"
        >
          <SchemaField.Object>
            <SchemaField.Void x-component="Space">
              <SchemaField.Void
                x-decorator="FormItem"
                x-component="ArrayItems.SortHandle"
              />
              <SchemaField.String
                x-decorator="FormItem"
                required
                title="日期"
                name="date"
                x-component="DatePicker.RangePicker"
                x-component-props={{
                  style: {
                    width: 160,
                  },
                }}
              />
              <SchemaField.String
                x-decorator="FormItem"
                required
                title="输入框"
                name="input"
                x-component="Input"
              />
              <SchemaField.String
                x-decorator="FormItem"
                required
                title="选择框"
                name="select"
                enum={[
                  { label: '选项1', value: 1 },
                  { label: '选项2', value: 2 },
                ]}
                x-component="Select"
                x-component-props={{
                  style: {
                    width: 160,
                  },
                }}
              />
              <SchemaField.Void
                x-decorator="FormItem"
                x-component="ArrayItems.Remove"
              />
              <SchemaField.Void
                x-decorator="FormItem"
                x-component="ArrayItems.Copy"
              />
            </SchemaField.Void>
          </SchemaField.Object>
          <SchemaField.Void
            x-component="ArrayItems.Addition"
            title="添加条目"
          />
        </SchemaField.Array>
        <SchemaField.Array
          name="array2"
          title="对象数组"
          x-decorator="FormItem"
          x-component="ArrayItems"
          x-component-props={{ style: { width: 300 } }}
        >
          <SchemaField.Object x-decorator="ArrayItems.Item">
            <SchemaField.Void
              x-decorator="FormItem"
              x-component="ArrayItems.SortHandle"
            />
            <SchemaField.String
              x-decorator="Editable"
              title="输入框"
              name="input"
              x-component="Input"
              x-component-props={{ bordered: false }}
            />
            <SchemaField.Object
              name="config"
              x-component="Editable.Popover"
              required
              title="配置复杂数据"
              x-reactions={(field) => {
                field.title = field.value?.input || field.title
              }}
            >
              <SchemaField.String
                x-decorator="FormItem"
                required
                title="日期"
                name="date"
                x-component="DatePicker.RangePicker"
                x-component-props={{ style: { width: '100%' } }}
              />
              <SchemaField.String
                x-decorator="FormItem"
                required
                title="输入框"
                name="input"
                x-component="Input"
              />
            </SchemaField.Object>
            <SchemaField.Void
              x-decorator="FormItem"
              x-component="ArrayItems.Remove"
            />
          </SchemaField.Object>
          <SchemaField.Void
            x-component="ArrayItems.Addition"
            title="添加条目"
          />
        </SchemaField.Array>
      </SchemaField>
      <FormButtonGroup>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## JSON Schema 案例

```tsx
import React from 'react'
import {
  FormItem,
  Editable,
  Input,
  Select,
  Radio,
  DatePicker,
  ArrayItems,
  FormButtonGroup,
  Submit,
  Space,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Editable,
    DatePicker,
    Space,
    Radio,
    Input,
    Select,
    ArrayItems,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    string_array: {
      type: 'array',
      'x-component': 'ArrayItems',
      'x-decorator': 'FormItem',
      title: '字符串数组',
      items: {
        type: 'void',
        'x-component': 'Space',
        properties: {
          sort: {
            type: 'void',
            'x-decorator': 'FormItem',
            'x-component': 'ArrayItems.SortHandle',
          },
          input: {
            type: 'string',
            'x-decorator': 'FormItem',
            'x-component': 'Input',
          },
          remove: {
            type: 'void',
            'x-decorator': 'FormItem',
            'x-component': 'ArrayItems.Remove',
          },
        },
      },
      properties: {
        add: {
          type: 'void',
          title: '添加条目',
          'x-component': 'ArrayItems.Addition',
        },
      },
    },
    array: {
      type: 'array',
      'x-component': 'ArrayItems',
      'x-decorator': 'FormItem',
      title: '对象数组',
      items: {
        type: 'object',
        properties: {
          space: {
            type: 'void',
            'x-component': 'Space',
            properties: {
              sort: {
                type: 'void',
                'x-decorator': 'FormItem',
                'x-component': 'ArrayItems.SortHandle',
              },
              date: {
                type: 'string',
                title: '日期',
                'x-decorator': 'FormItem',
                'x-component': 'DatePicker.RangePicker',
                'x-component-props': {
                  style: {
                    width: 160,
                  },
                },
              },
              input: {
                type: 'string',
                title: '输入框',
                'x-decorator': 'FormItem',
                'x-component': 'Input',
              },
              select: {
                type: 'string',
                title: '下拉框',
                enum: [
                  { label: '选项1', value: 1 },
                  { label: '选项2', value: 2 },
                ],
                'x-decorator': 'FormItem',
                'x-component': 'Select',
                'x-component-props': {
                  style: {
                    width: 160,
                  },
                },
              },
              remove: {
                type: 'void',
                'x-decorator': 'FormItem',
                'x-component': 'ArrayItems.Remove',
              },
            },
          },
        },
      },
      properties: {
        add: {
          type: 'void',
          title: '添加条目',
          'x-component': 'ArrayItems.Addition',
        },
      },
    },
    array2: {
      type: 'array',
      'x-component': 'ArrayItems',
      'x-decorator': 'FormItem',
      'x-component-props': { style: { width: 300 } },
      title: '对象数组',
      items: {
        type: 'object',
        'x-decorator': 'ArrayItems.Item',
        properties: {
          sort: {
            type: 'void',
            'x-decorator': 'FormItem',
            'x-component': 'ArrayItems.SortHandle',
          },

          input: {
            type: 'string',
            title: '输入框',
            'x-decorator': 'Editable',
            'x-component': 'Input',
            'x-component-props': {
              bordered: false,
            },
          },
          config: {
            type: 'object',
            title: '配置复杂数据',
            'x-component': 'Editable.Popover',
            'x-reactions':
              '{{(field)=>field.title = field.value && field.value.input || field.title}}',
            properties: {
              date: {
                type: 'string',
                title: '日期',
                'x-decorator': 'FormItem',
                'x-component': 'DatePicker.RangePicker',
                'x-component-props': {
                  style: {
                    width: 160,
                  },
                },
              },
              input: {
                type: 'string',
                title: '输入框',
                'x-decorator': 'FormItem',
                'x-component': 'Input',
              },
              select: {
                type: 'string',
                title: '下拉框',
                enum: [
                  { label: '选项1', value: 1 },
                  { label: '选项2', value: 2 },
                ],
                'x-decorator': 'FormItem',
                'x-component': 'Select',
                'x-component-props': {
                  style: {
                    width: 160,
                  },
                },
              },
            },
          },
          remove: {
            type: 'void',
            'x-decorator': 'FormItem',
            'x-component': 'ArrayItems.Remove',
          },
        },
      },
      properties: {
        add: {
          type: 'void',
          title: '添加条目',
          'x-component': 'ArrayItems.Addition',
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} />
      <FormButtonGroup>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## Effects 联动案例

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayItems,
  Editable,
  FormButtonGroup,
  Submit,
  Space,
} from '@formily/antd'
import { createForm, onFieldChange, onFieldReact } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Space,
    Editable,
    FormItem,
    Input,
    ArrayItems,
  },
})

const form = createForm({
  effects: () => {
    //主动联动模式
    onFieldChange('array.*.aa', ['value'], (field, form) => {
      form.setFieldState(field.query('.bb'), (state) => {
        state.visible = field.value != '123'
      })
    })
    //被动联动模式
    onFieldReact('array.*.dd', (field) => {
      field.visible = field.query('.cc').get('value') != '123'
    })
  },
})

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Array
          name="array"
          title="对象数组"
          maxItems={3}
          x-decorator="FormItem"
          x-component="ArrayItems"
          x-component-props={{
            style: {
              width: 300,
            },
          }}
        >
          <SchemaField.Object x-decorator="ArrayItems.Item">
            <SchemaField.Void x-component="Space">
              <SchemaField.Void
                x-decorator="FormItem"
                x-component="ArrayItems.SortHandle"
              />
              <SchemaField.Void
                x-decorator="FormItem"
                x-component="ArrayItems.Index"
              />
            </SchemaField.Void>
            <SchemaField.Void x-component="Editable.Popover" title="配置数据">
              <SchemaField.String
                name="aa"
                x-decorator="FormItem"
                title="AA"
                required
                description="AA输入123时隐藏BB"
                x-component="Input"
              />
              <SchemaField.String
                name="bb"
                x-decorator="FormItem"
                title="BB"
                required
                x-component="Input"
              />
              <SchemaField.String
                name="cc"
                x-decorator="FormItem"
                title="CC"
                required
                description="CC输入123时隐藏DD"
                x-component="Input"
              />
              <SchemaField.String
                name="dd"
                x-decorator="FormItem"
                title="DD"
                required
                x-component="Input"
              />
            </SchemaField.Void>
            <SchemaField.Void x-component="Space">
              <SchemaField.Void
                x-decorator="FormItem"
                x-component="ArrayItems.Remove"
              />
              <SchemaField.Void
                x-decorator="FormItem"
                x-component="ArrayItems.MoveUp"
              />
              <SchemaField.Void
                x-decorator="FormItem"
                x-component="ArrayItems.MoveDown"
              />
            </SchemaField.Void>
          </SchemaField.Object>
          <SchemaField.Void
            x-component="ArrayItems.Addition"
            title="添加条目"
          />
        </SchemaField.Array>
      </SchemaField>
      <FormButtonGroup>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## JSON Schema 联动案例

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayItems,
  Editable,
  FormButtonGroup,
  Submit,
  Space,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Space,
    Editable,
    FormItem,
    Input,
    ArrayItems,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    array: {
      type: 'array',
      'x-component': 'ArrayItems',
      'x-decorator': 'FormItem',
      maxItems: 3,
      title: '对象数组',
      'x-component-props': { style: { width: 300 } },
      items: {
        type: 'object',
        'x-decorator': 'ArrayItems.Item',
        properties: {
          left: {
            type: 'void',
            'x-component': 'Space',
            properties: {
              sort: {
                type: 'void',
                'x-decorator': 'FormItem',
                'x-component': 'ArrayItems.SortHandle',
              },
              index: {
                type: 'void',
                'x-decorator': 'FormItem',
                'x-component': 'ArrayItems.Index',
              },
            },
          },
          edit: {
            type: 'void',
            'x-component': 'Editable.Popover',
            title: '配置数据',
            properties: {
              aa: {
                type: 'string',
                'x-decorator': 'FormItem',
                title: 'AA',
                required: true,
                'x-component': 'Input',
                description: '输入123',
              },
              bb: {
                type: 'string',
                title: 'BB',
                required: true,
                'x-decorator': 'FormItem',
                'x-component': 'Input',
                'x-reactions': [
                  {
                    dependencies: ['.aa'],
                    when: "{{$deps[0] != '123'}}",
                    fulfill: {
                      schema: {
                        title: 'BB',
                        'x-disabled': true,
                      },
                    },
                    otherwise: {
                      schema: {
                        title: 'Changed',
                        'x-disabled': false,
                      },
                    },
                  },
                ],
              },
            },
          },
          right: {
            type: 'void',
            'x-component': 'Space',
            properties: {
              remove: {
                type: 'void',
                'x-component': 'ArrayItems.Remove',
              },
              moveUp: {
                type: 'void',
                'x-component': 'ArrayItems.MoveUp',
              },
              moveDown: {
                type: 'void',
                'x-component': 'ArrayItems.MoveDown',
              },
            },
          },
        },
      },
      properties: {
        addition: {
          type: 'void',
          title: '添加条目',
          'x-component': 'ArrayItems.Addition',
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} />
      <FormButtonGroup>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## API

### ArrayItems

扩展属性

| 属性名     | 类型                      | 描述         | 默认值 |
| ---------- | ------------------------- | ------------ | ------ |
| onAdd      | `(index: number) => void` | 增加方法     |        |
| onRemove   | `(index: number) => void` | 删除方法     |        |
| onCopy     | `(index: number) => void` | 复制方法     |        |
| onMoveUp   | `(index: number) => void` | 向上移动方法 |        |
| onMoveDown | `(index: number) => void` | 向下移动方法 |        |

其余继承 HTMLDivElement Props

### ArrayItems.Item

> 列表区块

继承 HTMLDivElement Props

扩展属性

| 属性名 | 类型                 | 描述           | 默认值 |
| ------ | -------------------- | -------------- | ------ |
| type   | `'card' \| 'divide'` | 卡片或者分割线 |        |

### ArrayItems.SortHandle

> 拖拽手柄

参考 https://ant.design/components/icon-cn/

### ArrayItems.Addition

> 添加按钮

扩展属性

| 属性名       | 类型                  | 描述     | 默认值   |
| ------------ | --------------------- | -------- | -------- |
| title        | ReactText             | 文案     |          |
| method       | `'push' \| 'unshift'` | 添加方式 | `'push'` |
| defaultValue | `any`                 | 默认值   |          |

其余参考 https://ant.design/components/button-cn/

注意：title 属性可以接收 Field 模型中的 title 映射，也就是在 Field 上传 title 也是生效的

注意：使用`onClick={e => e.preventDefault()}`可禁用默认行为。

### ArrayItems.Copy

> 复制按钮

扩展属性

| 属性名 | 类型                  | 描述     | 默认值   |
| ------ | --------------------- | -------- | -------- |
| title  | ReactText             | 文案     |          |
| method | `'push' \| 'unshift'` | 添加方式 | `'push'` |

其余参考 https://ant.design/components/button-cn/

注意：title 属性可以接收 Field 模型中的 title 映射，也就是在 Field 上传 title 也是生效的

注意：使用`onClick={e => e.preventDefault()}`可禁用默认行为。

### ArrayItems.Remove

> 删除按钮

| 属性名 | 类型      | 描述 | 默认值 |
| ------ | --------- | ---- | ------ |
| title  | ReactText | 文案 |        |

其余参考 https://ant.design/components/icon-cn/

注意：title 属性可以接收 Field 模型中的 title 映射，也就是在 Field 上传 title 也是生效的

注意：使用`onClick={e => e.preventDefault()}`可禁用默认行为。

### ArrayItems.MoveDown

> 下移按钮

| 属性名 | 类型      | 描述 | 默认值 |
| ------ | --------- | ---- | ------ |
| title  | ReactText | 文案 |        |

其余参考 https://ant.design/components/icon-cn/

注意：title 属性可以接收 Field 模型中的 title 映射，也就是在 Field 上传 title 也是生效的

注意：使用`onClick={e => e.preventDefault()}`可禁用默认行为。

### ArrayItems.MoveUp

> 上移按钮

| 属性名 | 类型      | 描述 | 默认值 |
| ------ | --------- | ---- | ------ |
| title  | ReactText | 文案 |        |

其余参考 https://ant.design/components/icon-cn/

注意：title 属性可以接收 Field 模型中的 title 映射，也就是在 Field 上传 title 也是生效的

注意：使用`onClick={e => e.preventDefault()}`可禁用默认行为。

### ArrayItems.Index

> 索引渲染器

无属性

### ArrayItems.useIndex

> 读取当前渲染行索引的 React Hook

### ArrayItems.useRecord

> 读取当前渲染记录的 React Hook
</file>

<file path="packages/antd/docs/components/ArrayTable.md">
# ArrayTable

> Self-increasing table, it is more suitable to use this component for scenes with a large amount of data. Although the amount of data is large to a certain extent, it will be a little bit stuck, but it will not affect the basic operation
>
> Note: This component is only applicable to Schema scenarios and can only be an array of objects

## Markup Schema example

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayTable,
  Editable,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Button, Alert } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Editable,
    Input,
    ArrayTable,
  },
})

const form = createForm()

const range = (count: number) =>
  Array.from(new Array(count)).map((_, key) => ({
    aaa: key,
  }))

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Array
          name="array"
          x-decorator="FormItem"
          x-component="ArrayTable"
          x-component-props={{
            pagination: { pageSize: 10 },
            scroll: { x: '100%' },
          }}
        >
          <SchemaField.Object>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{ width: 50, title: 'Sort', align: 'center' }}
            >
              <SchemaField.Void
                x-decorator="FormItem"
                required
                x-component="ArrayTable.SortHandle"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{ width: 80, title: 'Index', align: 'center' }}
            >
              <SchemaField.Void
                x-decorator="FormItem"
                required
                x-component="ArrayTable.Index"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{ title: 'A1', dataIndex: 'a1', width: 200 }}
            >
              <SchemaField.String
                name="a1"
                x-decorator="Editable"
                required
                x-component="Input"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{ title: 'A2', width: 200 }}
            >
              <SchemaField.String
                x-decorator="FormItem"
                name="a2"
                required
                x-component="Input"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{ title: 'A3', width: 200 }}
            >
              <SchemaField.String
                x-decorator="FormItem"
                name="a3"
                required
                x-component="Input"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{
                title: 'Operations',
                dataIndex: 'operations',
                width: 200,
                fixed: 'right',
              }}
            >
              <SchemaField.Void x-component="FormItem">
                <SchemaField.Void x-component="ArrayTable.Remove" />
                <SchemaField.Void x-component="ArrayTable.MoveDown" />
                <SchemaField.Void x-component="ArrayTable.MoveUp" />
              </SchemaField.Void>
            </SchemaField.Void>
          </SchemaField.Object>
          <SchemaField.Void
            x-component="ArrayTable.Addition"
            title="Add entry"
          />
        </SchemaField.Array>
      </SchemaField>
      <FormButtonGroup>
        <Submit onSubmit={console.log}>Submit</Submit>
        <Button
          block
          onClick={() => {
            form.setInitialValues({
              array: range(100000),
            })
          }}
        >
          Load 10W pieces of large data
        </Button>
      </FormButtonGroup>
      <Alert
        style={{ marginTop: 10 }}
        message="Note: Open the formily plug-in page, because there is data communication in the background, which will occupy the browser's computing power, it is best to test in the incognito mode (no formily plug-in)"
        type="warning"
      />
    </FormProvider>
  )
}
```

## JSON Schema case

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayTable,
  Editable,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Editable,
    Input,
    ArrayTable,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    array: {
      type: 'array',
      'x-decorator': 'FormItem',
      'x-component': 'ArrayTable',
      'x-component-props': {
        pagination: { pageSize: 10 },
        scroll: { x: '100%' },
      },
      items: {
        type: 'object',
        properties: {
          column1: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 50, title: 'Sort', align: 'center' },
            properties: {
              sort: {
                type: 'void',
                'x-component': 'ArrayTable.SortHandle',
              },
            },
          },
          column2: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 80, title: 'Index', align: 'center' },
            properties: {
              index: {
                type: 'void',
                'x-component': 'ArrayTable.Index',
              },
            },
          },
          column3: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 200, title: 'A1' },
            properties: {
              a1: {
                type: 'string',
                'x-decorator': 'Editable',
                'x-component': 'Input',
              },
            },
          },
          column4: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 200, title: 'A2' },
            properties: {
              a2: {
                type: 'string',
                'x-decorator': 'FormItem',
                'x-component': 'Input',
              },
            },
          },
          column5: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 200, title: 'A3' },
            properties: {
              a3: {
                type: 'string',
                'x-decorator': 'FormItem',
                'x-component': 'Input',
              },
            },
          },
          column6: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': {
              title: 'Operations',
              dataIndex: 'operations',
              width: 200,
              fixed: 'right',
            },
            properties: {
              item: {
                type: 'void',
                'x-component': 'FormItem',
                properties: {
                  remove: {
                    type: 'void',
                    'x-component': 'ArrayTable.Remove',
                  },
                  moveDown: {
                    type: 'void',
                    'x-component': 'ArrayTable.MoveDown',
                  },
                  moveUp: {
                    type: 'void',
                    'x-component': 'ArrayTable.MoveUp',
                  },
                },
              },
            },
          },
        },
      },
      properties: {
        add: {
          type: 'void',
          'x-component': 'ArrayTable.Addition',
          title: 'Add entry',
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} />
      <FormButtonGroup>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## Effects linkage case

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayTable,
  Switch,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm, onFieldChange, onFieldReact } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Button } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Switch,
    Input,
    Button,
    ArrayTable,
  },
})

const form = createForm({
  effects: () => {
    //Active linkage mode
    onFieldChange('hideFirstColumn', ['value'], (field) => {
      field.query('array.column4').take((target) => {
        target.visible = !field.value
      })
      field.query('array.*.a2').take((target) => {
        target.visible = !field.value
      })
    })
    //Passive linkage mode
    onFieldReact('array.*.a2', (field) => {
      field.visible = !field.query('.a1').get('value')
    })
  },
})

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Boolean
          name="hideFirstColumn"
          x-decorator="FormItem"
          x-component="Switch"
          title="Hide A2"
        />
        <SchemaField.Array
          name="array"
          x-decorator="FormItem"
          x-component="ArrayTable"
          x-component-props={{
            pagination: { pageSize: 10 },
            scroll: { x: '100%' },
          }}
        >
          <SchemaField.Object>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              name="column1"
              x-component-props={{ width: 50, title: 'Sort', align: 'center' }}
            >
              <SchemaField.Void
                x-decorator="FormItem"
                required
                x-component="ArrayTable.SortHandle"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              name="column2"
              x-component-props={{ width: 80, title: 'Index', align: 'center' }}
            >
              <SchemaField.String
                x-decorator="FormItem"
                required
                x-component="ArrayTable.Index"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              name="column3"
              x-component-props={{
                title: 'Explicitly hidden->A2',
                dataIndex: 'a1',
                width: 100,
              }}
            >
              <SchemaField.Boolean
                name="a1"
                x-decorator="FormItem"
                required
                x-component="Switch"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              name="column4"
              x-component-props={{ title: 'A2', width: 200 }}
            >
              <SchemaField.String
                x-decorator="FormItem"
                name="a2"
                required
                x-component="Input"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              name="column5"
              x-component-props={{ title: 'A3', width: 200 }}
            >
              <SchemaField.String
                x-decorator="FormItem"
                name="a3"
                required
                x-component="Input"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              name="column6"
              x-component-props={{
                title: 'Operations',
                dataIndex: 'operations',
                width: 200,
                fixed: 'right',
              }}
            >
              <SchemaField.Void x-component="FormItem">
                <SchemaField.Void x-component="ArrayTable.Remove" />
                <SchemaField.Void x-component="ArrayTable.MoveDown" />
                <SchemaField.Void x-component="ArrayTable.MoveUp" />
              </SchemaField.Void>
            </SchemaField.Void>
          </SchemaField.Object>
          <SchemaField.Void
            x-component="ArrayTable.Addition"
            title="Add entry"
          />
        </SchemaField.Array>
      </SchemaField>
      <FormButtonGroup>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## JSON Schema linkage case

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayTable,
  Switch,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Switch,
    Input,
    ArrayTable,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    hideFirstColumn: {
      type: 'boolean',
      title: 'Hide A2',
      'x-decorator': 'FormItem',
      'x-component': 'Switch',
    },
    array: {
      type: 'array',
      'x-decorator': 'FormItem',
      'x-component': 'ArrayTable',
      'x-component-props': {
        pagination: { pageSize: 10 },
        scroll: { x: '100%' },
      },
      items: {
        type: 'object',
        properties: {
          column1: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 50, title: 'Sort', align: 'center' },

            properties: {
              sort: {
                type: 'void',
                'x-component': 'ArrayTable.SortHandle',
              },
            },
          },
          column2: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 80, title: 'Index', align: 'center' },
            properties: {
              index: {
                type: 'void',
                'x-component': 'ArrayTable.Index',
              },
            },
          },
          column3: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 100, title: 'Explicitly hidden->A2' },
            properties: {
              a1: {
                type: 'boolean',
                'x-decorator': 'FormItem',
                'x-component': 'Switch',
              },
            },
          },
          column4: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 200, title: 'A2' },
            'x-reactions': [
              {
                dependencies: ['hideFirstColumn'],
                when: '{{$deps[0]}}',
                fulfill: {
                  schema: {
                    'x-visible': false,
                  },
                },
                otherwise: {
                  schema: {
                    'x-visible': true,
                  },
                },
              },
            ],
            properties: {
              a2: {
                type: 'string',
                'x-decorator': 'FormItem',
                'x-component': 'Input',
                required: true,
                'x-reactions': [
                  {
                    dependencies: ['.a1', 'hideFirstColumn'],
                    when: '{{$deps[1] || $deps[0]}}',
                    fulfill: {
                      schema: {
                        'x-visible': false,
                      },
                    },
                    otherwise: {
                      schema: {
                        'x-visible': true,
                      },
                    },
                  },
                ],
              },
            },
          },
          column5: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 200, title: 'A3' },
            properties: {
              a3: {
                type: 'string',
                required: true,
                'x-decorator': 'FormItem',
                'x-component': 'Input',
              },
            },
          },
          column6: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': {
              title: 'Operations',
              dataIndex: 'operations',
              width: 200,
              fixed: 'right',
            },
            properties: {
              item: {
                type: 'void',
                'x-component': 'FormItem',
                properties: {
                  remove: {
                    type: 'void',
                    'x-component': 'ArrayTable.Remove',
                  },
                  moveDown: {
                    type: 'void',
                    'x-component': 'ArrayTable.MoveDown',
                  },
                  moveUp: {
                    type: 'void',
                    'x-component': 'ArrayTable.MoveUp',
                  },
                },
              },
            },
          },
        },
      },
      properties: {
        add: {
          type: 'void',
          'x-component': 'ArrayTable.Addition',
          title: 'Add entry',
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} />
      <FormButtonGroup>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## Overwrite default behavior of build-in operations

```tsx
/**
 * title: Markup Schema
 */
import React from 'react'
import {
  FormItem,
  Input,
  ArrayTable,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { message } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    ArrayTable,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Array
          name="array"
          x-decorator="FormItem"
          x-component="ArrayTable"
          x-component-props={{
            pagination: { pageSize: 10 },
            scroll: { x: '100%' },
          }}
        >
          <SchemaField.Object>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{ width: 80, title: 'Index', align: 'center' }}
            >
              <SchemaField.Void
                x-decorator="FormItem"
                required
                x-component="ArrayTable.Index"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{ title: 'A1', width: 200 }}
            >
              <SchemaField.String
                x-decorator="FormItem"
                name="a1"
                required
                x-component="Input"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{ title: 'A2', width: 200 }}
            >
              <SchemaField.String
                x-decorator="FormItem"
                name="a2"
                required
                x-component="Input"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{
                title: 'Operations',
                dataIndex: 'operations',
                width: 200,
                fixed: 'right',
              }}
            >
              <SchemaField.Void x-component="FormItem">
                <SchemaField.Void
                  x-component="ArrayTable.Remove"
                  x-component-props={{
                    onClick: (e) => {
                      e.preventDefault()
                      message.info('remove is disabled!')
                    },
                  }}
                />
                <SchemaField.Void
                  x-component="ArrayTable.Copy"
                  x-component-props={{
                    onClick: (e) => {
                      e.preventDefault()
                      message.info('copy is disabled!')
                    },
                  }}
                />
                <SchemaField.Void
                  x-component="ArrayTable.MoveDown"
                  x-component-props={{
                    onClick: (e) => {
                      e.preventDefault()
                      message.info('moveDown is disabled!')
                    },
                  }}
                />
                <SchemaField.Void
                  x-component="ArrayTable.MoveUp"
                  x-component-props={{
                    onClick: (e) => {
                      e.preventDefault()
                      message.info('moveUp is disabled!')
                    },
                  }}
                />
              </SchemaField.Void>
            </SchemaField.Void>
          </SchemaField.Object>
          <SchemaField.Void
            x-component="ArrayTable.Addition"
            x-component-props={{
              onClick: (e) => {
                e.preventDefault()
                const base = form.values.array.length
                form.values.array.push(
                  { a1: base + 1 },
                  { a1: base + 2, a2: base + 2 }
                )
              },
            }}
            title="Add two entries"
          />
        </SchemaField.Array>
      </SchemaField>
      <FormButtonGroup>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

```tsx
/**
 * title: JSON Schema
 */
import React from 'react'
import {
  FormItem,
  Input,
  ArrayTable,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm, onFieldMount } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { message } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    ArrayTable,
  },
})

const form = createForm({
  effects() {
    onFieldMount('array.add', (field, form) => {
      field.componentProps.onClick = (e) => {
        e.preventDefault()
        const base = form.values.array.length
        form.values.array.push({ a1: base + 1 }, { a1: base + 2, a2: base + 2 })
      }
    })

    onFieldMount('array.*[0:].item.*', (field) => {
      field.componentProps.onClick = (e) => {
        e.preventDefault()
        message.info(`${field.address.segments.slice(-1)[0]} is disabled!`)
      }
    })
  },
})

const schema = {
  type: 'object',
  properties: {
    array: {
      type: 'array',
      'x-decorator': 'FormItem',
      'x-component': 'ArrayTable',
      'x-component-props': {
        pagination: { pageSize: 10 },
        scroll: { x: '100%' },
      },
      items: {
        type: 'object',
        properties: {
          column1: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 80, title: 'Index', align: 'center' },
            properties: {
              index: {
                type: 'void',
                'x-component': 'ArrayTable.Index',
              },
            },
          },
          column2: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 200, title: 'A1' },
            properties: {
              a1: {
                type: 'string',
                'x-decorator': 'FormItem',
                'x-component': 'Input',
              },
            },
          },
          column3: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 200, title: 'A2' },
            properties: {
              a2: {
                type: 'string',
                'x-decorator': 'FormItem',
                'x-component': 'Input',
              },
            },
          },
          column4: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': {
              title: 'Operations',
              dataIndex: 'operations',
              width: 200,
              fixed: 'right',
            },
            properties: {
              item: {
                type: 'void',
                'x-component': 'FormItem',
                properties: {
                  remove: {
                    type: 'void',
                    'x-component': 'ArrayTable.Remove',
                  },
                  moveDown: {
                    type: 'void',
                    'x-component': 'ArrayTable.MoveDown',
                  },
                  moveUp: {
                    type: 'void',
                    'x-component': 'ArrayTable.MoveUp',
                  },
                },
              },
            },
          },
        },
      },
      properties: {
        add: {
          type: 'void',
          'x-component': 'ArrayTable.Addition',
          title: 'Add two entries',
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} />
      <FormButtonGroup>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## API

### ArrayTable

> Form Components

Extended attributes

| Property name | Type                      | Description     | Default value |
| ------------- | ------------------------- | --------------- | ------------- |
| onAdd         | `(index: number) => void` | add method      |               |
| onRemove      | `(index: number) => void` | remove method   |               |
| onCopy        | `(index: number) => void` | copy method     |               |
| onMoveUp      | `(index: number) => void` | moveUp method   |               |
| onMoveDown    | `(index: number) => void` | moveDown method |               |

Other Reference https://ant.design/components/table-cn/

### ArrayTable.Column

> Table Column

Reference https://ant.design/components/table-cn/

### ArrayTable.SortHandle

> Drag handle

Reference https://ant.design/components/icon-cn/

### ArrayTable.Addition

> Add button

Extended attributes

| Property name | Type                 | Description   | Default value |
| ------------- | -------------------- | ------------- | ------------- |
| title         | ReactText            | Copywriting   |               |
| method        | `'push' \|'unshift'` | add method    | `'push'`      |
| defaultValue  | `any`                | Default value |               |

Other references https://ant.design/components/button-cn/

Note: The title attribute can receive the title mapping in the Field model, that is, uploading the title in the Field is also effective

Note: You can disable default behavior with `onClick={e => e.preventDefault()}` in props.

### ArrayTable.Remove

> Delete button

| Property name | Type      | Description | Default value |
| ------------- | --------- | ----------- | ------------- |
| title         | ReactText | Copywriting |               |

Other references https://ant.design/components/icon-cn/

Note: The title attribute can receive the title mapping in the Field model, that is, uploading the title in the Field is also effective

Note: You can disable default behavior with `onClick={e => e.preventDefault()}` in props.

### ArrayTable.Copy

> Copy button

| Property name | Type      | Description | Default value |
| ------------- | --------- | ----------- | ------------- |
| title         | ReactText | Copywriting |               |

Other references https://ant.design/components/icon-cn/

Note: The title attribute can receive the title mapping in the Field model, that is, uploading the title in the Field is also effective

Note: You can disable default behavior with `onClick={e => e.preventDefault()}` in props.

### ArrayTable.MoveDown

> Move down button

| Property name | Type      | Description | Default value |
| ------------- | --------- | ----------- | ------------- |
| title         | ReactText | Copywriting |               |

Other references https://ant.design/components/icon-cn/

Note: The title attribute can receive the title mapping in the Field model, that is, uploading the title in the Field is also effective

Note: You can disable default behavior with `onClick={e => e.preventDefault()}` in props.

### ArrayTable.MoveUp

> Move up button

| Property name | Type      | Description | Default value |
| ------------- | --------- | ----------- | ------------- |
| title         | ReactText | Copywriting |               |

Other references https://ant.design/components/icon-cn/

Note: The title attribute can receive the title mapping in the Field model, that is, uploading the title in the Field is also effective

Note: You can disable default behavior with `onClick={e => e.preventDefault()}` in props.

### ArrayTable.Index

> Index Renderer

No attributes

### ArrayTable.useIndex

> Read the React Hook of the current rendering row index

### ArrayTable.useRecord

> Read the React Hook of the current rendering row
</file>

<file path="packages/antd/docs/components/ArrayTable.zh-CN.md">
# ArrayTable

> 自增表格，对于数据量超大的场景比较适合使用该组件，虽然数据量大到一定程度会有些许卡顿，但是不会影响基本操作
>
> 注意：该组件只适用于 Schema 场景，且只能是对象数组

## Markup Schema 案例

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayTable,
  Editable,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Button, Alert } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Editable,
    Input,
    ArrayTable,
  },
})

const form = createForm()

const range = (count: number) =>
  Array.from(new Array(count)).map((_, key) => ({
    aaa: key,
  }))

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Array
          name="array"
          x-decorator="FormItem"
          x-component="ArrayTable"
          x-component-props={{
            pagination: { pageSize: 10 },
            scroll: { x: '100%' },
          }}
        >
          <SchemaField.Object>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{ width: 50, title: 'Sort', align: 'center' }}
            >
              <SchemaField.Void
                x-decorator="FormItem"
                required
                x-component="ArrayTable.SortHandle"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{ width: 80, title: 'Index', align: 'center' }}
            >
              <SchemaField.Void
                x-decorator="FormItem"
                required
                x-component="ArrayTable.Index"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{ title: 'A1', dataIndex: 'a1', width: 200 }}
            >
              <SchemaField.String
                name="a1"
                x-decorator="Editable"
                required
                x-component="Input"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{ title: 'A2', width: 200 }}
            >
              <SchemaField.String
                x-decorator="FormItem"
                name="a2"
                required
                x-component="Input"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{ title: 'A3', width: 200 }}
            >
              <SchemaField.String
                x-decorator="FormItem"
                name="a3"
                required
                x-component="Input"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{
                title: 'Operations',
                dataIndex: 'operations',
                width: 200,
                fixed: 'right',
              }}
            >
              <SchemaField.Void x-component="FormItem">
                <SchemaField.Void x-component="ArrayTable.Remove" />
                <SchemaField.Void x-component="ArrayTable.MoveDown" />
                <SchemaField.Void x-component="ArrayTable.MoveUp" />
              </SchemaField.Void>
            </SchemaField.Void>
          </SchemaField.Object>
          <SchemaField.Void
            x-component="ArrayTable.Addition"
            title="添加条目"
          />
        </SchemaField.Array>
      </SchemaField>
      <FormButtonGroup>
        <Submit onSubmit={console.log}>提交</Submit>
        <Button
          block
          onClick={() => {
            form.setInitialValues({
              array: range(100000),
            })
          }}
        >
          加载10W条超大数据
        </Button>
      </FormButtonGroup>
      <Alert
        style={{ marginTop: 10 }}
        message="注意：开启formily插件的页面，因为后台有数据通信，会占用浏览器算力，最好在无痕模式(无formily插件)下测试"
        type="warning"
      />
    </FormProvider>
  )
}
```

## JSON Schema 案例

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayTable,
  Editable,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Editable,
    Input,
    ArrayTable,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    array: {
      type: 'array',
      'x-decorator': 'FormItem',
      'x-component': 'ArrayTable',
      'x-component-props': {
        pagination: { pageSize: 10 },
        scroll: { x: '100%' },
      },
      items: {
        type: 'object',
        properties: {
          column1: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 50, title: 'Sort', align: 'center' },
            properties: {
              sort: {
                type: 'void',
                'x-component': 'ArrayTable.SortHandle',
              },
            },
          },
          column2: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 80, title: 'Index', align: 'center' },
            properties: {
              index: {
                type: 'void',
                'x-component': 'ArrayTable.Index',
              },
            },
          },
          column3: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 200, title: 'A1' },
            properties: {
              a1: {
                type: 'string',
                'x-decorator': 'Editable',
                'x-component': 'Input',
              },
            },
          },
          column4: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 200, title: 'A2' },
            properties: {
              a2: {
                type: 'string',
                'x-decorator': 'FormItem',
                'x-component': 'Input',
              },
            },
          },
          column5: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 200, title: 'A3' },
            properties: {
              a3: {
                type: 'string',
                'x-decorator': 'FormItem',
                'x-component': 'Input',
              },
            },
          },
          column6: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': {
              title: 'Operations',
              dataIndex: 'operations',
              width: 200,
              fixed: 'right',
            },
            properties: {
              item: {
                type: 'void',
                'x-component': 'FormItem',
                properties: {
                  remove: {
                    type: 'void',
                    'x-component': 'ArrayTable.Remove',
                  },
                  moveDown: {
                    type: 'void',
                    'x-component': 'ArrayTable.MoveDown',
                  },
                  moveUp: {
                    type: 'void',
                    'x-component': 'ArrayTable.MoveUp',
                  },
                },
              },
            },
          },
        },
      },
      properties: {
        add: {
          type: 'void',
          'x-component': 'ArrayTable.Addition',
          title: '添加条目',
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} />
      <FormButtonGroup>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## Effects 联动案例

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayTable,
  Switch,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm, onFieldChange, onFieldReact } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Button } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Switch,
    Input,
    Button,
    ArrayTable,
  },
})

const form = createForm({
  effects: () => {
    //主动联动模式
    onFieldChange('hideFirstColumn', ['value'], (field) => {
      field.query('array.column4').take((target) => {
        target.visible = !field.value
      })
      field.query('array.*.a2').take((target) => {
        target.visible = !field.value
      })
    })
    //被动联动模式
    onFieldReact('array.*.a2', (field) => {
      field.visible = !field.query('.a1').get('value')
    })
  },
})

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Boolean
          name="hideFirstColumn"
          x-decorator="FormItem"
          x-component="Switch"
          title="隐藏A2"
        />
        <SchemaField.Array
          name="array"
          x-decorator="FormItem"
          x-component="ArrayTable"
          x-component-props={{
            pagination: { pageSize: 10 },
            scroll: { x: '100%' },
          }}
        >
          <SchemaField.Object>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              name="column1"
              x-component-props={{ width: 50, title: 'Sort', align: 'center' }}
            >
              <SchemaField.Void
                x-decorator="FormItem"
                required
                x-component="ArrayTable.SortHandle"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              name="column2"
              x-component-props={{ width: 80, title: 'Index', align: 'center' }}
            >
              <SchemaField.String
                x-decorator="FormItem"
                required
                x-component="ArrayTable.Index"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              name="column3"
              x-component-props={{
                title: '显隐->A2',
                dataIndex: 'a1',
                width: 100,
              }}
            >
              <SchemaField.Boolean
                name="a1"
                x-decorator="FormItem"
                required
                x-component="Switch"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              name="column4"
              x-component-props={{ title: 'A2', width: 200 }}
            >
              <SchemaField.String
                x-decorator="FormItem"
                name="a2"
                required
                x-component="Input"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              name="column5"
              x-component-props={{ title: 'A3', width: 200 }}
            >
              <SchemaField.String
                x-decorator="FormItem"
                name="a3"
                required
                x-component="Input"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              name="column6"
              x-component-props={{
                title: 'Operations',
                dataIndex: 'operations',
                width: 200,
                fixed: 'right',
              }}
            >
              <SchemaField.Void x-component="FormItem">
                <SchemaField.Void x-component="ArrayTable.Remove" />
                <SchemaField.Void x-component="ArrayTable.MoveDown" />
                <SchemaField.Void x-component="ArrayTable.MoveUp" />
              </SchemaField.Void>
            </SchemaField.Void>
          </SchemaField.Object>
          <SchemaField.Void
            x-component="ArrayTable.Addition"
            title="添加条目"
          />
        </SchemaField.Array>
      </SchemaField>
      <FormButtonGroup>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## JSON Schema 联动案例

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayTable,
  Switch,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Switch,
    Input,
    ArrayTable,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    hideFirstColumn: {
      type: 'boolean',
      title: '隐藏A2',
      'x-decorator': 'FormItem',
      'x-component': 'Switch',
    },
    array: {
      type: 'array',
      'x-decorator': 'FormItem',
      'x-component': 'ArrayTable',
      'x-component-props': {
        pagination: { pageSize: 10 },
        scroll: { x: '100%' },
      },
      items: {
        type: 'object',
        properties: {
          column1: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 50, title: 'Sort', align: 'center' },

            properties: {
              sort: {
                type: 'void',
                'x-component': 'ArrayTable.SortHandle',
              },
            },
          },
          column2: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 80, title: 'Index', align: 'center' },
            properties: {
              index: {
                type: 'void',
                'x-component': 'ArrayTable.Index',
              },
            },
          },
          column3: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 100, title: '显隐->A2' },
            properties: {
              a1: {
                type: 'boolean',
                'x-decorator': 'FormItem',
                'x-component': 'Switch',
              },
            },
          },
          column4: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 200, title: 'A2' },
            'x-reactions': [
              {
                dependencies: ['hideFirstColumn'],
                when: '{{$deps[0]}}',
                fulfill: {
                  schema: {
                    'x-visible': false,
                  },
                },
                otherwise: {
                  schema: {
                    'x-visible': true,
                  },
                },
              },
            ],
            properties: {
              a2: {
                type: 'string',
                'x-decorator': 'FormItem',
                'x-component': 'Input',
                required: true,
                'x-reactions': [
                  {
                    dependencies: ['.a1', 'hideFirstColumn'],
                    when: '{{$deps[1] || $deps[0]}}',
                    fulfill: {
                      schema: {
                        'x-visible': false,
                      },
                    },
                    otherwise: {
                      schema: {
                        'x-visible': true,
                      },
                    },
                  },
                ],
              },
            },
          },
          column5: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 200, title: 'A3' },
            properties: {
              a3: {
                type: 'string',
                required: true,
                'x-decorator': 'FormItem',
                'x-component': 'Input',
              },
            },
          },
          column6: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': {
              title: 'Operations',
              dataIndex: 'operations',
              width: 200,
              fixed: 'right',
            },
            properties: {
              item: {
                type: 'void',
                'x-component': 'FormItem',
                properties: {
                  remove: {
                    type: 'void',
                    'x-component': 'ArrayTable.Remove',
                  },
                  moveDown: {
                    type: 'void',
                    'x-component': 'ArrayTable.MoveDown',
                  },
                  moveUp: {
                    type: 'void',
                    'x-component': 'ArrayTable.MoveUp',
                  },
                },
              },
            },
          },
        },
      },
      properties: {
        add: {
          type: 'void',
          'x-component': 'ArrayTable.Addition',
          title: '添加条目',
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} />
      <FormButtonGroup>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## 重写内置操作项的默认行为

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayTable,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { message } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    ArrayTable,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Array
          name="array"
          x-decorator="FormItem"
          x-component="ArrayTable"
          x-component-props={{
            pagination: { pageSize: 10 },
            scroll: { x: '100%' },
          }}
        >
          <SchemaField.Object>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{ width: 80, title: 'Index', align: 'center' }}
            >
              <SchemaField.Void
                x-decorator="FormItem"
                required
                x-component="ArrayTable.Index"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{ title: 'A1', width: 200 }}
            >
              <SchemaField.String
                x-decorator="FormItem"
                name="a1"
                required
                x-component="Input"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{ title: 'A2', width: 200 }}
            >
              <SchemaField.String
                x-decorator="FormItem"
                name="a2"
                required
                x-component="Input"
              />
            </SchemaField.Void>
            <SchemaField.Void
              x-component="ArrayTable.Column"
              x-component-props={{
                title: 'Operations',
                dataIndex: 'operations',
                width: 200,
                fixed: 'right',
              }}
            >
              <SchemaField.Void x-component="FormItem">
                <SchemaField.Void
                  x-component="ArrayTable.Remove"
                  x-component-props={{
                    onClick: (e) => {
                      e.preventDefault()
                      message.info('remove 已被禁用!')
                    },
                  }}
                />
                <SchemaField.Void
                  x-component="ArrayTable.Copy"
                  x-component-props={{
                    onClick: (e) => {
                      e.preventDefault()
                      message.info('copy 已被禁用!')
                    },
                  }}
                />
                <SchemaField.Void
                  x-component="ArrayTable.MoveDown"
                  x-component-props={{
                    onClick: (e) => {
                      e.preventDefault()
                      message.info('moveDown 已被禁用!')
                    },
                  }}
                />
                <SchemaField.Void
                  x-component="ArrayTable.MoveUp"
                  x-component-props={{
                    onClick: (e) => {
                      e.preventDefault()
                      message.info('moveUp 已被禁用!')
                    },
                  }}
                />
              </SchemaField.Void>
            </SchemaField.Void>
          </SchemaField.Object>
          <SchemaField.Void
            x-component="ArrayTable.Addition"
            x-component-props={{
              onClick: (e) => {
                e.preventDefault()
                const base = form.values.array.length
                form.values.array.push(
                  { a1: base + 1 },
                  { a1: base + 2, a2: base + 2 }
                )
              },
            }}
            title="添加2个条目"
          />
        </SchemaField.Array>
      </SchemaField>
      <FormButtonGroup>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

```tsx
/**
 * title: JSON Schema
 */
import React from 'react'
import {
  FormItem,
  Input,
  ArrayTable,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm, onFieldMount } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { message } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    ArrayTable,
  },
})

const form = createForm({
  effects() {
    onFieldMount('array.add', (field, form) => {
      field.componentProps.onClick = (e) => {
        e.preventDefault()
        const base = form.values.array.length
        form.values.array.push({ a1: base + 1 }, { a1: base + 2, a2: base + 2 })
      }
    })

    onFieldMount('array.*[0:].item.*', (field) => {
      field.componentProps.onClick = (e) => {
        e.preventDefault()
        message.info(`${field.address.segments.slice(-1)[0]} 已被禁用!`)
      }
    })
  },
})

const schema = {
  type: 'object',
  properties: {
    array: {
      type: 'array',
      'x-decorator': 'FormItem',
      'x-component': 'ArrayTable',
      'x-component-props': {
        pagination: { pageSize: 10 },
        scroll: { x: '100%' },
      },
      items: {
        type: 'object',
        properties: {
          column1: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 80, title: 'Index', align: 'center' },
            properties: {
              index: {
                type: 'void',
                'x-component': 'ArrayTable.Index',
              },
            },
          },
          column2: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 200, title: 'A1' },
            properties: {
              a1: {
                type: 'string',
                'x-decorator': 'FormItem',
                'x-component': 'Input',
              },
            },
          },
          column3: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': { width: 200, title: 'A2' },
            properties: {
              a2: {
                type: 'string',
                'x-decorator': 'FormItem',
                'x-component': 'Input',
              },
            },
          },
          column4: {
            type: 'void',
            'x-component': 'ArrayTable.Column',
            'x-component-props': {
              title: 'Operations',
              dataIndex: 'operations',
              width: 200,
              fixed: 'right',
            },
            properties: {
              item: {
                type: 'void',
                'x-component': 'FormItem',
                properties: {
                  remove: {
                    type: 'void',
                    'x-component': 'ArrayTable.Remove',
                  },
                  copy: {
                    type: 'void',
                    'x-component': 'ArrayTable.Copy',
                  },
                  moveDown: {
                    type: 'void',
                    'x-component': 'ArrayTable.MoveDown',
                  },
                  moveUp: {
                    type: 'void',
                    'x-component': 'ArrayTable.MoveUp',
                  },
                },
              },
            },
          },
        },
      },
      properties: {
        add: {
          type: 'void',
          'x-component': 'ArrayTable.Addition',
          title: '添加2个条目',
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} />
      <FormButtonGroup>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## API

### ArrayTable

> 表格组件

扩展属性

| 属性名     | 类型                      | 描述         | 默认值 |
| ---------- | ------------------------- | ------------ | ------ |
| onAdd      | `(index: number) => void` | 增加方法     |        |
| onRemove   | `(index: number) => void` | 删除方法     |        |
| onCopy     | `(index: number) => void` | 复制方法     |        |
| onMoveUp   | `(index: number) => void` | 向上移动方法 |        |
| onMoveDown | `(index: number) => void` | 向下移动方法 |        |

其余参考 https://ant.design/components/table-cn/

### ArrayTable.Column

> 表格列

参考 https://ant.design/components/table-cn/

### ArrayTable.SortHandle

> 拖拽手柄

参考 https://ant.design/components/icon-cn/

### ArrayTable.Addition

> 添加按钮

扩展属性

| 属性名       | 类型                  | 描述     | 默认值   |
| ------------ | --------------------- | -------- | -------- |
| title        | ReactText             | 文案     |          |
| method       | `'push' \| 'unshift'` | 添加方式 | `'push'` |
| defaultValue | `any`                 | 默认值   |          |

其余参考 https://ant.design/components/button-cn/

注意：title 属性可以接收 Field 模型中的 title 映射，也就是在 Field 上传 title 也是生效的

注意：使用`onClick={e => e.preventDefault()}`可禁用默认行为。

### ArrayTable.Remove

> 删除按钮

| 属性名 | 类型      | 描述 | 默认值 |
| ------ | --------- | ---- | ------ |
| title  | ReactText | 文案 |        |

其余参考 https://ant.design/components/icon-cn/

注意：title 属性可以接收 Field 模型中的 title 映射，也就是在 Field 上传 title 也是生效的

注意：使用`onClick={e => e.preventDefault()}`可禁用默认行为。

### ArrayTable.Copy

> 复制按钮

| 属性名 | 类型      | 描述 | 默认值 |
| ------ | --------- | ---- | ------ |
| title  | ReactText | 文案 |        |

其余参考 https://ant.design/components/icon-cn/

注意：title 属性可以接收 Field 模型中的 title 映射，也就是在 Field 上传 title 也是生效的

注意：使用`onClick={e => e.preventDefault()}`可禁用默认行为。

### ArrayTable.MoveDown

> 下移按钮

| 属性名 | 类型      | 描述 | 默认值 |
| ------ | --------- | ---- | ------ |
| title  | ReactText | 文案 |        |

其余参考 https://ant.design/components/icon-cn/

注意：title 属性可以接收 Field 模型中的 title 映射，也就是在 Field 上传 title 也是生效的

注意：使用`onClick={e => e.preventDefault()}`可禁用默认行为。

### ArrayTable.MoveUp

> 上移按钮

| 属性名 | 类型      | 描述 | 默认值 |
| ------ | --------- | ---- | ------ |
| title  | ReactText | 文案 |        |

其余参考 https://ant.design/components/icon-cn/

注意：title 属性可以接收 Field 模型中的 title 映射，也就是在 Field 上传 title 也是生效的

注意：使用`onClick={e => e.preventDefault()}`可禁用默认行为。

### ArrayTable.Index

> 索引渲染器

无属性

### ArrayTable.useIndex

> 读取当前渲染行索引的 React Hook

### ArrayTable.useRecord

> 读取当前渲染记录的 React Hook
</file>

<file path="packages/antd/docs/components/ArrayTabs.md">
# ArrayTabs

> Self-increasing tab, you can consider using this component for scenarios with high vertical space requirements
>
> Note: This component is only applicable to Schema scenarios, please avoid cross-tab linkage in interaction

## Markup Schema example

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayTabs,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    ArrayTabs,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Array
          name="string_array"
          x-decorator="FormItem"
          title="string array"
          maxItems={3}
          x-component="ArrayTabs"
        >
          <SchemaField.String
            x-decorator="FormItem"
            required
            x-component="Input"
          />
        </SchemaField.Array>
        <SchemaField.Array
          name="array"
          x-decorator="FormItem"
          title="Object array"
          maxItems={3}
          x-component="ArrayTabs"
        >
          <SchemaField.Object>
            <SchemaField.String
              x-decorator="FormItem"
              title="AAA"
              name="aaa"
              required
              x-component="Input"
            />
            <SchemaField.String
              x-decorator="FormItem"
              title="BBB"
              name="bbb"
              required
              x-component="Input"
            />
          </SchemaField.Object>
        </SchemaField.Array>
      </SchemaField>
      <FormButtonGroup>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## JSON Schema case

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayTabs,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    ArrayTabs,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    string_array: {
      type: 'array',
      title: 'String array',
      'x-decorator': 'FormItem',
      maxItems: 3,
      'x-component': 'ArrayTabs',
      items: {
        type: 'string',
        'x-decorator': 'FormItem',
        required: true,
        'x-component': 'Input',
      },
    },
    array: {
      type: 'array',
      title: 'Object array',
      'x-decorator': 'FormItem',
      maxItems: 3,
      'x-component': 'ArrayTabs',
      items: {
        type: 'object',
        properties: {
          aaa: {
            type: 'string',
            'x-decorator': 'FormItem',
            title: 'AAA',
            required: true,
            'x-component': 'Input',
          },
          bbb: {
            type: 'string',
            'x-decorator': 'FormItem',
            title: 'BBB',
            required: true,
            'x-component': 'Input',
          },
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} />
      <FormButtonGroup>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## API

### ArrayTabs

Reference https://ant.design/components/tabs-cn/
</file>

<file path="packages/antd/docs/components/ArrayTabs.zh-CN.md">
# ArrayTabs

> 自增选项卡，对于纵向空间要求较高的场景可以考虑使用该组件
>
> 注意：该组件只适用于 Schema 场景，交互上请避免跨 Tab 联动

## Markup Schema 案例

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayTabs,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    ArrayTabs,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Array
          name="string_array"
          x-decorator="FormItem"
          title="字符串数组"
          maxItems={3}
          x-component="ArrayTabs"
        >
          <SchemaField.String
            x-decorator="FormItem"
            required
            x-component="Input"
          />
        </SchemaField.Array>
        <SchemaField.Array
          name="array"
          x-decorator="FormItem"
          title="对象数组"
          maxItems={3}
          x-component="ArrayTabs"
        >
          <SchemaField.Object>
            <SchemaField.String
              x-decorator="FormItem"
              title="AAA"
              name="aaa"
              required
              x-component="Input"
            />
            <SchemaField.String
              x-decorator="FormItem"
              title="BBB"
              name="bbb"
              required
              x-component="Input"
            />
          </SchemaField.Object>
        </SchemaField.Array>
      </SchemaField>
      <FormButtonGroup>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## JSON Schema 案例

```tsx
import React from 'react'
import {
  FormItem,
  Input,
  ArrayTabs,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    ArrayTabs,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    string_array: {
      type: 'array',
      title: '字符串数组',
      'x-decorator': 'FormItem',
      maxItems: 3,
      'x-component': 'ArrayTabs',
      items: {
        type: 'string',
        'x-decorator': 'FormItem',
        required: true,
        'x-component': 'Input',
      },
    },
    array: {
      type: 'array',
      title: '对象数组',
      'x-decorator': 'FormItem',
      maxItems: 3,
      'x-component': 'ArrayTabs',
      items: {
        type: 'object',
        properties: {
          aaa: {
            type: 'string',
            'x-decorator': 'FormItem',
            title: 'AAA',
            required: true,
            'x-component': 'Input',
          },
          bbb: {
            type: 'string',
            'x-decorator': 'FormItem',
            title: 'BBB',
            required: true,
            'x-component': 'Input',
          },
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} />
      <FormButtonGroup>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup>
    </FormProvider>
  )
}
```

## API

### ArrayTabs

参考 https://ant.design/components/tabs-cn/
</file>

<file path="packages/antd/docs/components/Cascader.md">
# Cascader

> Cascade selector

## Markup Schema example

```tsx
import React from 'react'
import { Cascader, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm, onFieldReact, FormPathPattern } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { action } from '@formily/reactive'

const SchemaField = createSchemaField({
  components: {
    Cascader,
    FormItem,
  },
})

const useAddress = (pattern: FormPathPattern) => {
  const transform = (data = {}) => {
    return Object.entries(data).reduce((buf, [key, value]) => {
      if (typeof value === 'string')
        return buf.concat({
          label: value,
          value: key,
        })
      const { name, code, cities, districts } = value
      const _cities = transform(cities)
      const _districts = transform(districts)
      return buf.concat({
        label: name,
        value: code,
        children: _cities.length
          ? _cities
          : _districts.length
          ? _districts
          : undefined,
      })
    }, [])
  }
  onFieldReact(pattern, (field) => {
    field.loading = true
    fetch('//unpkg.com/china-location/dist/location.json')
      .then((res) => res.json())
      .then(
        action.bound((data) => {
          field.dataSource = transform(data)
          field.loading = false
        })
      )
  })
}

const form = createForm({
  effects: () => {
    useAddress('address')
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="address"
        title="Address Selection"
        required
        x-decorator="FormItem"
        x-component="Cascader"
        x-component-props={{
          style: {
            width: 240,
          },
        }}
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema case

```tsx
import React from 'react'
import { Cascader, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { action } from '@formily/reactive'

const SchemaField = createSchemaField({
  components: {
    Cascader,
    FormItem,
  },
})

const transformAddress = (data = {}) => {
  return Object.entries(data).reduce((buf, [key, value]) => {
    if (typeof value === 'string')
      return buf.concat({
        label: value,
        value: key,
      })
    const { name, code, cities, districts } = value
    const _cities = transformAddress(cities)
    const _districts = transformAddress(districts)
    return buf.concat({
      label: name,
      value: code,
      children: _cities.length
        ? _cities
        : _districts.length
        ? _districts
        : undefined,
    })
  }, [])
}

const useAsyncDataSource =
  (url: string, transform: (data: any) => any) => (field) => {
    field.loading = true
    fetch(url)
      .then((res) => res.json())
      .then(
        action.bound((data) => {
          field.dataSource = transform(data)
          field.loading = false
        })
      )
  }

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    address: {
      type: 'string',
      title: 'Address Selection',
      'x-decorator': 'FormItem',
      'x-component': 'Cascader',
      'x-component-props': {
        style: {
          width: 240,
        },
      },
      'x-reactions': [
        '{{useAsyncDataSource("//unpkg.com/china-location/dist/location.json",transformAddress)}}',
      ],
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField
      schema={schema}
      scope={{ useAsyncDataSource, transformAddress }}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## Pure JSX case

```tsx
import React from 'react'
import { Cascader, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm, onFieldReact, FormPathPattern } from '@formily/core'
import { FormProvider, Field } from '@formily/react'
import { action } from '@formily/reactive'

const useAddress = (pattern: FormPathPattern) => {
  const transform = (data = {}) => {
    return Object.entries(data).reduce((buf, [key, value]) => {
      if (typeof value === 'string')
        return buf.concat({
          label: value,
          value: key,
        })
      const { name, code, cities, districts } = value
      const _cities = transform(cities)
      const _districts = transform(districts)
      return buf.concat({
        label: name,
        value: code,
        children: _cities.length
          ? _cities
          : _districts.length
          ? _districts
          : undefined,
      })
    }, [])
  }
  onFieldReact(pattern, (field) => {
    field.loading = true
    fetch('//unpkg.com/china-location/dist/location.json')
      .then((res) => res.json())
      .then(
        action.bound((data) => {
          field.dataSource = transform(data)
          field.loading = false
        })
      )
  })
}

const form = createForm({
  effects: () => {
    useAddress('address')
  },
})

export default () => (
  <FormProvider form={form}>
    <Field
      name="address"
      title="Address Selection"
      decorator={[FormItem]}
      component={[
        Cascader,
        {
          style: {
            width: 240,
          },
        },
      ]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

Reference https://ant.design/components/cascader-cn/
</file>

<file path="packages/antd/docs/components/Cascader.zh-CN.md">
# Cascader

> 联级选择器

## Markup Schema 案例

```tsx
import React from 'react'
import { Cascader, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm, onFieldReact, FormPathPattern } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { action } from '@formily/reactive'

const SchemaField = createSchemaField({
  components: {
    Cascader,
    FormItem,
  },
})

const useAddress = (pattern: FormPathPattern) => {
  const transform = (data = {}) => {
    return Object.entries(data).reduce((buf, [key, value]) => {
      if (typeof value === 'string')
        return buf.concat({
          label: value,
          value: key,
        })
      const { name, code, cities, districts } = value
      const _cities = transform(cities)
      const _districts = transform(districts)
      return buf.concat({
        label: name,
        value: code,
        children: _cities.length
          ? _cities
          : _districts.length
          ? _districts
          : undefined,
      })
    }, [])
  }
  onFieldReact(pattern, (field) => {
    field.loading = true
    fetch('//unpkg.com/china-location/dist/location.json')
      .then((res) => res.json())
      .then(
        action.bound((data) => {
          field.dataSource = transform(data)
          field.loading = false
        })
      )
  })
}

const form = createForm({
  effects: () => {
    useAddress('address')
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="address"
        title="地址选择"
        required
        x-decorator="FormItem"
        x-component="Cascader"
        x-component-props={{
          style: {
            width: 240,
          },
        }}
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema 案例

```tsx
import React from 'react'
import { Cascader, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { action } from '@formily/reactive'

const SchemaField = createSchemaField({
  components: {
    Cascader,
    FormItem,
  },
})

const transformAddress = (data = {}) => {
  return Object.entries(data).reduce((buf, [key, value]) => {
    if (typeof value === 'string')
      return buf.concat({
        label: value,
        value: key,
      })
    const { name, code, cities, districts } = value
    const _cities = transformAddress(cities)
    const _districts = transformAddress(districts)
    return buf.concat({
      label: name,
      value: code,
      children: _cities.length
        ? _cities
        : _districts.length
        ? _districts
        : undefined,
    })
  }, [])
}

const useAsyncDataSource =
  (url: string, transform: (data: any) => any) => (field) => {
    field.loading = true
    fetch(url)
      .then((res) => res.json())
      .then(
        action.bound((data) => {
          field.dataSource = transform(data)
          field.loading = false
        })
      )
  }

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    address: {
      type: 'string',
      title: '地址选择',
      'x-decorator': 'FormItem',
      'x-component': 'Cascader',
      'x-component-props': {
        style: {
          width: 240,
        },
      },
      'x-reactions': [
        '{{useAsyncDataSource("//unpkg.com/china-location/dist/location.json",transformAddress)}}',
      ],
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField
      schema={schema}
      scope={{ useAsyncDataSource, transformAddress }}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## 纯 JSX 案例

```tsx
import React from 'react'
import { Cascader, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm, onFieldReact, FormPathPattern } from '@formily/core'
import { FormProvider, Field } from '@formily/react'
import { action } from '@formily/reactive'

const useAddress = (pattern: FormPathPattern) => {
  const transform = (data = {}) => {
    return Object.entries(data).reduce((buf, [key, value]) => {
      if (typeof value === 'string')
        return buf.concat({
          label: value,
          value: key,
        })
      const { name, code, cities, districts } = value
      const _cities = transform(cities)
      const _districts = transform(districts)
      return buf.concat({
        label: name,
        value: code,
        children: _cities.length
          ? _cities
          : _districts.length
          ? _districts
          : undefined,
      })
    }, [])
  }
  onFieldReact(pattern, (field) => {
    field.loading = true
    fetch('//unpkg.com/china-location/dist/location.json')
      .then((res) => res.json())
      .then(
        action.bound((data) => {
          field.dataSource = transform(data)
          field.loading = false
        })
      )
  })
}

const form = createForm({
  effects: () => {
    useAddress('address')
  },
})

export default () => (
  <FormProvider form={form}>
    <Field
      name="address"
      title="地址选择"
      decorator={[FormItem]}
      component={[
        Cascader,
        {
          style: {
            width: 240,
          },
        },
      ]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

参考 https://ant.design/components/cascader-cn/
</file>

<file path="packages/antd/docs/components/Checkbox.md">
# Checkbox

> Checkbox

## Markup Schema example

```tsx
import React from 'react'
import { Checkbox, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Checkbox,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Boolean
        name="single"
        title="Are you sure"
        x-decorator="FormItem"
        x-component="Checkbox"
      />
      <SchemaField.String
        name="multiple"
        title="Check"
        enum={[
          {
            label: 'Option 1',
            value: 1,
          },
          {
            label: 'Option 2',
            value: 2,
          },
        ]}
        x-decorator="FormItem"
        x-component="Checkbox.Group"
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema case

```tsx
import React from 'react'
import { Checkbox, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Checkbox,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    single: {
      type: 'boolean',
      title: 'Are you sure?',
      'x-decorator': 'FormItem',
      'x-component': 'Checkbox',
    },
    multiple: {
      type: 'array',
      title: 'Check',
      enum: [
        {
          label: 'Option 1',
          value: 1,
        },
        {
          label: 'Option 2',
          value: 2,
        },
      ],
      'x-decorator': 'FormItem',
      'x-component': 'Checkbox.Group',
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## Pure JSX case

```tsx
import React from 'react'
import { Checkbox, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="single"
      title="Are you sure"
      decorator={[FormItem]}
      component={[Checkbox]}
    />
    <Field
      name="multiple"
      title="Check"
      dataSource={[
        {
          label: 'Option 1',
          value: 1,
        },
        {
          label: 'Option 2',
          value: 2,
        },
      ]}
      decorator={[FormItem]}
      component={[Checkbox.Group]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

Reference https://ant.design/components/checkbox-cn/
</file>

<file path="packages/antd/docs/components/Checkbox.zh-CN.md">
# Checkbox

> 复选框

## Markup Schema 案例

```tsx
import React from 'react'
import { Checkbox, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Checkbox,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Boolean
        name="single"
        title="是否确认"
        x-decorator="FormItem"
        x-component="Checkbox"
      />
      <SchemaField.String
        name="multiple"
        title="复选"
        enum={[
          {
            label: '选项1',
            value: 1,
          },
          {
            label: '选项2',
            value: 2,
          },
        ]}
        x-decorator="FormItem"
        x-component="Checkbox.Group"
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema 案例

```tsx
import React from 'react'
import { Checkbox, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Checkbox,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    single: {
      type: 'boolean',
      title: '是否确认',
      'x-decorator': 'FormItem',
      'x-component': 'Checkbox',
    },
    multiple: {
      type: 'array',
      title: '复选',
      enum: [
        {
          label: '选项1',
          value: 1,
        },
        {
          label: '选项2',
          value: 2,
        },
      ],
      'x-decorator': 'FormItem',
      'x-component': 'Checkbox.Group',
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## 纯 JSX 案例

```tsx
import React from 'react'
import { Checkbox, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="single"
      title="是否确认"
      decorator={[FormItem]}
      component={[Checkbox]}
    />
    <Field
      name="multiple"
      title="复选"
      dataSource={[
        {
          label: '选项1',
          value: 1,
        },
        {
          label: '选项2',
          value: 2,
        },
      ]}
      decorator={[FormItem]}
      component={[Checkbox.Group]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

参考 https://ant.design/components/checkbox-cn/
</file>

<file path="packages/antd/docs/components/DatePicker.md">
# DatePicker

> Date Picker

## Markup Schema example

```tsx
import React from 'react'
import { DatePicker, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    DatePicker,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="date"
        required
        title="normal date"
        x-decorator="FormItem"
        x-component="DatePicker"
      />
      <SchemaField.String
        name="week"
        title="Week Selection"
        x-decorator="FormItem"
        x-component="DatePicker"
        x-component-props={{
          picker: 'week',
        }}
      />
      <SchemaField.String
        name="month"
        title="Month Selection"
        x-decorator="FormItem"
        x-component="DatePicker"
        x-component-props={{
          picker: 'month',
        }}
      />
      <SchemaField.String
        name="quarter"
        title="Financial Year Selection"
        x-decorator="FormItem"
        x-component="DatePicker"
        x-component-props={{
          picker: 'quarter',
        }}
      />
      <SchemaField.String
        name="year"
        title="Year selection"
        x-decorator="FormItem"
        x-component="DatePicker"
        x-component-props={{
          picker: 'year',
        }}
      />
      <SchemaField.String
        name="[startDate,endDate]"
        title="Date Range"
        x-decorator="FormItem"
        x-component="DatePicker.RangePicker"
        x-component-props={{
          showTime: true,
        }}
      />
      <SchemaField.String
        name="range_week"
        title="Week range selection"
        x-decorator="FormItem"
        x-component="DatePicker.RangePicker"
        x-component-props={{
          picker: 'week',
        }}
      />
      <SchemaField.String
        name="range_month"
        title="Month Range Selection"
        x-decorator="FormItem"
        x-component="DatePicker.RangePicker"
        x-component-props={{
          picker: 'month',
        }}
      />
      <SchemaField.String
        name="range_quarter"
        title="Financial Year Range Selection"
        x-decorator="FormItem"
        x-component="DatePicker.RangePicker"
        x-component-props={{
          picker: 'quarter',
        }}
      />
      <SchemaField.String
        name="range_year"
        title="Year range selection"
        x-decorator="FormItem"
        x-component="DatePicker.RangePicker"
        x-component-props={{
          picker: 'year',
        }}
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema case

```tsx
import React from 'react'
import { DatePicker, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    DatePicker,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    date: {
      title: 'Normal date',
      'x-decorator': 'FormItem',
      'x-component': 'DatePicker',
      type: 'string',
    },
    week: {
      title: 'Week Selection',
      'x-decorator': 'FormItem',
      'x-component': 'DatePicker',
      'x-component-props': {
        picker: 'week',
      },
      type: 'string',
    },
    month: {
      title: 'Month Selection',
      'x-decorator': 'FormItem',
      'x-component': 'DatePicker',
      'x-component-props': {
        picker: 'month',
      },
      type: 'string',
    },
    quarter: {
      title: 'Fiscal Year Selection',
      'x-decorator': 'FormItem',
      'x-component': 'DatePicker',
      'x-component-props': {
        picker: 'quarter',
      },
      type: 'string',
    },
    year: {
      title: 'Year selection',
      'x-decorator': 'FormItem',
      'x-component': 'DatePicker',
      'x-component-props': {
        picker: 'year',
      },
      type: 'string',
    },
    '[startDate,endDate]': {
      title: 'Date range',
      'x-decorator': 'FormItem',
      'x-component': 'DatePicker.RangePicker',
      'x-component-props': {
        showTime: true,
      },
      type: 'string',
    },
    range_week: {
      title: 'Week range selection',
      'x-decorator': 'FormItem',
      'x-component': 'DatePicker.RangePicker',
      'x-component-props': {
        picker: 'week',
      },
      type: 'string',
    },
    range_month: {
      title: 'Month Range Selection',
      'x-decorator': 'FormItem',
      'x-component': 'DatePicker.RangePicker',
      'x-component-props': {
        picker: 'month',
      },
      type: 'string',
    },
    range_quarter: {
      title: 'Financial year range selection',
      'x-decorator': 'FormItem',
      'x-component': 'DatePicker.RangePicker',
      'x-component-props': {
        picker: 'quarter',
      },
      type: 'string',
    },
    range_year: {
      name: 'range_year',
      title: 'Year range selection',
      'x-decorator': 'FormItem',
      'x-component': 'DatePicker.RangePicker',
      'x-component-props': {
        picker: 'year',
      },
      type: 'string',
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## Pure JSX case

```tsx
import React from 'react'
import { DatePicker, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="date"
      title="date selection"
      decorator={[FormItem]}
      component={[DatePicker]}
    />
    <Field
      name="week"
      title="Week Selection"
      decorator={[FormItem]}
      component={[
        DatePicker,
        {
          picker: 'week',
        },
      ]}
    />
    <Field
      name="quarter"
      title="Financial Year Selection"
      decorator={[FormItem]}
      component={[
        DatePicker,
        {
          picker: 'month',
        },
      ]}
    />
    <Field
      name="year"
      title="Year selection"
      decorator={[FormItem]}
      component={[
        DatePicker,
        {
          picker: 'year',
        },
      ]}
    />
    <Field
      name="[startDate,endDate]"
      title="Date range selection"
      decorator={[FormItem]}
      component={[DatePicker.RangePicker]}
    />
    <Field
      name="range_week"
      title="Week range selection"
      decorator={[FormItem]}
      component={[
        DatePicker.RangePicker,
        {
          picker: 'week',
        },
      ]}
    />
    <Field
      name="range_month"
      title="Month Range Selection"
      decorator={[FormItem]}
      component={[
        DatePicker.RangePicker,
        {
          picker: 'month',
        },
      ]}
    />
    <Field
      name="range_quarter"
      title="Financial Year Range Selection"
      decorator={[FormItem]}
      component={[
        DatePicker.RangePicker,
        {
          picker: 'quarter',
        },
      ]}
    />
    <Field
      name="range_year"
      title="Year range selection"
      decorator={[FormItem]}
      component={[
        DatePicker.RangePicker,
        {
          picker: 'year',
        },
      ]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

Reference https://ant.design/components/date-picker-cn/
</file>

<file path="packages/antd/docs/components/DatePicker.zh-CN.md">
# DatePicker

> 日期选择器

## Markup Schema 案例

```tsx
import React from 'react'
import { DatePicker, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    DatePicker,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="date"
        required
        title="普通日期"
        x-decorator="FormItem"
        x-component="DatePicker"
      />
      <SchemaField.String
        name="week"
        title="周选择"
        x-decorator="FormItem"
        x-component="DatePicker"
        x-component-props={{
          picker: 'week',
        }}
      />
      <SchemaField.String
        name="month"
        title="月选择"
        x-decorator="FormItem"
        x-component="DatePicker"
        x-component-props={{
          picker: 'month',
        }}
      />
      <SchemaField.String
        name="quarter"
        title="财年选择"
        x-decorator="FormItem"
        x-component="DatePicker"
        x-component-props={{
          picker: 'quarter',
        }}
      />
      <SchemaField.String
        name="year"
        title="年选择"
        x-decorator="FormItem"
        x-component="DatePicker"
        x-component-props={{
          picker: 'year',
        }}
      />
      <SchemaField.String
        name="[startDate,endDate]"
        title="日期范围"
        x-decorator="FormItem"
        x-component="DatePicker.RangePicker"
        x-component-props={{
          showTime: true,
        }}
      />
      <SchemaField.String
        name="range_week"
        title="周范围选择"
        x-decorator="FormItem"
        x-component="DatePicker.RangePicker"
        x-component-props={{
          picker: 'week',
        }}
      />
      <SchemaField.String
        name="range_month"
        title="月范围选择"
        x-decorator="FormItem"
        x-component="DatePicker.RangePicker"
        x-component-props={{
          picker: 'month',
        }}
      />
      <SchemaField.String
        name="range_quarter"
        title="财年范围选择"
        x-decorator="FormItem"
        x-component="DatePicker.RangePicker"
        x-component-props={{
          picker: 'quarter',
        }}
      />
      <SchemaField.String
        name="range_year"
        title="年范围选择"
        x-decorator="FormItem"
        x-component="DatePicker.RangePicker"
        x-component-props={{
          picker: 'year',
        }}
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema 案例

```tsx
import React from 'react'
import { DatePicker, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    DatePicker,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    date: {
      title: '普通日期',
      'x-decorator': 'FormItem',
      'x-component': 'DatePicker',
      type: 'string',
    },
    week: {
      title: '周选择',
      'x-decorator': 'FormItem',
      'x-component': 'DatePicker',
      'x-component-props': {
        picker: 'week',
      },
      type: 'string',
    },
    month: {
      title: '月选择',
      'x-decorator': 'FormItem',
      'x-component': 'DatePicker',
      'x-component-props': {
        picker: 'month',
      },
      type: 'string',
    },
    quarter: {
      title: '财年选择',
      'x-decorator': 'FormItem',
      'x-component': 'DatePicker',
      'x-component-props': {
        picker: 'quarter',
      },
      type: 'string',
    },
    year: {
      title: '年选择',
      'x-decorator': 'FormItem',
      'x-component': 'DatePicker',
      'x-component-props': {
        picker: 'year',
      },
      type: 'string',
    },
    '[startDate,endDate]': {
      title: '日期范围',
      'x-decorator': 'FormItem',
      'x-component': 'DatePicker.RangePicker',
      'x-component-props': {
        showTime: true,
      },
      type: 'string',
    },
    range_week: {
      title: '周范围选择',
      'x-decorator': 'FormItem',
      'x-component': 'DatePicker.RangePicker',
      'x-component-props': {
        picker: 'week',
      },
      type: 'string',
    },
    range_month: {
      title: '月范围选择',
      'x-decorator': 'FormItem',
      'x-component': 'DatePicker.RangePicker',
      'x-component-props': {
        picker: 'month',
      },
      type: 'string',
    },
    range_quarter: {
      title: '财年范围选择',
      'x-decorator': 'FormItem',
      'x-component': 'DatePicker.RangePicker',
      'x-component-props': {
        picker: 'quarter',
      },
      type: 'string',
    },
    range_year: {
      name: 'range_year',
      title: '年范围选择',
      'x-decorator': 'FormItem',
      'x-component': 'DatePicker.RangePicker',
      'x-component-props': {
        picker: 'year',
      },
      type: 'string',
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## 纯 JSX 案例

```tsx
import React from 'react'
import { DatePicker, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="date"
      title="日期选择"
      decorator={[FormItem]}
      component={[DatePicker]}
    />
    <Field
      name="week"
      title="周选择"
      decorator={[FormItem]}
      component={[
        DatePicker,
        {
          picker: 'week',
        },
      ]}
    />
    <Field
      name="quarter"
      title="财年选择"
      decorator={[FormItem]}
      component={[
        DatePicker,
        {
          picker: 'month',
        },
      ]}
    />
    <Field
      name="year"
      title="年选择"
      decorator={[FormItem]}
      component={[
        DatePicker,
        {
          picker: 'year',
        },
      ]}
    />
    <Field
      name="[startDate,endDate]"
      title="日期范围选择"
      decorator={[FormItem]}
      component={[DatePicker.RangePicker]}
    />
    <Field
      name="range_week"
      title="周范围选择"
      decorator={[FormItem]}
      component={[
        DatePicker.RangePicker,
        {
          picker: 'week',
        },
      ]}
    />
    <Field
      name="range_month"
      title="月范围选择"
      decorator={[FormItem]}
      component={[
        DatePicker.RangePicker,
        {
          picker: 'month',
        },
      ]}
    />
    <Field
      name="range_quarter"
      title="财年范围选择"
      decorator={[FormItem]}
      component={[
        DatePicker.RangePicker,
        {
          picker: 'quarter',
        },
      ]}
    />
    <Field
      name="range_year"
      title="年范围选择"
      decorator={[FormItem]}
      component={[
        DatePicker.RangePicker,
        {
          picker: 'year',
        },
      ]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

参考 https://ant.design/components/date-picker-cn/
</file>

<file path="packages/antd/docs/components/Editable.md">
# Editable

> Partial editor, you can use this component for some form areas with high space requirements
>
> Editable component is equivalent to a variant of FormItem component, so it is usually placed in decorator

## Markup Schema example

```tsx
import React from 'react'
import {
  Input,
  DatePicker,
  Editable,
  FormItem,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    DatePicker,
    Editable,
    Input,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="date"
        title="date"
        x-decorator="Editable"
        x-component="DatePicker"
      />
      <SchemaField.String
        name="input"
        title="input box"
        x-decorator="Editable"
        x-component="Input"
      />
      <SchemaField.Void
        name="void"
        title="Virtual Node Container"
        x-component="Editable.Popover"
        x-reactions={(field) => {
          field.title = field.query('.void.date2').get('value') || field.title
        }}
      >
        <SchemaField.String
          name="date2"
          title="date"
          x-decorator="FormItem"
          x-component="DatePicker"
        />
        <SchemaField.String
          name="input2"
          title="input box"
          x-decorator="FormItem"
          x-component="Input"
        />
      </SchemaField.Void>
      <SchemaField.Object
        name="iobject"
        title="Object node container"
        x-component="Editable.Popover"
        x-reactions={(field) => {
          field.title = field.value?.date || field.title
        }}
      >
        <SchemaField.String
          name="date"
          title="date"
          x-decorator="FormItem"
          x-component="DatePicker"
        />
        <SchemaField.String
          name="input"
          title="input box"
          x-decorator="FormItem"
          x-component="Input"
        />
      </SchemaField.Object>
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema case

```tsx
import React from 'react'
import {
  Input,
  DatePicker,
  Editable,
  FormItem,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    DatePicker,
    Editable,
    Input,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    date: {
      type: 'string',
      title: 'Date',
      'x-decorator': 'Editable',
      'x-component': 'DatePicker',
    },
    input: {
      type: 'string',
      title: 'input box',
      'x-decorator': 'Editable',
      'x-component': 'Input',
    },
    void: {
      type: 'void',
      title: 'Virtual Node Container',
      'x-component': 'Editable.Popover',
      'x-reactions':
        "{{(field) => field.title = field.query('.void.date2').get('value') || field.title}}",
      properties: {
        date2: {
          type: 'string',
          title: 'Date',
          'x-decorator': 'FormItem',
          'x-component': 'DatePicker',
        },
        input2: {
          type: 'string',
          title: 'input box',
          'x-decorator': 'FormItem',
          'x-component': 'Input',
        },
      },
    },
    iobject: {
      type: 'object',
      title: 'Object node container',
      'x-component': 'Editable.Popover',
      'x-reactions':
        '{{(field) => field.title = field.value && field.value.date || field.title}}',
      properties: {
        date: {
          type: 'string',
          title: 'Date',
          'x-decorator': 'FormItem',
          'x-component': 'DatePicker',
        },
        input: {
          type: 'string',
          title: 'input box',
          'x-decorator': 'FormItem',
          'x-component': 'Input',
        },
      },
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## Pure JSX case

```tsx
import React from 'react'
import {
  Input,
  DatePicker,
  Editable,
  FormItem,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field, VoidField, ObjectField } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="date"
      title="date"
      decorator={[Editable]}
      component={[DatePicker]}
    />
    <Field
      name="input"
      title="input box"
      decorator={[Editable]}
      component={[Input]}
    />
    <VoidField
      name="void"
      title="Virtual Node Container"
      reactions={(field) => {
        field.title = field.query('.void.date2').get('value') || field.title
      }}
      component={[Editable.Popover]}
    >
      <Field
        name="date2"
        title="date"
        decorator={[FormItem]}
        component={[DatePicker]}
      />
      <Field
        name="input2"
        title="input box"
        decorator={[FormItem]}
        component={[Input]}
      />
    </VoidField>
    <ObjectField
      name="iobject"
      title="Object node container"
      reactions={(field) => {
        field.title = field.value?.date || field.title
      }}
      component={[Editable.Popover]}
    >
      <Field
        name="date"
        title="date"
        decorator={[FormItem]}
        component={[DatePicker]}
      />
      <Field
        name="input"
        title="input box"
        decorator={[FormItem]}
        component={[Input]}
      />
    </ObjectField>

    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

### Editable

> Inline editing

Refer to the FormItem property in https://ant.design/components/form-cn/

### Editable.Popover

> Floating layer editing

Reference https://ant.design/components/popover-cn/
</file>

<file path="packages/antd/docs/components/Editable.zh-CN.md">
# Editable

> 局部编辑器，对于一些空间要求较高的表单区域可以使用该组件
>
> Editable 组件相当于是 FormItem 组件的变体，所以通常放在 decorator 中

## Markup Schema 案例

```tsx
import React from 'react'
import {
  Input,
  DatePicker,
  Editable,
  FormItem,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    DatePicker,
    Editable,
    Input,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="date"
        title="日期"
        x-decorator="Editable"
        x-component="DatePicker"
      />
      <SchemaField.String
        name="input"
        title="输入框"
        x-decorator="Editable"
        x-component="Input"
      />
      <SchemaField.Void
        name="void"
        title="虚拟节点容器"
        x-component="Editable.Popover"
        x-reactions={(field) => {
          field.title = field.query('.void.date2').get('value') || field.title
        }}
      >
        <SchemaField.String
          name="date2"
          title="日期"
          x-decorator="FormItem"
          x-component="DatePicker"
        />
        <SchemaField.String
          name="input2"
          title="输入框"
          x-decorator="FormItem"
          x-component="Input"
        />
      </SchemaField.Void>
      <SchemaField.Object
        name="iobject"
        title="对象节点容器"
        x-component="Editable.Popover"
        x-reactions={(field) => {
          field.title = field.value?.date || field.title
        }}
      >
        <SchemaField.String
          name="date"
          title="日期"
          x-decorator="FormItem"
          x-component="DatePicker"
        />
        <SchemaField.String
          name="input"
          title="输入框"
          x-decorator="FormItem"
          x-component="Input"
        />
      </SchemaField.Object>
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema 案例

```tsx
import React from 'react'
import {
  Input,
  DatePicker,
  Editable,
  FormItem,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    DatePicker,
    Editable,
    Input,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    date: {
      type: 'string',
      title: '日期',
      'x-decorator': 'Editable',
      'x-component': 'DatePicker',
    },
    input: {
      type: 'string',
      title: '输入框',
      'x-decorator': 'Editable',
      'x-component': 'Input',
    },
    void: {
      type: 'void',
      title: '虚拟节点容器',
      'x-component': 'Editable.Popover',
      'x-reactions':
        "{{(field) => field.title = field.query('.void.date2').get('value') || field.title}}",
      properties: {
        date2: {
          type: 'string',
          title: '日期',
          'x-decorator': 'FormItem',
          'x-component': 'DatePicker',
        },
        input2: {
          type: 'string',
          title: '输入框',
          'x-decorator': 'FormItem',
          'x-component': 'Input',
        },
      },
    },
    iobject: {
      type: 'object',
      title: '对象节点容器',
      'x-component': 'Editable.Popover',
      'x-reactions':
        '{{(field) => field.title = field.value && field.value.date || field.title}}',
      properties: {
        date: {
          type: 'string',
          title: '日期',
          'x-decorator': 'FormItem',
          'x-component': 'DatePicker',
        },
        input: {
          type: 'string',
          title: '输入框',
          'x-decorator': 'FormItem',
          'x-component': 'Input',
        },
      },
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## 纯 JSX 案例

```tsx
import React from 'react'
import {
  Input,
  DatePicker,
  Editable,
  FormItem,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field, VoidField, ObjectField } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="date"
      title="日期"
      decorator={[Editable]}
      component={[DatePicker]}
    />
    <Field
      name="input"
      title="输入框"
      decorator={[Editable]}
      component={[Input]}
    />
    <VoidField
      name="void"
      title="虚拟节点容器"
      reactions={(field) => {
        field.title = field.query('.void.date2').get('value') || field.title
      }}
      component={[Editable.Popover]}
    >
      <Field
        name="date2"
        title="日期"
        decorator={[FormItem]}
        component={[DatePicker]}
      />
      <Field
        name="input2"
        title="输入框"
        decorator={[FormItem]}
        component={[Input]}
      />
    </VoidField>
    <ObjectField
      name="iobject"
      title="对象节点容器"
      reactions={(field) => {
        field.title = field.value?.date || field.title
      }}
      component={[Editable.Popover]}
    >
      <Field
        name="date"
        title="日期"
        decorator={[FormItem]}
        component={[DatePicker]}
      />
      <Field
        name="input"
        title="输入框"
        decorator={[FormItem]}
        component={[Input]}
      />
    </ObjectField>

    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

### Editable

> 内联编辑

参考 https://ant.design/components/form-cn/ 中的 FormItem 属性

### Editable.Popover

> 浮层编辑

参考 https://ant.design/components/popover-cn/
</file>

<file path="packages/antd/docs/components/Form.md">
# Form

> The combination of FormProvider + FormLayout + form tags can help us quickly implement forms that are submitted with carriage return and can be laid out in batches

## Use Cases

```tsx
import React from 'react'
import {
  Input,
  Select,
  Form,
  FormItem,
  FormGrid,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { Field } from '@formily/react'

const form = createForm()

export default () => (
  <Form
    form={form}
    layout="vertical"
    feedbackLayout="terse"
    onAutoSubmit={console.log}
    onAutoSubmitFailed={console.log}
  >
    <FormGrid maxColumns={4}>
      <Field
        name="aa"
        title="select box"
        decorator={[FormItem]}
        component={[Select]}
        dataSource={[
          {
            label: 'Option 1',
            value: 1,
          },
          {
            label: 'Option 2',
            value: 2,
          },
        ]}
      />
      <Field
        name="bb"
        title="input box"
        required
        decorator={[FormItem]}
        component={[Input]}
      />
      <Field
        name="cc"
        title="input box"
        decorator={[FormItem]}
        component={[Input]}
      />
      <Field
        name="dd"
        title="input box"
        decorator={[FormItem]}
        component={[Input]}
      />
      <Field
        name="ee"
        title="input box"
        decorator={[FormItem]}
        component={[Input]}
      />
      <FormButtonGroup.FormItem>
        <Submit>Query</Submit>
      </FormButtonGroup.FormItem>
    </FormGrid>
  </Form>
)
```

<Alert style="margin-top:20px">
Note: To realize the carriage return submission, we cannot pass the onSubmit event to it when using the Submit component, otherwise the carriage return submission will become invalid. The purpose of this is to prevent users from writing onSubmit event listeners in multiple places at the same time, and processing logic If they are inconsistent, it is difficult to locate the problem when submitting.
</Alert>

## API

For layout-related API properties, we can refer to [FormLayout](./form-layout), and the rest are the unique API properties of the Form component

| Property name          | Type                                                                                             | Description                                                         | Default value |
| ---------------------- | ------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------- | ------------- |
| form                   | [Form](https://core.formilyjs.org/api/models/form)                                               | Form example                                                        | -             |
| component              | string                                                                                           | Rendering component, can be specified as custom component rendering | `form`        |
| previewTextPlaceholder | ReactNode                                                                                        | Preview State Placeholder                                           | `N/A`         |
| onAutoSubmit           | `(values:any)=>any`                                                                              | Carriage return submit event callback                               | -             |
| onAutoSubmitFailed     | (feedbacks: [IFormFeedback](https://core.formilyjs.org/api/models/form#iformfeedback)[]) => void | Carriage return submission verification failure event callback      | -             |
</file>

<file path="packages/antd/docs/components/Form.zh-CN.md">
# Form

> FormProvider + FormLayout + form 标签的组合组件，可以帮助我们快速实现带回车提交的且能批量布局的表单

## 使用案例

```tsx
import React from 'react'
import {
  Input,
  Select,
  Form,
  FormItem,
  FormGrid,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { Field } from '@formily/react'

const form = createForm()

export default () => (
  <Form
    form={form}
    layout="vertical"
    feedbackLayout="terse"
    onAutoSubmit={console.log}
    onAutoSubmitFailed={console.log}
  >
    <FormGrid maxColumns={4}>
      <Field
        name="aa"
        title="选择框"
        decorator={[FormItem]}
        component={[Select]}
        dataSource={[
          {
            label: '选项1',
            value: 1,
          },
          {
            label: '选项2',
            value: 2,
          },
        ]}
      />
      <Field
        name="bb"
        title="输入框"
        required
        decorator={[FormItem]}
        component={[Input]}
      />
      <Field
        name="cc"
        title="输入框"
        decorator={[FormItem]}
        component={[Input]}
      />
      <Field
        name="dd"
        title="输入框"
        decorator={[FormItem]}
        component={[Input]}
      />
      <Field
        name="ee"
        title="输入框"
        decorator={[FormItem]}
        component={[Input]}
      />
      <FormButtonGroup.FormItem>
        <Submit>查询</Submit>
      </FormButtonGroup.FormItem>
    </FormGrid>
  </Form>
)
```

<Alert style="margin-top:20px">
注意：想要实现回车提交，我们在使用Submit组件的时候不能给其传onSubmit事件，否则回车提交会失效，这样做的目的是为了防止用户同时在多处写onSubmit事件监听器，处理逻辑不一致的话，提交时很难定位问题。
</Alert>

## API

布局相关的 API 属性，我们参考 [FormLayout](./form-layout)即可，剩下是 Form 组件独有的 API 属性

| 属性名                 | 类型                                                                                                   | 描述                               | 默认值 |
| ---------------------- | ------------------------------------------------------------------------------------------------------ | ---------------------------------- | ------ |
| form                   | [Form](https://core.formilyjs.org/zh-CN/api/models/form)                                               | Form 实例                          | -      |
| component              | string                                                                                                 | 渲染组件，可以指定为自定义组件渲染 | `form` |
| previewTextPlaceholder | ReactNode                                                                                              | 预览态占位符                       | `N/A`  |
| onAutoSubmit           | `(values:any)=>any`                                                                                    | 回车提交事件回调                   | -      |
| onAutoSubmitFailed     | (feedbacks: [IFormFeedback](https://core.formilyjs.org/zh-CN/api/models/form#iformfeedback)[]) => void | 回车提交校验失败事件回调           | -      |
</file>

<file path="packages/antd/docs/components/FormButtonGroup.md">
# FormButtonGroup

> Form button group layout component

## Common case

```tsx
import React from 'react'
import {
  FormButtonGroup,
  Submit,
  Reset,
  FormItem,
  Input,
  FormLayout,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <FormLayout labelCol={6} wrapperCol={10}>
        <SchemaField>
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
        </SchemaField>
        <FormButtonGroup.FormItem>
          <Submit onSubmit={console.log}>Submit</Submit>
          <Reset>Reset</Reset>
        </FormButtonGroup.FormItem>
      </FormLayout>
    </FormProvider>
  )
}
```

## Suction bottom case

```tsx
import React from 'react'
import {
  FormButtonGroup,
  Submit,
  Reset,
  FormItem,
  FormLayout,
  Input,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <FormLayout labelCol={6} wrapperCol={10}>
        <SchemaField>
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
        </SchemaField>
        <FormButtonGroup.Sticky>
          <FormButtonGroup.FormItem>
            <Submit onSubmit={console.log}>Submit</Submit>
            <Reset>Reset</Reset>
          </FormButtonGroup.FormItem>
        </FormButtonGroup.Sticky>
      </FormLayout>
    </FormProvider>
  )
}
```

## Suction bottom centering case

```tsx
import React from 'react'
import {
  FormButtonGroup,
  Submit,
  Reset,
  FormItem,
  FormLayout,
  Input,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <FormLayout labelCol={6} wrapperCol={10}>
        <SchemaField>
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="input box"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
        </SchemaField>
        <FormButtonGroup.Sticky align="center">
          <FormButtonGroup>
            <Submit onSubmit={console.log}>Submit</Submit>
            <Reset>Reset</Reset>
          </FormButtonGroup>
        </FormButtonGroup.Sticky>
      </FormLayout>
    </FormProvider>
  )
}
```

## API

### FormButtonGroup

> This component is mainly used to handle the button group gap

| Property name | Type                        | Description | Default value |
| ------------- | --------------------------- | ----------- | ------------- |
| gutter        | number                      | Gap size    | 8px           |
| align         | `'left'\|'center'\|'right'` | Alignment   | `'left'`      |

### FormButtonGroup.FormItem

> This component is mainly used to deal with the alignment of the button group and the main form FormItem

Refer to [FormItem](/components/form-item) property

### FormButtonGroup.Sticky

> This component is mainly used to deal with the floating positioning problem of the button group

| Property name | Type                        | Description | Default value |
| ------------- | --------------------------- | ----------- | ------------- |
| align         | `'left'\|'center'\|'right'` | Alignment   | `'left'`      |
</file>

<file path="packages/antd/docs/components/FormButtonGroup.zh-CN.md">
# FormButtonGroup

> 表单按钮组布局组件

## 普通案例

```tsx
import React from 'react'
import {
  FormButtonGroup,
  Submit,
  Reset,
  FormItem,
  Input,
  FormLayout,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <FormLayout labelCol={6} wrapperCol={10}>
        <SchemaField>
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
        </SchemaField>
        <FormButtonGroup.FormItem>
          <Submit onSubmit={console.log}>提交</Submit>
          <Reset>重置</Reset>
        </FormButtonGroup.FormItem>
      </FormLayout>
    </FormProvider>
  )
}
```

## 吸底案例

```tsx
import React from 'react'
import {
  FormButtonGroup,
  Submit,
  Reset,
  FormItem,
  FormLayout,
  Input,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <FormLayout labelCol={6} wrapperCol={10}>
        <SchemaField>
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
        </SchemaField>
        <FormButtonGroup.Sticky>
          <FormButtonGroup.FormItem>
            <Submit onSubmit={console.log}>提交</Submit>
            <Reset>重置</Reset>
          </FormButtonGroup.FormItem>
        </FormButtonGroup.Sticky>
      </FormLayout>
    </FormProvider>
  )
}
```

## 吸底居中案例

```tsx
import React from 'react'
import {
  FormButtonGroup,
  Submit,
  Reset,
  FormItem,
  FormLayout,
  Input,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <FormLayout labelCol={6} wrapperCol={10}>
        <SchemaField>
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
          <SchemaField.String
            title="输入框"
            x-decorator="FormItem"
            required
            x-component="Input"
          />
        </SchemaField>
        <FormButtonGroup.Sticky align="center">
          <FormButtonGroup>
            <Submit onSubmit={console.log}>提交</Submit>
            <Reset>重置</Reset>
          </FormButtonGroup>
        </FormButtonGroup.Sticky>
      </FormLayout>
    </FormProvider>
  )
}
```

## API

### FormButtonGroup

> 该组件主要用来处理按钮组间隙

| 属性名 | 类型                        | 描述     | 默认值   |
| ------ | --------------------------- | -------- | -------- |
| gutter | number                      | 间隙大小 | 8px      |
| align  | `'left'\|'center'\|'right'` | 对齐方式 | `'left'` |

### FormButtonGroup.FormItem

> 该组件主要用来处理按钮组与主表单 FormItem 对齐问题

参考 [FormItem](/components/form-item) 属性

### FormButtonGroup.Sticky

> 该组件主要用来处理按钮组浮动定位问题

| 属性名 | 类型                        | 描述     | 默认值   |
| ------ | --------------------------- | -------- | -------- |
| align  | `'left'\|'center'\|'right'` | 对齐方式 | `'left'` |
</file>

<file path="packages/antd/docs/components/FormCollapse.md">
# FormCollapse

> Folding panel, usually used in form scenes with high layout space requirements
>
> Note: Can only be used in Schema scenarios

## Markup Schema example

```tsx
import React from 'react'
import {
  FormCollapse,
  FormLayout,
  FormItem,
  Input,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Button } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    FormCollapse,
    Input,
  },
})

const form = createForm()
const formCollapse = FormCollapse.createFormCollapse()
export default () => {
  return (
    <FormProvider form={form}>
      <FormLayout labelCol={6} wrapperCol={10}>
        <SchemaField>
          <SchemaField.Void
            title="Folding Panel"
            x-decorator="FormItem"
            x-component="FormCollapse"
            x-component-props={{
              formCollapse,
            }}
          >
            <SchemaField.Void
              name="panel1"
              x-component="FormCollapse.CollapsePanel"
              x-component-props={{ header: 'A1' }}
            >
              <SchemaField.String
                name="aaa"
                title="AAA"
                x-decorator="FormItem"
                required
                x-component="Input"
              />
            </SchemaField.Void>
            <SchemaField.Void
              name="panel2"
              x-component="FormCollapse.CollapsePanel"
              x-component-props={{ header: 'A2' }}
            >
              <SchemaField.String
                name="bbb"
                title="BBB"
                x-decorator="FormItem"
                required
                x-component="Input"
              />
            </SchemaField.Void>
            <SchemaField.Void
              name="panel3"
              x-component="FormCollapse.CollapsePanel"
              x-component-props={{ header: 'A3' }}
            >
              <SchemaField.String
                name="ccc"
                title="CCC"
                x-decorator="FormItem"
                required
                x-component="Input"
              />
            </SchemaField.Void>
          </SchemaField.Void>
        </SchemaField>
        <FormButtonGroup.FormItem>
          <Button
            onClick={() => {
              form.query('panel3').take((field) => {
                field.visible = !field.visible
              })
            }}
          >
            Show/hide the last tab
          </Button>
          <Button
            onClick={() => {
              formCollapse.toggleActiveKey('panel2')
            }}
          >
            Switch to the second Tab
          </Button>
          <Submit onSubmit={console.log}>Submit</Submit>
        </FormButtonGroup.FormItem>
      </FormLayout>
    </FormProvider>
  )
}
```

## JSON Schema case

```tsx
import React from 'react'
import {
  FormCollapse,
  FormItem,
  FormLayout,
  Input,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Button } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    FormCollapse,
    Input,
  },
})

const form = createForm()
const formCollapse = FormCollapse.createFormCollapse()
const schema = {
  type: 'object',
  properties: {
    collapse: {
      type: 'void',
      title: 'Folding Panel',
      'x-decorator': 'FormItem',
      'x-component': 'FormCollapse',
      'x-component-props': {
        formCollapse: '{{formCollapse}}',
      },
      properties: {
        panel1: {
          type: 'void',
          'x-component': 'FormCollapse.CollapsePanel',
          'x-component-props': {
            header: 'A1',
          },
          properties: {
            aaa: {
              type: 'string',
              title: 'AAA',
              'x-decorator': 'FormItem',
              required: true,
              'x-component': 'Input',
            },
          },
        },
        panel2: {
          type: 'void',
          'x-component': 'FormCollapse.CollapsePanel',
          'x-component-props': {
            header: 'A2',
          },
          properties: {
            bbb: {
              type: 'string',
              title: 'BBB',
              'x-decorator': 'FormItem',
              required: true,
              'x-component': 'Input',
            },
          },
        },
        panel3: {
          type: 'void',
          'x-component': 'FormCollapse.CollapsePanel',
          'x-component-props': {
            header: 'A3',
          },
          properties: {
            ccc: {
              type: 'string',
              title: 'CCC',
              'x-decorator': 'FormItem',
              required: true,
              'x-component': 'Input',
            },
          },
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <FormLayout labelCol={6} wrapperCol={10}>
        <SchemaField schema={schema} scope={{ formCollapse }} />
        <FormButtonGroup.FormItem>
          <Button
            onClick={() => {
              form.query('panel3').take((field) => {
                field.visible = !field.visible
              })
            }}
          >
            Show/hide the last tab
          </Button>
          <Button
            onClick={() => {
              formCollapse.toggleActiveKey('panel2')
            }}
          >
            Switch to the second Tab
          </Button>
          <Submit onSubmit={console.log}>Submit</Submit>
        </FormButtonGroup.FormItem>
      </FormLayout>
    </FormProvider>
  )
}
```

## API

### FormCollapse

| Property name | Type          | Description                                                     | Default value |
| ------------- | ------------- | --------------------------------------------------------------- | ------------- |
| formCollapse  | IFormCollapse | Pass in the model created by createFormCollapse/useFormCollapse |               |

Other references https://ant.design/components/collapse-cn/

### FormCollapse.CollapsePanel

Reference https://ant.design/components/collapse-cn/

### FormCollapse.createFormCollapse

```ts pure
type ActiveKey = string | number
type ActiveKeys = string | number | Array<string | number>

interface createFormCollapse {
  (defaultActiveKeys?: ActiveKeys): IFormCollpase
}

interface IFormCollapse {
  //Activate the primary key list
  activeKeys: ActiveKeys
  //Does the activation key exist?
  hasActiveKey(key: ActiveKey): boolean
  //Set the list of active primary keys
  setActiveKeys(keys: ActiveKeys): void
  //Add activation key
  addActiveKey(key: ActiveKey): void
  //Delete the active primary key
  removeActiveKey(key: ActiveKey): void
  //Switch to activate the main key
  toggleActiveKey(key: ActiveKey): void
}
```
</file>

<file path="packages/antd/docs/components/FormCollapse.zh-CN.md">
# FormCollapse

> 折叠面板，通常用在布局空间要求较高的表单场景
>
> 注意：只能用在 Schema 场景

## Markup Schema 案例

```tsx
import React from 'react'
import {
  FormCollapse,
  FormLayout,
  FormItem,
  Input,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Button } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    FormCollapse,
    Input,
  },
})

const form = createForm()
const formCollapse = FormCollapse.createFormCollapse()
export default () => {
  return (
    <FormProvider form={form}>
      <FormLayout labelCol={6} wrapperCol={10}>
        <SchemaField>
          <SchemaField.Void
            title="折叠面板"
            x-decorator="FormItem"
            x-component="FormCollapse"
            x-component-props={{
              formCollapse,
            }}
          >
            <SchemaField.Void
              name="panel1"
              x-component="FormCollapse.CollapsePanel"
              x-component-props={{ header: 'A1' }}
            >
              <SchemaField.String
                name="aaa"
                title="AAA"
                x-decorator="FormItem"
                required
                x-component="Input"
              />
            </SchemaField.Void>
            <SchemaField.Void
              name="panel2"
              x-component="FormCollapse.CollapsePanel"
              x-component-props={{ header: 'A2' }}
            >
              <SchemaField.String
                name="bbb"
                title="BBB"
                x-decorator="FormItem"
                required
                x-component="Input"
              />
            </SchemaField.Void>
            <SchemaField.Void
              name="panel3"
              x-component="FormCollapse.CollapsePanel"
              x-component-props={{ header: 'A3' }}
            >
              <SchemaField.String
                name="ccc"
                title="CCC"
                x-decorator="FormItem"
                required
                x-component="Input"
              />
            </SchemaField.Void>
          </SchemaField.Void>
        </SchemaField>
        <FormButtonGroup.FormItem>
          <Button
            onClick={() => {
              form.query('panel3').take((field) => {
                field.visible = !field.visible
              })
            }}
          >
            显示/隐藏最后一个Tab
          </Button>
          <Button
            onClick={() => {
              formCollapse.toggleActiveKey('panel2')
            }}
          >
            切换第二个Tab
          </Button>
          <Submit onSubmit={console.log}>提交</Submit>
        </FormButtonGroup.FormItem>
      </FormLayout>
    </FormProvider>
  )
}
```

## JSON Schema 案例

```tsx
import React from 'react'
import {
  FormCollapse,
  FormItem,
  FormLayout,
  Input,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Button } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    FormCollapse,
    Input,
  },
})

const form = createForm()
const formCollapse = FormCollapse.createFormCollapse()
const schema = {
  type: 'object',
  properties: {
    collapse: {
      type: 'void',
      title: '折叠面板',
      'x-decorator': 'FormItem',
      'x-component': 'FormCollapse',
      'x-component-props': {
        formCollapse: '{{formCollapse}}',
      },
      properties: {
        panel1: {
          type: 'void',
          'x-component': 'FormCollapse.CollapsePanel',
          'x-component-props': {
            header: 'A1',
          },
          properties: {
            aaa: {
              type: 'string',
              title: 'AAA',
              'x-decorator': 'FormItem',
              required: true,
              'x-component': 'Input',
            },
          },
        },
        panel2: {
          type: 'void',
          'x-component': 'FormCollapse.CollapsePanel',
          'x-component-props': {
            header: 'A2',
          },
          properties: {
            bbb: {
              type: 'string',
              title: 'BBB',
              'x-decorator': 'FormItem',
              required: true,
              'x-component': 'Input',
            },
          },
        },
        panel3: {
          type: 'void',
          'x-component': 'FormCollapse.CollapsePanel',
          'x-component-props': {
            header: 'A3',
          },
          properties: {
            ccc: {
              type: 'string',
              title: 'CCC',
              'x-decorator': 'FormItem',
              required: true,
              'x-component': 'Input',
            },
          },
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <FormLayout labelCol={6} wrapperCol={10}>
        <SchemaField schema={schema} scope={{ formCollapse }} />
        <FormButtonGroup.FormItem>
          <Button
            onClick={() => {
              form.query('panel3').take((field) => {
                field.visible = !field.visible
              })
            }}
          >
            显示/隐藏最后一个Tab
          </Button>
          <Button
            onClick={() => {
              formCollapse.toggleActiveKey('panel2')
            }}
          >
            切换第二个Tab
          </Button>
          <Submit onSubmit={console.log}>提交</Submit>
        </FormButtonGroup.FormItem>
      </FormLayout>
    </FormProvider>
  )
}
```

## API

### FormCollapse

| 属性名       | 类型          | 描述                                                       | 默认值 |
| ------------ | ------------- | ---------------------------------------------------------- | ------ |
| formCollapse | IFormCollapse | 传入通过 createFormCollapse/useFormCollapse 创建出来的模型 |        |

其余参考 https://ant.design/components/collapse-cn/

### FormCollapse.CollapsePanel

参考 https://ant.design/components/collapse-cn/

### FormCollapse.createFormCollapse

```ts pure
type ActiveKey = string | number
type ActiveKeys = string | number | Array<string | number>

interface createFormCollapse {
  (defaultActiveKeys?: ActiveKeys): IFormCollpase
}

interface IFormCollapse {
  //激活主键列表
  activeKeys: ActiveKeys
  //是否存在该激活主键
  hasActiveKey(key: ActiveKey): boolean
  //设置激活主键列表
  setActiveKeys(keys: ActiveKeys): void
  //添加激活主键
  addActiveKey(key: ActiveKey): void
  //删除激活主键
  removeActiveKey(key: ActiveKey): void
  //开关切换激活主键
  toggleActiveKey(key: ActiveKey): void
}
```
</file>

<file path="packages/antd/docs/components/FormDialog.md">
# FormDialog

> Pop-up form, mainly used in simple event to open the form scene

## Markup Schema example

```tsx
import React from 'react'
import { FormDialog, FormItem, FormLayout, Input } from '@formily/antd'
import { createSchemaField } from '@formily/react'
import { Button } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
  },
})

export default () => {
  return (
    <Button
      onClick={() => {
        const dialog = FormDialog('Pop-up form', () => {
          return (
            <FormLayout labelCol={6} wrapperCol={10}>
              <SchemaField>
                <SchemaField.String
                  name="aaa"
                  required
                  title="input box 1"
                  x-decorator="FormItem"
                  x-component="Input"
                />
                <SchemaField.String
                  name="bbb"
                  required
                  title="input box 2"
                  x-decorator="FormItem"
                  x-component="Input"
                />
                <SchemaField.String
                  name="ccc"
                  required
                  title="input box 3"
                  x-decorator="FormItem"
                  x-component="Input"
                />
                <SchemaField.String
                  name="ddd"
                  required
                  title="input box 4"
                  x-decorator="FormItem"
                  x-component="Input"
                />
              </SchemaField>
              <FormDialog.Footer>
                <span
                  onClick={() => {
                    dialog.close()
                  }}
                  style={{ marginLeft: 4 }}
                >
                  Extended copywriting(Click me to close the form)
                </span>
              </FormDialog.Footer>
            </FormLayout>
          )
        })
        dialog
          .forOpen((payload, next) => {
            setTimeout(() => {
              next({
                initialValues: {
                  aaa: '123',
                },
              })
            }, 1000)
          })
          .forConfirm((payload, next) => {
            setTimeout(() => {
              console.log(payload)
              next(payload)
            }, 1000)
          })
          .forCancel((payload, next) => {
            setTimeout(() => {
              console.log(payload)
              next(payload)
            }, 1000)
          })
          .open({
            initialValues: {
              aaa: '123',
            },
          })
          .then(console.log)
      }}
    >
      Click me to open the form
    </Button>
  )
}
```

## JSON Schema case

```tsx
import React from 'react'
import { FormDialog, FormItem, FormLayout, Input } from '@formily/antd'
import { createSchemaField } from '@formily/react'
import { Button } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
  },
})

const schema = {
  type: 'object',
  properties: {
    aaa: {
      type: 'string',
      title: 'input box 1',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    bbb: {
      type: 'string',
      title: 'input box 2',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    ccc: {
      type: 'string',
      title: 'input box 3',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    ddd: {
      type: 'string',
      title: 'input box 4',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
  },
}

export default () => {
  return (
    <Button
      onClick={() => {
        const dialog = FormDialog('Pop-up form', () => {
          return (
            <FormLayout labelCol={6} wrapperCol={10}>
              <SchemaField schema={schema} />
              <FormDialog.Footer>
                <span
                  onClick={() => {
                    dialog.close()
                  }}
                  style={{ marginLeft: 4 }}
                >
                  Extended copywriting(Click me to close the form)
                </span>
              </FormDialog.Footer>
            </FormLayout>
          )
        })
        dialog
          .forOpen((payload, next) => {
            setTimeout(() => {
              next({
                initialValues: {
                  aaa: '123',
                },
              })
            }, 1000)
          })
          .forConfirm((payload, next) => {
            setTimeout(() => {
              console.log(payload)
              next(payload)
            }, 1000)
          })
          .forCancel((payload, next) => {
            setTimeout(() => {
              console.log(payload)
              next(payload)
            }, 1000)
          })
          .open({
            initialValues: {
              aaa: '123',
            },
          })
          .then(console.log)
      }}
    >
      Click me to open the form
    </Button>
  )
}
```

## Pure JSX case

```tsx
import React from 'react'
import { FormDialog, FormItem, FormLayout, Input } from '@formily/antd'
import { Field } from '@formily/react'
import { Button } from 'antd'

export default () => {
  return (
    <Button
      onClick={() => {
        const dialog = FormDialog('Pop-up form', () => {
          return (
            <FormLayout labelCol={6} wrapperCol={10}>
              <Field
                name="aaa"
                required
                title="input box 1"
                decorator={[FormItem]}
                component={[Input]}
              />
              <Field
                name="bbb"
                required
                title="input box 2"
                decorator={[FormItem]}
                component={[Input]}
              />
              <Field
                name="ccc"
                required
                title="input box 3"
                decorator={[FormItem]}
                component={[Input]}
              />
              <Field
                name="ddd"
                required
                title="input box 4"
                decorator={[FormItem]}
                component={[Input]}
              />
              <FormDialog.Footer>
                <span
                  onClick={() => {
                    dialog.close()
                  }}
                  style={{ marginLeft: 4 }}
                >
                  Extended copywriting(Click me to close the form)
                </span>
              </FormDialog.Footer>
            </FormLayout>
          )
        })
        dialog
          .forOpen((payload, next) => {
            setTimeout(() => {
              next({
                initialValues: {
                  aaa: '123',
                },
              })
            }, 1000)
          })
          .forConfirm((payload, next) => {
            setTimeout(() => {
              console.log(payload)
              next(payload)
            }, 1000)
          })
          .forCancel((payload, next) => {
            setTimeout(() => {
              console.log(payload)
              next(payload)
            }, 1000)
          })
          .open({
            initialValues: {
              aaa: '123',
            },
          })
          .then(console.log)
      }}
    >
      Click me to open the form
    </Button>
  )
}
```

## API

### FormDialog

```ts pure
import { IFormProps, Form } from '@formily/core'

type FormDialogRenderer =
  | React.ReactElement
  | ((form: Form) => React.ReactElement)

type ModalTitle = string | number | React.ReactElement

interface IFormDialog {
  forOpen(
    middleware: (
      props: IFormProps,
      next: (props?: IFormProps) => Promise<any>
    ) => any
  ): any //Middleware interceptor, can intercept Dialog to open
  forConfirm(
    middleware: (props: Form, next: (props?: Form) => Promise<any>) => any
  ): any //Middleware interceptor, which can intercept Dialog confirmation
  forCancel(
    middleware: (props: Form, next: (props?: Form) => Promise<any>) => any
  ): any //Middleware interceptor, can intercept Dialog to cancel
  //Open the pop-up window to receive form attributes, you can pass in initialValues/values/effects etc.
  open(props: IFormProps): Promise<any> //return form data
  //Close the pop-up window
  close(): void
}

interface IModalProps extends ModalProps {
  onOk?: (event: React.MouseEvent<HTMLElement>) => void | boolean // return false can prevent onOk
  onCancel?: (event: React.MouseEvent<HTMLElement>) => void | boolean // return false can prevent onCancel
  loadingText?: React.ReactNode
}

interface FormDialog {
  (title: IModalProps, id: string, renderer: FormDialogRenderer): IFormDialog
  (title: IModalProps, renderer: FormDialogRenderer): IFormDialog
  (title: ModalTitle, id: string, renderer: FormDialogRenderer): IFormDialog
  (title: ModalTitle, renderer: FormDialogRenderer): IFormDialog
}
```

`ModalProps` type definition reference ant design [Modal API](https://ant.design/components/modal-cn/#API)

### FormDialog.Footer

No attributes, only child nodes are received

### FormDialog.Portal

Receive the optional id attribute, the default value is `form-dialog`, if there are multiple prefixCls in an application, and the prefixCls in the pop-up window of different regions are different, then it is recommended to specify the id as the region-level id
</file>

<file path="packages/antd/docs/components/FormDialog.zh-CN.md">
# FormDialog

> 弹窗表单，主要用在简单的事件打开表单场景

## Markup Schema 案例

以下例子演示了 FormDialog 的几个能力：

- 快速打开，关闭能力
- 中间件能力，自动出现加载态
- 渲染函数内可以响应式能力
- 上下文共享能力

```tsx
import React, { createContext, useContext } from 'react'
import { FormDialog, FormItem, FormLayout, Input } from '@formily/antd'
import { createSchemaField } from '@formily/react'
import { Button } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
  },
})

const Context = createContext()

const PortalId = '可以传，也可以不传的ID，默认是form-dialog'

export default () => {
  return (
    <Context.Provider value="自定义上下文可以直接传到弹窗内部，只需要ID一致即可">
      <FormDialog.Portal id={PortalId}>
        <Button
          onClick={() => {
            const dialog = FormDialog('弹窗表单', PortalId, (form) => {
              console.log(useContext(Context))
              return (
                <FormLayout labelCol={6} wrapperCol={10}>
                  <SchemaField>
                    <SchemaField.String
                      name="aaa"
                      required
                      title="输入框1"
                      x-decorator="FormItem"
                      x-component="Input"
                    />
                    <SchemaField.String
                      name="bbb"
                      required
                      title="输入框2"
                      x-decorator="FormItem"
                      x-component="Input"
                    />
                    <SchemaField.String
                      name="ccc"
                      required
                      title="输入框3"
                      x-decorator="FormItem"
                      x-component="Input"
                    />
                    <SchemaField.String
                      name="ddd"
                      required
                      title="输入框4"
                      x-decorator="FormItem"
                      x-component="Input"
                    />
                  </SchemaField>
                  <FormDialog.Footer>
                    <span
                      style={{ marginLeft: 4 }}
                      onClick={() => {
                        dialog.close()
                      }}
                    >
                      扩展文案：{form.values.aaa}(点击关闭弹窗)
                    </span>
                  </FormDialog.Footer>
                </FormLayout>
              )
            })
            dialog
              .forOpen((payload, next) => {
                setTimeout(() => {
                  next({
                    initialValues: {
                      aaa: '123',
                    },
                  })
                }, 1000)
              })
              .forConfirm((payload, next) => {
                setTimeout(() => {
                  console.log(payload)
                  next(payload)
                }, 1000)
              })
              .forCancel((payload, next) => {
                setTimeout(() => {
                  console.log(payload)
                  next(payload)
                }, 1000)
              })
              .open()
              .then(console.log)
              .catch(console.error)
          }}
        >
          点我打开表单
        </Button>
      </FormDialog.Portal>
    </Context.Provider>
  )
}
```

## JSON Schema 案例

```tsx
import React from 'react'
import { FormDialog, FormItem, FormLayout, Input } from '@formily/antd'
import { createSchemaField } from '@formily/react'
import { Button } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
  },
})

const schema = {
  type: 'object',
  properties: {
    aaa: {
      type: 'string',
      title: '输入框1',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    bbb: {
      type: 'string',
      title: '输入框2',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    ccc: {
      type: 'string',
      title: '输入框3',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    ddd: {
      type: 'string',
      title: '输入框4',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
  },
}

export default () => {
  return (
    <FormDialog.Portal>
      <Button
        onClick={() => {
          const dialog = FormDialog('弹窗表单', () => {
            return (
              <FormLayout labelCol={6} wrapperCol={10}>
                <SchemaField schema={schema} />
                <FormDialog.Footer>
                  <span
                    onClick={() => {
                      dialog.close()
                    }}
                    style={{ marginLeft: 4 }}
                  >
                    扩展文案
                  </span>
                  (点击关闭弹窗)
                </FormDialog.Footer>
              </FormLayout>
            )
          })
          dialog
            .forOpen((payload, next) => {
              setTimeout(() => {
                next({
                  initialValues: {
                    aaa: '123',
                  },
                })
              }, 1000)
            })
            .forConfirm((payload, next) => {
              setTimeout(() => {
                console.log(payload)
                next(payload)
              }, 1000)
            })
            .forCancel((payload, next) => {
              setTimeout(() => {
                console.log(payload)
                next(payload)
              }, 1000)
            })
            .open()
            .then(console.log)
        }}
      >
        点我打开表单
      </Button>
    </FormDialog.Portal>
  )
}
```

## 纯 JSX 案例

```tsx
import React from 'react'
import { FormDialog, FormItem, FormLayout, Input } from '@formily/antd'
import { Field } from '@formily/react'
import { Button } from 'antd'

export default () => {
  return (
    <Button
      onClick={() => {
        const dialog = FormDialog('弹窗表单', () => {
          return (
            <FormLayout labelCol={6} wrapperCol={10}>
              <Field
                name="aaa"
                required
                title="输入框1"
                decorator={[FormItem]}
                component={[Input]}
              />
              <Field
                name="bbb"
                required
                title="输入框2"
                decorator={[FormItem]}
                component={[Input]}
              />
              <Field
                name="ccc"
                required
                title="输入框3"
                decorator={[FormItem]}
                component={[Input]}
              />
              <Field
                name="ddd"
                required
                title="输入框4"
                decorator={[FormItem]}
                component={[Input]}
              />
              <FormDialog.Footer>
                <span
                  onClick={() => {
                    dialog.close()
                  }}
                  style={{ marginLeft: 4 }}
                >
                  扩展文案
                </span>
                (点击关闭弹窗)
              </FormDialog.Footer>
            </FormLayout>
          )
        })
        dialog
          .forOpen((payload, next) => {
            setTimeout(() => {
              next({
                initialValues: {
                  aaa: '123',
                },
              })
            }, 1000)
          })
          .forConfirm((payload, next) => {
            setTimeout(() => {
              console.log(payload)
              next(payload)
            }, 1000)
          })
          .forCancel((payload, next) => {
            setTimeout(() => {
              console.log(payload)
              next(payload)
            }, 1000)
          })
          .open()
          .then(console.log)
      }}
    >
      点我打开表单
    </Button>
  )
}
```

## API

### FormDialog

```ts pure
import { IFormProps, Form } from '@formily/core'

type FormDialogRenderer =
  | React.ReactElement
  | ((form: Form) => React.ReactElement)

type ModalTitle = string | number | React.ReactElement

interface IFormDialog {
  forOpen(
    middleware: (
      props: IFormProps,
      next: (props?: IFormProps) => Promise<any>
    ) => any
  ): any //中间件拦截器，可以拦截Dialog打开
  forConfirm(
    middleware: (props: Form, next: (props?: Form) => Promise<any>) => any
  ): any //中间件拦截器，可以拦截Dialog确认
  forCancel(
    middleware: (props: Form, next: (props?: Form) => Promise<any>) => any
  ): any //中间件拦截器，可以拦截Dialog取消
  //打开弹窗，接收表单属性，可以传入initialValues/values/effects etc.
  open(props: IFormProps): Promise<any> //返回表单数据
  //关闭弹窗
  close(): void
}

interface IModalProps extends ModalProps {
  onOk?: (event: React.MouseEvent<HTMLElement>) => void | boolean // return false can prevent onOk
  onCancel?: (event: React.MouseEvent<HTMLElement>) => void | boolean // return false can prevent onCancel
  loadingText?: React.ReactNode
}

interface FormDialog {
  (title: IModalProps, id: string, renderer: FormDialogRenderer): IFormDialog
  (title: IModalProps, renderer: FormDialogRenderer): IFormDialog
  (title: ModalTitle, id: string, renderer: FormDialogRenderer): IFormDialog
  (title: ModalTitle, renderer: FormDialogRenderer): IFormDialog
}
```

`ModalProps`类型定义参考 ant design [Modal API](https://ant.design/components/modal-cn/#API)

### FormDialog.Footer

无属性，只接收子节点

### FormDialog.Portal

接收可选的 id 属性，默认值为`form-dialog`，如果一个应用存在多个 prefixCls，不同区域的弹窗内部 prefixCls 不一样，那推荐指定 id 为区域级 id
</file>

<file path="packages/antd/docs/components/FormDrawer.md">
# FormDrawer

> Drawer form, mainly used in simple event to open form scene

## Markup Schema example

```tsx
import React from 'react'
import {
  FormDrawer,
  FormItem,
  FormLayout,
  Input,
  Submit,
  Reset,
  FormButtonGroup,
} from '@formily/antd'
import { createSchemaField } from '@formily/react'
import { Button } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
  },
})

export default () => {
  return (
    <Button
      onClick={() => {
        FormDrawer('Drawer Form', () => {
          return (
            <FormLayout labelCol={6} wrapperCol={10}>
              <SchemaField>
                <SchemaField.String
                  name="aaa"
                  required
                  title="input box 1"
                  x-decorator="FormItem"
                  x-component="Input"
                />
                <SchemaField.String
                  name="bbb"
                  required
                  title="input box 2"
                  x-decorator="FormItem"
                  x-component="Input"
                />
                <SchemaField.String
                  name="ccc"
                  required
                  title="input box 3"
                  x-decorator="FormItem"
                  x-component="Input"
                />
                <SchemaField.String
                  name="ddd"
                  required
                  title="input box 4"
                  x-decorator="FormItem"
                  x-component="Input"
                />
              </SchemaField>
              <FormDrawer.Extra>
                <FormButtonGroup align="right">
                  <Submit
                    onSubmit={() => {
                      return new Promise((resolve) => {
                        setTimeout(resolve, 1000)
                      })
                    }}
                  >
                    Submit
                  </Submit>
                  <Reset>Reset</Reset>
                </FormButtonGroup>
              </FormDrawer.Extra>
            </FormLayout>
          )
        })
          .forOpen((props, next) => {
            setTimeout(() => {
              next({
                initialValues: {
                  aaa: '123',
                },
              })
            }, 1000)
          })
          .open()
          .then(console.log)
      }}
    >
      Click me to open the form
    </Button>
  )
}
```

## JSON Schema case

```tsx
import React from 'react'
import {
  FormDrawer,
  FormItem,
  FormLayout,
  Input,
  Submit,
  Reset,
  FormButtonGroup,
} from '@formily/antd'
import { createSchemaField } from '@formily/react'
import { Button } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
  },
})

const schema = {
  type: 'object',
  properties: {
    aaa: {
      type: 'string',
      title: 'input box 1',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    bbb: {
      type: 'string',
      title: 'input box 2',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    ccc: {
      type: 'string',
      title: 'input box 3',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    ddd: {
      type: 'string',
      title: 'input box 4',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
  },
}

export default () => {
  return (
    <Button
      onClick={() => {
        FormDrawer('Pop-up form', () => {
          return (
            <FormLayout labelCol={6} wrapperCol={10}>
              <SchemaField schema={schema} />
              <FormDrawer.Extra>
                <FormButtonGroup align="right">
                  <Submit
                    onSubmit={() => {
                      return new Promise((resolve) => {
                        setTimeout(resolve, 1000)
                      })
                    }}
                  >
                    Submit
                  </Submit>
                  <Reset>Reset</Reset>
                </FormButtonGroup>
              </FormDrawer.Extra>
            </FormLayout>
          )
        })
          .open({
            initialValues: {
              aaa: '123',
            },
          })
          .then(console.log)
      }}
    >
      Click me to open the form
    </Button>
  )
}
```

## Pure JSX case

```tsx
import React from 'react'
import {
  FormDrawer,
  FormItem,
  FormLayout,
  Input,
  Submit,
  Reset,
  FormButtonGroup,
} from '@formily/antd'
import { Field } from '@formily/react'
import { Button } from 'antd'

export default () => {
  return (
    <Button
      onClick={() => {
        FormDrawer('Pop-up form', () => {
          return (
            <FormLayout labelCol={6} wrapperCol={10}>
              <Field
                name="aaa"
                required
                title="input box 1"
                decorator={[FormItem]}
                component={[Input]}
              />
              <Field
                name="bbb"
                required
                title="input box 2"
                decorator={[FormItem]}
                component={[Input]}
              />
              <Field
                name="ccc"
                required
                title="input box 3"
                decorator={[FormItem]}
                component={[Input]}
              />
              <Field
                name="ddd"
                required
                title="input box 4"
                decorator={[FormItem]}
                component={[Input]}
              />
              <FormDrawer.Extra>
                <FormButtonGroup align="right">
                  <Submit
                    onSubmit={() => {
                      return new Promise((resolve) => {
                        setTimeout(resolve, 1000)
                      })
                    }}
                  >
                    Submit
                  </Submit>
                  <Reset>Reset</Reset>
                </FormButtonGroup>
              </FormDrawer.Extra>
            </FormLayout>
          )
        })
          .open({
            initialValues: {
              aaa: '123',
            },
          })
          .then(console.log)
      }}
    >
      Click me to open the form
    </Button>
  )
}
```

## API

### FormDrawer

```ts pure
import { IFormProps, Form } from '@formily/core'

type FormDrawerRenderer =
  | React.ReactElement
  | ((form: Form) => React.ReactElement)

interface IFormDrawer {
  forOpen(
    middleware: (
      props: IFormProps,
      next: (props?: IFormProps) => Promise<any>
    ) => any
  ): any //Middleware interceptor, can intercept Drawer to open
  //Open the pop-up window to receive form attributes, you can pass in initialValues/values/effects etc.
  open(props: IFormProps): Promise<any> //return form data
  //Close the pop-up window
  close(): void
}

export interface IDrawerProps extends DrawerProps {
  onClose?: (e: EventType) => void | boolean // return false can prevent onClose
  loadingText?: React.ReactNode
}

interface FormDrawer {
  (title: IDrawerProps, id: string, renderer: FormDrawerRenderer): IFormDrawer
  (title: IDrawerProps, renderer: FormDrawerRenderer): IFormDrawer
  (title: ModalTitle, id: string, renderer: FormDrawerRenderer): IFormDrawer
  (title: ModalTitle, renderer: FormDrawerRenderer): IFormDrawer
}
```

`DrawerProps` type definition reference ant design [Drawer API](https://ant.design/components/drawer-cn/#API)

### FormDrawer.Extra

No attributes, only child nodes are received

### FormDrawer.Footer

No attributes, only child nodes are received

### FormDrawer.Portal

Receive an optional id attribute, the default value is `form-drawer`, if there are multiple prefixCls in an application, and the prefixCls in the pop-up window of different regions are different, then it is recommended to specify the id as the region-level id
</file>

<file path="packages/antd/docs/components/FormDrawer.zh-CN.md">
# FormDrawer

> 抽屉表单，主要用在简单的事件打开表单场景

## Markup Schema 案例

```tsx
import React from 'react'
import {
  FormDrawer,
  FormItem,
  FormLayout,
  Input,
  Submit,
  Reset,
  FormButtonGroup,
} from '@formily/antd'
import { createSchemaField } from '@formily/react'
import { Button } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
  },
})

export default () => {
  return (
    <Button
      onClick={() => {
        FormDrawer('抽屉表单', () => {
          return (
            <FormLayout labelCol={6} wrapperCol={10}>
              <SchemaField>
                <SchemaField.String
                  name="aaa"
                  required
                  title="输入框1"
                  x-decorator="FormItem"
                  x-component="Input"
                />
                <SchemaField.String
                  name="bbb"
                  required
                  title="输入框2"
                  x-decorator="FormItem"
                  x-component="Input"
                />
                <SchemaField.String
                  name="ccc"
                  required
                  title="输入框3"
                  x-decorator="FormItem"
                  x-component="Input"
                />
                <SchemaField.String
                  name="ddd"
                  required
                  title="输入框4"
                  x-decorator="FormItem"
                  x-component="Input"
                />
              </SchemaField>
              <FormDrawer.Extra>
                <FormButtonGroup align="right">
                  <Submit
                    onSubmit={() => {
                      return new Promise((resolve) => {
                        setTimeout(resolve, 1000)
                      })
                    }}
                  >
                    提交
                  </Submit>
                  <Reset>重置</Reset>
                </FormButtonGroup>
              </FormDrawer.Extra>
            </FormLayout>
          )
        })
          .forOpen((props, next) => {
            setTimeout(() => {
              next()
            }, 1000)
          })
          .open({
            initialValues: {
              aaa: '123',
            },
          })
          .then(console.log)
      }}
    >
      点我打开表单
    </Button>
  )
}
```

## JSON Schema 案例

```tsx
import React from 'react'
import {
  FormDrawer,
  FormItem,
  FormLayout,
  Input,
  Submit,
  Reset,
  FormButtonGroup,
} from '@formily/antd'
import { createSchemaField } from '@formily/react'
import { Button } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
  },
})

const schema = {
  type: 'object',
  properties: {
    aaa: {
      type: 'string',
      title: '输入框1',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    bbb: {
      type: 'string',
      title: '输入框2',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    ccc: {
      type: 'string',
      title: '输入框3',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
    ddd: {
      type: 'string',
      title: '输入框4',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'Input',
    },
  },
}

export default () => {
  return (
    <Button
      onClick={() => {
        FormDrawer('弹窗表单', () => {
          return (
            <FormLayout labelCol={6} wrapperCol={10}>
              <SchemaField schema={schema} />
              <FormDrawer.Extra>
                <FormButtonGroup align="right">
                  <Submit
                    onSubmit={() => {
                      return new Promise((resolve) => {
                        setTimeout(resolve, 1000)
                      })
                    }}
                  >
                    提交
                  </Submit>
                  <Reset>重置</Reset>
                </FormButtonGroup>
              </FormDrawer.Extra>
            </FormLayout>
          )
        })
          .open({
            initialValues: {
              aaa: '123',
            },
          })
          .then(console.log)
      }}
    >
      点我打开表单
    </Button>
  )
}
```

## 纯 JSX 案例

```tsx
import React from 'react'
import {
  FormDrawer,
  FormItem,
  FormLayout,
  Input,
  Submit,
  Reset,
  FormButtonGroup,
} from '@formily/antd'
import { Field } from '@formily/react'
import { Button } from 'antd'

export default () => {
  return (
    <Button
      onClick={() => {
        FormDrawer('弹窗表单', () => {
          return (
            <FormLayout labelCol={6} wrapperCol={10}>
              <Field
                name="aaa"
                required
                title="输入框1"
                decorator={[FormItem]}
                component={[Input]}
              />
              <Field
                name="bbb"
                required
                title="输入框2"
                decorator={[FormItem]}
                component={[Input]}
              />
              <Field
                name="ccc"
                required
                title="输入框3"
                decorator={[FormItem]}
                component={[Input]}
              />
              <Field
                name="ddd"
                required
                title="输入框4"
                decorator={[FormItem]}
                component={[Input]}
              />
              <FormDrawer.Extra>
                <FormButtonGroup align="right">
                  <Submit
                    onSubmit={() => {
                      return new Promise((resolve) => {
                        setTimeout(resolve, 1000)
                      })
                    }}
                  >
                    提交
                  </Submit>
                  <Reset>重置</Reset>
                </FormButtonGroup>
              </FormDrawer.Extra>
            </FormLayout>
          )
        })
          .open({
            initialValues: {
              aaa: '123',
            },
          })
          .then(console.log)
      }}
    >
      点我打开表单
    </Button>
  )
}
```

## API

### FormDrawer

```ts pure
import { IFormProps, Form } from '@formily/core'

type FormDrawerRenderer =
  | React.ReactElement
  | ((form: Form) => React.ReactElement)

interface IFormDrawer {
  forOpen(
    middleware: (
      props: IFormProps,
      next: (props?: IFormProps) => Promise<any>
    ) => any
  ): any //中间件拦截器，可以拦截Drawer打开
  //打开弹窗，接收表单属性，可以传入initialValues/values/effects etc.
  open(props: IFormProps): Promise<any> //返回表单数据
  //关闭弹窗
  close(): void
}

export interface IDrawerProps extends DrawerProps {
  onClose?: (e: EventType) => void | boolean // return false can prevent onClose
  loadingText?: React.ReactNode
}

interface FormDrawer {
  (title: IDrawerProps, id: string, renderer: FormDrawerRenderer): IFormDrawer
  (title: IDrawerProps, renderer: FormDrawerRenderer): IFormDrawer
  (title: ModalTitle, id: string, renderer: FormDrawerRenderer): IFormDrawer
  (title: ModalTitle, renderer: FormDrawerRenderer): IFormDrawer
}
```

`DrawerProps`类型定义参考 ant design [Drawer API](https://ant.design/components/drawer-cn/#API)

### FormDrawer.Extra

无属性，只接收子节点

### FormDrawer.Footer

无属性，只接收子节点

### FormDrawer.Portal

接收可选的 id 属性，默认值为`form-drawer`，如果一个应用存在多个 prefixCls，不同区域的弹窗内部 prefixCls 不一样，那推荐指定 id 为区域级 id
</file>

<file path="packages/antd/docs/components/FormGrid.md">
# FormGrid

> FormGrid component

## Markup Schema example

```tsx
import React from 'react'
import { FormItem, Input, FormGrid } from '@formily/antd'
import { FormProvider, createSchemaField } from '@formily/react'
import { createForm } from '@formily/core'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    FormGrid,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Void
          x-component="FormGrid"
          x-component-props={{
            maxColumns: 3,
            minColumns: 2,
          }}
        >
          <SchemaField.String
            name="aaa"
            title="aaa"
            x-decorator="FormItem"
            x-decorator-props={{ gridSpan: 2 }}
            x-component="Input"
          />
          <SchemaField.String
            name="bbb"
            title="bbb"
            x-decorator="FormItem"
            x-component="Input"
          />
          <SchemaField.String
            name="ccc"
            title="ccc"
            x-decorator="FormItem"
            x-component="Input"
          />
          <SchemaField.String
            name="ddd"
            title="ddd"
            x-decorator="FormItem"
            x-component="Input"
          />
          <SchemaField.String
            name="eee"
            title="eee"
            x-decorator="FormItem"
            x-component="Input"
          />
          <SchemaField.String
            name="fff"
            title="fff"
            x-decorator="FormItem"
            x-component="Input"
          />
          <SchemaField.String
            name="ggg"
            title="ggg"
            x-decorator="FormItem"
            x-component="Input"
          />
        </SchemaField.Void>
      </SchemaField>
    </FormProvider>
  )
}
```

## JSON Schema case

```tsx
import React from 'react'
import { FormItem, Input, FormGrid } from '@formily/antd'
import { FormProvider, createSchemaField } from '@formily/react'
import { createForm } from '@formily/core'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    FormGrid,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    grid: {
      type: 'void',
      'x-component': 'FormGrid',
      'x-component-props': {
        minColumns: [4, 6, 10],
      },
      properties: {
        aaa: {
          type: 'string',
          title: 'AAA',
          'x-decorator': 'FormItem',
          'x-component': 'Input',
        },
        bbb: {
          type: 'string',
          title: 'BBB',
          'x-decorator': 'FormItem',
          'x-component': 'Input',
        },
        ccc: {
          type: 'string',
          title: 'CCC',
          'x-decorator': 'FormItem',
          'x-component': 'Input',
        },
        ddd: {
          type: 'string',
          title: 'DDD',
          'x-decorator': 'FormItem',
          'x-component': 'Input',
        },
        eee: {
          type: 'string',
          title: 'EEE',
          'x-decorator': 'FormItem',
          'x-component': 'Input',
        },
        fff: {
          type: 'string',
          title: 'FFF',
          'x-decorator': 'FormItem',
          'x-component': 'Input',
        },
        ggg: {
          type: 'string',
          title: 'GGG',
          'x-decorator': 'FormItem',
          'x-component': 'Input',
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} />
    </FormProvider>
  )
}
```

## Native case

```tsx
import React from 'react'
import { FormGrid } from '@formily/antd'

const { GridColumn } = FormGrid
const Cell = ({ children }) => {
  return (
    <div
      style={{
        backgroundColor: '#AAA',
        color: '#FFF',
        height: 30,
        display: 'flex',
        alignItems: 'center',
        padding: '0 10px',
      }}
    >
      {children}
    </div>
  )
}
export default () => {
  return (
    <React.Fragment>
      <p>maxColumns 3 + minColumns 2</p>
      <FormGrid maxColumns={3} minColumns={2} columnGap={4}>
        <GridColumn gridSpan={4}>
          <Cell>1</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>2</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>3</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>4</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>5</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>6</Cell>
        </GridColumn>
      </FormGrid>
      <p>maxColumns 3</p>
      <FormGrid maxColumns={3} columnGap={4}>
        <GridColumn gridSpan={2}>
          <Cell>1</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>2</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>3</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>4</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>5</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>6</Cell>
        </GridColumn>
      </FormGrid>
      <p>minColumns 2</p>
      <FormGrid minColumns={2} columnGap={4}>
        <GridColumn gridSpan={2}>
          <Cell>1</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>2</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>3</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>4</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>5</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>6</Cell>
        </GridColumn>
      </FormGrid>
      <p>Null</p>
      <FormGrid columnGap={4}>
        <GridColumn gridSpan={2}>
          <Cell>1</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>2</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>3</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>4</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>5</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>6</Cell>
        </GridColumn>
      </FormGrid>
      <p>minWidth 150 +maxColumns 3</p>
      <FormGrid minWidth={150} maxColumns={3} columnGap={4}>
        <GridColumn gridSpan={2}>
          <Cell>1</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>2</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>3</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>4</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>5</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>6</Cell>
        </GridColumn>
      </FormGrid>
      <p>maxWidth 120+minColumns 2</p>
      <FormGrid maxWidth={120} minColumns={2} columnGap={4}>
        <GridColumn gridSpan={2}>
          <Cell>1</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>2</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>3</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>4</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>5</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>6</Cell>
        </GridColumn>
      </FormGrid>
      <p>maxWidth 120 + gridSpan -1</p>
      <FormGrid maxWidth={120} columnGap={4}>
        <GridColumn gridSpan={2}>
          <Cell>1</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>2</Cell>
        </GridColumn>
        <GridColumn gridSpan={-1}>
          <Cell>3</Cell>
        </GridColumn>
      </FormGrid>
    </React.Fragment>
  )
}
```

## Query Form case

```tsx
import React, { useMemo, Fragment } from 'react'
import { createForm } from '@formily/core'
import { createSchemaField, FormProvider, observer } from '@formily/react'
import {
  Form,
  Input,
  Select,
  DatePicker,
  FormItem,
  FormGrid,
  Submit,
  Reset,
  FormButtonGroup,
} from '@formily/antd'

const useCollapseGrid = (maxRows: number) => {
  const grid = useMemo(
    () =>
      FormGrid.createFormGrid({
        maxColumns: 4,
        maxWidth: 240,
        maxRows: maxRows,
        shouldVisible: (node, grid) => {
          if (node.index === grid.childSize - 1) return true
          if (grid.maxRows === Infinity) return true
          return node.shadowRow < maxRows + 1
        },
      }),
    []
  )
  const expanded = grid.maxRows === Infinity
  const realRows = grid.shadowRows
  const computeRows = grid.fullnessLastColumn
    ? grid.shadowRows - 1
    : grid.shadowRows

  const toggle = () => {
    if (grid.maxRows === Infinity) {
      grid.maxRows = maxRows
    } else {
      grid.maxRows = Infinity
    }
  }
  const takeType = () => {
    if (realRows < maxRows + 1) return 'incomplete-wrap'
    if (computeRows > maxRows) return 'collapsible'
    return 'complete-wrap'
  }
  return {
    grid,
    expanded,
    toggle,
    type: takeType(),
  }
}

const QueryForm: React.FC = observer((props) => {
  const { grid, expanded, toggle, type } = useCollapseGrid(1)

  const renderActions = () => {
    return (
      <Fragment>
        <Submit onSubmit={console.log}>Query</Submit>
        <Reset>Reset</Reset>
      </Fragment>
    )
  }

  const renderButtonGroup = () => {
    if (type === 'incomplete-wrap') {
      return (
        <FormButtonGroup.FormItem>
          <FormButtonGroup>{renderActions()}</FormButtonGroup>
        </FormButtonGroup.FormItem>
      )
    }
    if (type === 'collapsible') {
      return (
        <Fragment>
          <FormButtonGroup>
            <a
              href=""
              onClick={(e) => {
                e.preventDefault()
                toggle()
              }}
            >
              {expanded ? 'Fold' : 'UnFold'}
            </a>
          </FormButtonGroup>
          <FormButtonGroup align="right">{renderActions()}</FormButtonGroup>
        </Fragment>
      )
    }
    return (
      <FormButtonGroup align="right" style={{ display: 'flex', width: '100%' }}>
        {renderActions()}
      </FormButtonGroup>
    )
  }

  return (
    <Form {...props} layout="vertical" feedbackLayout="terse">
      <FormGrid grid={grid}>
        {props.children}
        <FormGrid.GridColumn
          gridSpan={-1}
          style={{ display: 'flex', justifyContent: 'space-between' }}
        >
          {renderButtonGroup()}
        </FormGrid.GridColumn>
      </FormGrid>
    </Form>
  )
})

const SchemaField = createSchemaField({
  components: {
    QueryForm,
    Input,
    Select,
    DatePicker,
    FormItem,
  },
})

export default () => {
  const form = useMemo(() => createForm(), [])
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Object x-component="QueryForm">
          <SchemaField.String
            name="input1"
            title="Input 1"
            x-component="Input"
            x-decorator="FormItem"
          />
          <SchemaField.String
            name="input2"
            title="Input 2"
            x-component="Input"
            x-decorator="FormItem"
          />

          <SchemaField.String
            name="select1"
            title="Select 1"
            x-component="Select"
            x-decorator="FormItem"
          />
          <SchemaField.String
            name="select2"
            title="Select 2"
            x-component="Select"
            x-decorator="FormItem"
          />
          <SchemaField.String
            name="date"
            title="DatePicker"
            x-component="DatePicker"
            x-decorator="FormItem"
          />
          <SchemaField.String
            name="dateRange"
            title="DatePicker.RangePicker"
            x-component="DatePicker.RangePicker"
            x-decorator="FormItem"
            x-decorator-props={{
              gridSpan: 2,
            }}
          />
          <SchemaField.String
            name="select3"
            title="Select 3"
            x-component="Select"
            x-decorator="FormItem"
          />
        </SchemaField.Object>
      </SchemaField>
    </FormProvider>
  )
}
```

## API

### FormGrid

| Property name | Type                   | Description                                                                       | Default value     |
| ------------- | ---------------------- | --------------------------------------------------------------------------------- | ----------------- |
| minWidth      | `number \| number[]`   | Minimum element width                                                             | 100               |
| maxWidth      | `number \| number[]`   | Maximum element width                                                             | -                 |
| minColumns    | `number \| number[]`   | Minimum number of columns                                                         | 0                 |
| maxColumns    | `number \| number[]`   | Maximum number of columns                                                         | -                 |
| breakpoints   | number[]               | Container size breakpoints                                                        | `[720,1280,1920]` |
| columnGap     | number                 | Column spacing                                                                    | 8                 |
| rowGap        | number                 | Row spacing                                                                       | 4                 |
| colWrap       | boolean                | Wrap                                                                              | true              |
| strictAutoFit | boolean                | Is width strictly limited by maxWidth                                             | false             |
| shouldVisible | `(node,grid)=>boolean` | Whether to show the current node                                                  | `()=>true`        |
| grid          | `Grid`                 | Grid instance passed in from outside, used to implement more complex layout logic | -                 |

note:

- minWidth takes priority over minColumn
- maxWidth has priority over maxColumn
- The array format of minWidth/maxWidth/minColumns/maxColumns represents the mapping with the breakpoint array

### FormGrid.GridColumn

| Property name | Type   | Description                                                                                                              | Default value |
| ------------- | ------ | ------------------------------------------------------------------------------------------------------------------------ | ------------- |
| gridSpan      | number | The number of columns spanned by the element, if it is -1, it will automatically fill the cell across columns in reverse | 1             |

### FormGrid.createFormGrid

Read the Grid instance from the context

```ts
interface createFormGrid {
  (props: IGridProps): Grid
}
```

- IGridProps reference FormGrid properties
- Grid instance attribute method reference https://github.com/alibaba/formily/tree/formily_next/packages/grid

### FormGrid.useFormGrid

Read the Grid instance from the context

```ts
interface useFormGrid {
  (): Grid
}
```

- Grid instance attribute method reference https://github.com/alibaba/formily/tree/formily_next/packages/grid
</file>

<file path="packages/antd/docs/components/FormGrid.zh-CN.md">
# FormGrid

> FormGrid 组件

## Markup Schema 案例

```tsx
import React from 'react'
import { FormItem, Input, FormGrid } from '@formily/antd'
import { FormProvider, createSchemaField } from '@formily/react'
import { createForm } from '@formily/core'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    FormGrid,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Void
          x-component="FormGrid"
          x-component-props={{
            maxColumns: 3,
            minColumns: 2,
          }}
        >
          <SchemaField.String
            name="aaa"
            title="aaa"
            x-decorator="FormItem"
            x-decorator-props={{ gridSpan: 2 }}
            x-component="Input"
          />
          <SchemaField.String
            name="bbb"
            title="bbb"
            x-decorator="FormItem"
            x-component="Input"
          />
          <SchemaField.String
            name="ccc"
            title="ccc"
            x-decorator="FormItem"
            x-component="Input"
          />
          <SchemaField.String
            name="ddd"
            title="ddd"
            x-decorator="FormItem"
            x-component="Input"
          />
          <SchemaField.String
            name="eee"
            title="eee"
            x-decorator="FormItem"
            x-component="Input"
          />
          <SchemaField.String
            name="fff"
            title="fff"
            x-decorator="FormItem"
            x-component="Input"
          />
          <SchemaField.String
            name="ggg"
            title="ggg"
            x-decorator="FormItem"
            x-component="Input"
          />
        </SchemaField.Void>
      </SchemaField>
    </FormProvider>
  )
}
```

## JSON Schema 案例

```tsx
import React from 'react'
import { FormItem, Input, FormGrid } from '@formily/antd'
import { FormProvider, createSchemaField } from '@formily/react'
import { createForm } from '@formily/core'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    Input,
    FormGrid,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    grid: {
      type: 'void',
      'x-component': 'FormGrid',
      'x-component-props': {
        minColumns: [4, 6, 10],
      },
      properties: {
        aaa: {
          type: 'string',
          title: 'AAA',
          'x-decorator': 'FormItem',
          'x-component': 'Input',
        },
        bbb: {
          type: 'string',
          title: 'BBB',
          'x-decorator': 'FormItem',
          'x-component': 'Input',
        },
        ccc: {
          type: 'string',
          title: 'CCC',
          'x-decorator': 'FormItem',
          'x-component': 'Input',
        },
        ddd: {
          type: 'string',
          title: 'DDD',
          'x-decorator': 'FormItem',
          'x-component': 'Input',
        },
        eee: {
          type: 'string',
          title: 'EEE',
          'x-decorator': 'FormItem',
          'x-component': 'Input',
        },
        fff: {
          type: 'string',
          title: 'FFF',
          'x-decorator': 'FormItem',
          'x-component': 'Input',
        },
        ggg: {
          type: 'string',
          title: 'GGG',
          'x-decorator': 'FormItem',
          'x-component': 'Input',
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} />
    </FormProvider>
  )
}
```

## 原生 案例

```tsx
import React from 'react'
import { FormGrid } from '@formily/antd'

const { GridColumn } = FormGrid
const Cell = ({ children }) => {
  return (
    <div
      style={{
        backgroundColor: '#AAA',
        color: '#FFF',
        height: 30,
        display: 'flex',
        alignItems: 'center',
        padding: '0 10px',
      }}
    >
      {children}
    </div>
  )
}
export default () => {
  return (
    <React.Fragment>
      <p>maxColumns 3 + minColumns 2</p>
      <FormGrid maxColumns={3} minColumns={2} columnGap={4}>
        <GridColumn gridSpan={4}>
          <Cell>1</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>2</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>3</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>4</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>5</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>6</Cell>
        </GridColumn>
      </FormGrid>
      <p>maxColumns 3</p>
      <FormGrid maxColumns={3} columnGap={4}>
        <GridColumn gridSpan={2}>
          <Cell>1</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>2</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>3</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>4</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>5</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>6</Cell>
        </GridColumn>
      </FormGrid>
      <p>minColumns 2</p>
      <FormGrid minColumns={2} columnGap={4}>
        <GridColumn gridSpan={2}>
          <Cell>1</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>2</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>3</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>4</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>5</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>6</Cell>
        </GridColumn>
      </FormGrid>
      <p>Null</p>
      <FormGrid columnGap={4}>
        <GridColumn gridSpan={2}>
          <Cell>1</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>2</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>3</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>4</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>5</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>6</Cell>
        </GridColumn>
      </FormGrid>
      <p>minWidth 150 +maxColumns 3</p>
      <FormGrid minWidth={150} maxColumns={3} columnGap={4}>
        <GridColumn gridSpan={2}>
          <Cell>1</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>2</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>3</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>4</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>5</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>6</Cell>
        </GridColumn>
      </FormGrid>
      <p>maxWidth 120+minColumns 2</p>
      <FormGrid maxWidth={120} minColumns={2} columnGap={4}>
        <GridColumn gridSpan={2}>
          <Cell>1</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>2</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>3</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>4</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>5</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>6</Cell>
        </GridColumn>
      </FormGrid>
      <p>maxWidth 120 + gridSpan -1</p>
      <FormGrid maxWidth={120} columnGap={4}>
        <GridColumn gridSpan={2}>
          <Cell>1</Cell>
        </GridColumn>
        <GridColumn>
          <Cell>2</Cell>
        </GridColumn>
        <GridColumn gridSpan={-1}>
          <Cell>3</Cell>
        </GridColumn>
      </FormGrid>
    </React.Fragment>
  )
}
```

## 查询表单实现案例

```tsx
import React, { useMemo, Fragment } from 'react'
import { createForm } from '@formily/core'
import { createSchemaField, FormProvider, observer } from '@formily/react'
import {
  Form,
  Input,
  Select,
  DatePicker,
  FormItem,
  FormGrid,
  Submit,
  Reset,
  FormButtonGroup,
} from '@formily/antd'

const useCollapseGrid = (maxRows: number) => {
  const grid = useMemo(
    () =>
      FormGrid.createFormGrid({
        maxColumns: 4,
        maxWidth: 240,
        maxRows: maxRows,
        shouldVisible: (node, grid) => {
          if (node.index === grid.childSize - 1) return true
          if (grid.maxRows === Infinity) return true
          return node.shadowRow < maxRows + 1
        },
      }),
    []
  )
  const expanded = grid.maxRows === Infinity
  const realRows = grid.shadowRows
  const computeRows = grid.fullnessLastColumn
    ? grid.shadowRows - 1
    : grid.shadowRows

  const toggle = () => {
    if (grid.maxRows === Infinity) {
      grid.maxRows = maxRows
    } else {
      grid.maxRows = Infinity
    }
  }
  const takeType = () => {
    if (realRows < maxRows + 1) return 'incomplete-wrap'
    if (computeRows > maxRows) return 'collapsible'
    return 'complete-wrap'
  }
  return {
    grid,
    expanded,
    toggle,
    type: takeType(),
  }
}

const QueryForm: React.FC = observer((props) => {
  const { grid, expanded, toggle, type } = useCollapseGrid(1)

  const renderActions = () => {
    return (
      <Fragment>
        <Submit onSubmit={console.log}>查询</Submit>
        <Reset>重置</Reset>
      </Fragment>
    )
  }

  const renderButtonGroup = () => {
    if (type === 'incomplete-wrap') {
      return (
        <FormButtonGroup.FormItem>
          <FormButtonGroup>{renderActions()}</FormButtonGroup>
        </FormButtonGroup.FormItem>
      )
    }
    if (type === 'collapsible') {
      return (
        <Fragment>
          <FormButtonGroup>
            <a
              href=""
              onClick={(e) => {
                e.preventDefault()
                toggle()
              }}
            >
              {expanded ? '收起' : '展开'}
            </a>
          </FormButtonGroup>
          <FormButtonGroup align="right">{renderActions()}</FormButtonGroup>
        </Fragment>
      )
    }
    return (
      <FormButtonGroup align="right" style={{ display: 'flex', width: '100%' }}>
        {renderActions()}
      </FormButtonGroup>
    )
  }

  return (
    <Form {...props} layout="vertical" feedbackLayout="terse">
      <FormGrid grid={grid}>
        {props.children}
        <FormGrid.GridColumn
          gridSpan={-1}
          style={{ display: 'flex', justifyContent: 'space-between' }}
        >
          {renderButtonGroup()}
        </FormGrid.GridColumn>
      </FormGrid>
    </Form>
  )
})

const SchemaField = createSchemaField({
  components: {
    QueryForm,
    Input,
    Select,
    DatePicker,
    FormItem,
  },
})

export default () => {
  const form = useMemo(() => createForm(), [])
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Object x-component="QueryForm">
          <SchemaField.String
            name="input1"
            title="Input 1"
            x-component="Input"
            x-decorator="FormItem"
          />
          <SchemaField.String
            name="input2"
            title="Input 2"
            x-component="Input"
            x-decorator="FormItem"
          />

          <SchemaField.String
            name="select1"
            title="Select 1"
            x-component="Select"
            x-decorator="FormItem"
          />
          <SchemaField.String
            name="select2"
            title="Select 2"
            x-component="Select"
            x-decorator="FormItem"
          />
          <SchemaField.String
            name="date"
            title="DatePicker"
            x-component="DatePicker"
            x-decorator="FormItem"
          />
          <SchemaField.String
            name="dateRange"
            title="DatePicker.RangePicker"
            x-component="DatePicker.RangePicker"
            x-decorator="FormItem"
            x-decorator-props={{
              gridSpan: 2,
            }}
          />
          <SchemaField.String
            name="select3"
            title="Select 3"
            x-component="Select"
            x-decorator="FormItem"
          />
        </SchemaField.Object>
      </SchemaField>
    </FormProvider>
  )
}
```

## API

### FormGrid

| 属性名        | 类型                   | 描述                                                           | 默认值            |
| ------------- | ---------------------- | -------------------------------------------------------------- | ----------------- |
| minWidth      | `number \| number[]`   | 元素最小宽度                                                   | 100               |
| maxWidth      | `number \| number[]`   | 元素最大宽度                                                   | -                 |
| minColumns    | `number \| number[]`   | 最小列数                                                       | 0                 |
| maxColumns    | `number \| number[]`   | 最大列数                                                       | -                 |
| breakpoints   | number[]               | 容器尺寸断点                                                   | `[720,1280,1920]` |
| columnGap     | number                 | 列间距                                                         | 8                 |
| rowGap        | number                 | 行间距                                                         | 4                 |
| colWrap       | boolean                | 自动换行                                                       | true              |
| strictAutoFit | boolean                | GridItem 宽度是否严格受限于 maxWidth，不受限的话会自动占满容器 | false             |
| shouldVisible | `(node,grid)=>boolean` | 是否需要显示当前节点                                           | `()=>true`        |
| grid          | `Grid`                 | 外部传入 Grid 实例，用于实现更复杂的布局逻辑                   | -                 |

注意：

- minWidth 生效优先级高于 minColumn
- maxWidth 优先级高于 maxColumn
- minWidth/maxWidth/minColumns/maxColumns 的数组格式代表与断点数组映射

### FormGrid.GridColumn

| 属性名   | 类型   | 描述                                                 | 默认值 |
| -------- | ------ | ---------------------------------------------------- | ------ |
| gridSpan | number | 元素所跨列数，如果为-1，那么会自动反向跨列填补单元格 | 1      |

### FormGrid.createFormGrid

从上下文中读取 Grid 实例

```ts
interface createFormGrid {
  (props: IGridProps): Grid
}
```

- IGridProps 参考 FormGrid 属性
- Grid 实例属性方法参考 https://github.com/alibaba/formily/tree/formily_next/packages/grid

### FormGrid.useFormGrid

从上下文中读取 Grid 实例

```ts
interface useFormGrid {
  (): Grid
}
```

- Grid 实例属性方法参考 https://github.com/alibaba/formily/tree/formily_next/packages/grid
</file>

<file path="packages/antd/docs/components/FormItem.md">
# FormItem

> The brand-new FormItem component, compared to Antd's FormItem, it supports more functions. At the same time, it is positioned as a pure style component and does not manage the state of the form, so it will be lighter and more convenient for customization

## Markup Schema example

```tsx
import React from 'react'
import { Input, Select, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    Select,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="input"
        title="input box"
        x-decorator="FormItem"
        x-component="Input"
        required
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema case

```tsx
import React from 'react'
import { Input, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    input: {
      type: 'string',
      title: 'input box',
      'x-decorator': 'FormItem',
      'x-component': 'Input',
      'x-component-props': {
        style: {
          width: 240,
        },
      },
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## Pure JSX case

```tsx
import React from 'react'
import { Input, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="input"
      title="input box"
      required
      decorator={[FormItem]}
      component={[
        Input,
        {
          style: {
            width: 240,
          },
        },
      ]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## Commonly used attribute cases

```tsx
import React from 'react'
import {
  Input,
  Radio,
  TreeSelect,
  Cascader,
  Select,
  DatePicker,
  FormItem,
  NumberPicker,
  Switch,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const Title = (props) => <h3>{props.text}</h3>

const SchemaField = createSchemaField({
  components: {
    Input,
    Select,
    Cascader,
    TreeSelect,
    DatePicker,
    NumberPicker,
    Switch,
    Radio,
    FormItem,
    Title,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Void
          x-component="Title"
          x-component-props={{ text: 'Display when label is empty' }}
        />
        <SchemaField.String
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            labelWidth: 300,
          }}
        />
        <SchemaField.String
          title=""
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            labelWidth: 300,
          }}
        />
        <SchemaField.Void
          x-component="Title"
          x-component-props={{ text: 'colon' }}
        />
        <SchemaField.String
          title="default"
          x-decorator="FormItem"
          x-component="Input"
        />
        <SchemaField.String
          title="no colon (colon=false)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            colon: false,
          }}
        />

        <SchemaField.Void
          x-component="Title"
          x-component-props={{ text: 'Fixed width settings' }}
        />
        <SchemaField.String
          title="Fixed label width (labelWidth)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            labelWidth: 300,
          }}
        />
        <SchemaField.String
          title="Fixed label width (labelWidth) overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow overflow"
          description="description description"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            labelWidth: 300,
            tooltip: 'Prompt Tip',
            tooltipLayout: 'text',
          }}
        />
        <SchemaField.String
          title="Fixed label width (labelWidth) newline newline newline newline newline newline newline newline newline newline newline newline newline newline newline newline newline newline newline newline newline newline newline newline newline"
          description="description description"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            labelWidth: 300,
            labelWrap: true,
            tooltip: 'Prompt Tip',
          }}
        />
        <SchemaField.String
          title="fixed content width (wrapperWidth)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            labelWidth: 300,
            wrapperWidth: 300,
          }}
        />

        <SchemaField.Void
          x-component="Title"
          x-component-props={{ text: 'Alignment settings' }}
        />
        <SchemaField.String
          title="labelLeft Alignment(labelAlign=left)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            labelWidth: 300,
            labelAlign: 'left',
          }}
        />
        <SchemaField.String
          title="label right alignment (labelAlign=right default)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            labelWidth: 300,
            labelAlign: 'right',
          }}
        />

        <SchemaField.String
          title="Content left aligned (wrapperAlign=left default)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            labelWidth: 300,
            wrapperWidth: 240,
            wrapperAlign: 'left',
          }}
        />
        <SchemaField.String
          title="Content align right (wrapperAlign=right)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            labelWidth: 300,
            wrapperWidth: 240,
            wrapperAlign: 'right',
          }}
        />

        <SchemaField.String
          title="tooltip"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            tooltip: 'tooltip',
          }}
        />

        <SchemaField.Void
          x-component="Title"
          x-component-props={{ text: 'Is it full?' }}
        />

        <SchemaField.String
          title="The default is not full (fullness=false)"
          x-decorator="FormItem"
          x-component="Select"
        />
        <SchemaField.String
          title="Fullness(fullness=true)"
          x-decorator="FormItem"
          x-component="Select"
          x-decorator-props={{
            fullness: true,
          }}
        />

        <SchemaField.Void
          x-component="Title"
          x-component-props={{ text: 'auxiliary information' }}
        />

        <SchemaField.String
          title="Required asterisk"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            asterisk: true,
            labelCol: 6,
            wrapperCol: 10,
          }}
        />

        <SchemaField.String
          title="prefix"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            addonBefore: 'addonBefore',
            labelCol: 6,
            wrapperCol: 10,
          }}
        />
        <SchemaField.String
          title="suffix"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            addonAfter: 'addonAfter',
            labelCol: 6,
            wrapperCol: 10,
          }}
        />

        <SchemaField.String
          title="Help information feedbackText"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            feedbackText: 'feedbackText',
            labelCol: 6,
            wrapperCol: 10,
          }}
        />

        <SchemaField.String
          title="extra information extra"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            feedbackText: 'feedbackText',
            extra: 'extra',
            labelCol: 6,
            wrapperCol: 10,
          }}
        />
      </SchemaField>
    </FormProvider>
  )
}
```

## Required style

```tsx
import React, { useState } from 'react'
import { Input, FormItem, FormLayout } from '@formily/antd'
import { Radio } from 'antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const form = createForm()

export default () => {
  const [requiredMark, setRequiredMark] = useState(true)
  return (
    <div>
      <p>
        Required Mark：
        <Radio.Group
          value={requiredMark}
          onChange={(e) => setRequiredMark(e.target.value)}
        >
          <Radio.Button value="optional">optional</Radio.Button>
          <Radio.Button value={true}>true</Radio.Button>
          <Radio.Button value={false}>false</Radio.Button>
        </Radio.Group>
      </p>
      <FormProvider form={form}>
        <FormLayout requiredMark={requiredMark}>
          <SchemaField>
            <SchemaField.String
              title="I am Required"
              required
              x-decorator="FormItem"
              x-component="Input"
            />
            <SchemaField.String
              title="I am Optional"
              x-decorator="FormItem"
              x-component="Input"
            />
            <SchemaField.String
              default="When the field is not editable, always hide the required/optional flag"
              x-editable={false}
              x-decorator="FormItem"
              x-component="Input"
            />
            <SchemaField.String
              title="I am Required"
              required
              default="Not editable"
              x-editable={false}
              x-decorator="FormItem"
              x-component="Input"
            />
            <SchemaField.String
              title="I am Optional"
              default="Not editable"
              x-editable={false}
              x-decorator="FormItem"
              x-component="Input"
            />
          </SchemaField>
        </FormLayout>
      </FormProvider>
    </div>
  )
}
```

## Borderless case

Set to remove the component border

```tsx
import React from 'react'
import {
  Input,
  Radio,
  TreeSelect,
  Cascader,
  Select,
  DatePicker,
  FormItem,
  NumberPicker,
  Switch,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const Title = (props) => <h3>{props.text}</h3>

const SchemaField = createSchemaField({
  components: {
    Input,
    Select,
    Cascader,
    TreeSelect,
    DatePicker,
    NumberPicker,
    Switch,
    Radio,
    FormItem,
    Title,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.String
          name="input"
          title="Input"
          x-decorator="FormItem"
          x-component="Input"
          required
          x-decorator-props={{
            bordered: false,
          }}
        />
        <SchemaField.String
          name="Select"
          title="Select"
          x-decorator="FormItem"
          x-component="Select"
          required
          x-decorator-props={{
            bordered: false,
          }}
        />
        <SchemaField.String
          name="Select"
          title="Select"
          x-decorator="FormItem"
          x-component="Select"
          required
          x-decorator-props={{
            bordered: false,
          }}
        />
        <SchemaField.String
          name="Cascader"
          title="Cascader"
          x-decorator="FormItem"
          x-component="Cascader"
          required
          x-decorator-props={{
            bordered: false,
          }}
        />
        <SchemaField.String
          name="DatePicker"
          title="DatePicker"
          x-decorator="FormItem"
          x-component="DatePicker"
          required
          x-decorator-props={{
            bordered: false,
          }}
        />
        <SchemaField.String
          name="NumberPicker"
          title="NumberPicker"
          x-decorator="FormItem"
          x-component="NumberPicker"
          required
          x-decorator-props={{
            bordered: false,
          }}
        />
        <SchemaField.String
          name="TreeSelect"
          title="TreeSelect"
          x-decorator="FormItem"
          x-component="TreeSelect"
          required
          x-decorator-props={{
            bordered: false,
          }}
        />
        <SchemaField.Boolean
          name="Switch"
          title="Switch"
          x-decorator="FormItem"
          x-component="Switch"
          required
          x-decorator-props={{
            bordered: false,
          }}
        />
      </SchemaField>
    </FormProvider>
  )
}
```

## Embedded mode case

Set the form component to inline mode

```tsx
import React from 'react'
import {
  Input,
  Radio,
  TreeSelect,
  Cascader,
  Select,
  DatePicker,
  FormItem,
  NumberPicker,
  Switch,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const Title = (props) => <h3>{props.text}</h3>

const SchemaField = createSchemaField({
  components: {
    Input,
    Select,
    Cascader,
    TreeSelect,
    DatePicker,
    NumberPicker,
    Switch,
    Radio,
    FormItem,
    Title,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.String
          name="input"
          title="Input"
          x-decorator="FormItem"
          x-component="Input"
          required
          x-decorator-props={{
            inset: true,
          }}
        />
        <SchemaField.String
          name="Select"
          title="Select"
          x-decorator="FormItem"
          x-component="Select"
          required
          x-decorator-props={{
            inset: true,
          }}
        />
        <SchemaField.String
          name="Select"
          title="Select"
          x-decorator="FormItem"
          x-component="Select"
          required
          x-decorator-props={{
            inset: true,
          }}
        />
        <SchemaField.String
          name="Cascader"
          title="Cascader"
          x-decorator="FormItem"
          x-component="Cascader"
          required
          x-decorator-props={{
            inset: true,
          }}
        />
        <SchemaField.String
          name="DatePicker"
          title="DatePicker"
          x-decorator="FormItem"
          x-component="DatePicker"
          required
          x-decorator-props={{
            inset: true,
          }}
        />
        <SchemaField.String
          name="NumberPicker"
          title="NumberPicker"
          x-decorator="FormItem"
          x-component="NumberPicker"
          required
          x-decorator-props={{
            inset: true,
          }}
        />
        <SchemaField.String
          name="TreeSelect"
          title="TreeSelect"
          x-decorator="FormItem"
          x-component="TreeSelect"
          required
          x-decorator-props={{
            inset: true,
          }}
        />
        <SchemaField.Boolean
          name="Switch"
          title="Switch"
          x-decorator="FormItem"
          x-component="Switch"
          required
          x-decorator-props={{
            inset: false,
          }}
        />
      </SchemaField>
    </FormProvider>
  )
}
```

## Feedback Customization Case

The button for specifying feedback can be passed in through `feedbackIcon`

```tsx
import React from 'react'
import {
  Input,
  Radio,
  TreeSelect,
  Cascader,
  Select,
  DatePicker,
  TimePicker,
  FormItem,
  FormLayout,
  NumberPicker,
  Switch,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { CheckCircleFilled, LoadingOutlined } from '@ant-design/icons'
const Title = (props) => <h3>{props.text}</h3>

const SchemaField = createSchemaField({
  components: {
    Input,
    Select,
    Cascader,
    TreeSelect,
    DatePicker,
    TimePicker,
    NumberPicker,
    Switch,
    Radio,
    FormItem,
    Title,
    FormLayout,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.String
          title="error status (feedbackStatus=error)"
          x-decorator="FormItem"
          x-component="Input"
          description="description"
          x-decorator-props={{
            feedbackStatus: 'error',
          }}
        />

        <SchemaField.String
          title="Warning Status(feedbackStatus=warning)"
          x-decorator="FormItem"
          x-component="Input"
          description="description"
          x-decorator-props={{
            feedbackStatus: 'warning',
          }}
        />

        <SchemaField.String
          title="Success Status (feedbackStatus=success)"
          x-decorator="FormItem"
          x-component="Input"
          description="description"
          x-decorator-props={{
            feedbackStatus: 'success',
            feedbackIcon: <CheckCircleFilled style={{ color: '#52c41a' }} />,
          }}
        />

        <SchemaField.String
          title="Loading Status(feedbackStatus=pending)"
          x-decorator="FormItem"
          x-component="Input"
          description="description"
          x-decorator-props={{
            feedbackStatus: 'pending',
            feedbackIcon: <LoadingOutlined style={{ color: '#1890ff' }} />,
          }}
        />

        <SchemaField.String
          title="Status border style disabled(feedbackStatus=error)"
          x-decorator="FormItem"
          x-component="Input"
          description="description"
          x-decorator-props={{
            enableOutlineFeedback: false,
            feedbackStatus: 'error',
          }}
        />

        <SchemaField.Void
          x-component="Title"
          x-component-props={{ text: 'Layout of feedback information' }}
        />

        <SchemaField.String
          title="Compact mode required"
          x-decorator="FormItem"
          x-component="Input"
          required
          x-decorator-props={{
            feedbackLayout: 'terse',
          }}
        />

        <SchemaField.String
          title="Compact mode has feedback(feedbackLayout=terse)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            feedbackStatus: 'error',
            feedbackText: 'error message',
            feedbackLayout: 'terse',
          }}
        />

        <SchemaField.String
          title="Compact mode without feedback(feedbackLayout=terse)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            feedbackLayout: 'terse',
          }}
        />

        <SchemaField.String
          title="loose mode (feedbackLayout=loose)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            feedbackStatus: 'error',
            feedbackText: 'error message',
            feedbackLayout: 'loose',
          }}
        />

        <SchemaField.String
          title="Popup Mode (feedbackLayout=popover)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            feedbackStatus: 'warning',
            feedbackText: 'warning message',
            feedbackLayout: 'popover',
          }}
        />

        <SchemaField.String
          title="Popup Mode (feedbackLayout=popover)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            feedbackStatus: 'error',
            feedbackText: 'error message',
            feedbackLayout: 'popover',
          }}
        />
        <SchemaField.String
          title="Popup Mode (feedbackLayout=popover)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            feedbackStatus: 'success',
            feedbackText: 'success message',
            feedbackLayout: 'popover',
          }}
        />

        <SchemaField.Void
          x-component="Title"
          x-component-props={{ text: 'Component adaptation' }}
        />
        <SchemaField.Void
          x-component="FormLayout"
          x-component-props={{ layout: 'vertical' }}
        >
          <SchemaField.String
            title="Select"
            x-decorator="FormItem"
            x-component="Select"
            x-decorator-props={{
              feedbackStatus: 'success',
              feedbackIcon: <CheckCircleFilled style={{ color: '#52c41a' }} />,
            }}
          />

          <SchemaField.String
            title="DatePicker"
            x-decorator="FormItem"
            x-component="DatePicker"
            x-decorator-props={{
              feedbackStatus: 'success',
              feedbackIcon: <CheckCircleFilled style={{ color: '#52c41a' }} />,
            }}
          />
          <SchemaField.String
            title="DatePicker.RangePicker"
            x-decorator="FormItem"
            x-component="DatePicker.RangePicker"
            x-decorator-props={{
              feedbackStatus: 'success',
              feedbackIcon: <CheckCircleFilled style={{ color: '#52c41a' }} />,
            }}
          />
          <SchemaField.String
            title="DatePicker.YearPicker"
            x-decorator="FormItem"
            x-component="DatePicker.YearPicker"
            x-decorator-props={{
              feedbackStatus: 'success',
              feedbackIcon: <CheckCircleFilled style={{ color: '#52c41a' }} />,
            }}
          />
          <SchemaField.String
            title="DatePicker.MonthPicker"
            x-decorator="FormItem"
            x-component="DatePicker.MonthPicker"
            x-decorator-props={{
              feedbackStatus: 'success',
              feedbackIcon: <CheckCircleFilled style={{ color: '#52c41a' }} />,
            }}
          />
          <SchemaField.String
            title="DatePicker.TimePicker"
            x-decorator="FormItem"
            x-component="TimePicker"
            x-decorator-props={{
              feedbackStatus: 'success',
              feedbackIcon: <CheckCircleFilled style={{ color: '#52c41a' }} />,
            }}
          />
          <SchemaField.String
            title="NumberPicker"
            x-decorator="FormItem"
            x-component="NumberPicker"
            x-decorator-props={{
              feedbackStatus: 'success',
              feedbackIcon: <CheckCircleFilled style={{ color: '#52c41a' }} />,
            }}
          />

          <SchemaField.String
            title="TreeSelect"
            x-decorator="FormItem"
            x-component="TreeSelect"
            x-decorator-props={{
              feedbackStatus: 'success',
              feedbackIcon: <CheckCircleFilled style={{ color: '#52c41a' }} />,
            }}
          />

          <SchemaField.String
            title="Cascader"
            x-decorator="FormItem"
            x-component="Cascader"
            x-decorator-props={{
              feedbackStatus: 'success',
              feedbackIcon: <CheckCircleFilled style={{ color: '#52c41a' }} />,
            }}
          />
        </SchemaField.Void>
      </SchemaField>
    </FormProvider>
  )
}
```

## Size control case

```tsx
import React from 'react'
import {
  Input,
  Radio,
  TreeSelect,
  Cascader,
  Select,
  DatePicker,
  FormItem,
  NumberPicker,
  Switch,
} from '@formily/antd'
import { createForm, onFieldChange } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const Div = (props) => <div {...props} />

const SchemaField = createSchemaField({
  components: {
    Input,
    Select,
    Cascader,
    TreeSelect,
    DatePicker,
    NumberPicker,
    Switch,
    Radio,
    FormItem,
    Div,
  },
})

const form = createForm({
  values: {
    size: 'default',
  },
  effects: () => {
    onFieldChange('size', ['value'], (field, form) => {
      form.setFieldState('sizeWrap.*', (state) => {
        if (state.decorator[1]) {
          state.decorator[1].size = field.value
        }
      })
    })
  },
})

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.String
          name="size"
          title="Radio.Group"
          x-decorator="FormItem"
          x-component="Radio.Group"
          enum={[
            { value: 'small', label: 'Small' },
            { value: 'default', label: 'Default' },
            { value: 'large', label: 'Large' },
          ]}
        />
        <SchemaField.Void name="sizeWrap" x-component="Div">
          <SchemaField.String
            name="input"
            title="Input"
            x-decorator="FormItem"
            x-component="Input"
            required
          />
          <SchemaField.String
            name="select1"
            title="Multiple Select"
            x-decorator="FormItem"
            x-component="Select"
            enum={[
              {
                label: 'Option 1',
                value: 1,
              },
              {
                label: 'Option 2',
                value: 2,
              },
            ]}
            x-component-props={{
              mode: 'multiple',
              placeholder: 'Please choose',
            }}
            required
          />
          <SchemaField.String
            name="select2"
            title="Select"
            x-decorator="FormItem"
            x-component="Select"
            enum={[
              {
                label: 'Option 1',
                value: 1,
              },
              {
                label: 'Option 2',
                value: 2,
              },
            ]}
            x-component-props={{
              placeholder: 'Please choose',
            }}
            required
          />
          <SchemaField.String
            name="Cascader"
            title="Cascader"
            x-decorator="FormItem"
            x-component="Cascader"
            required
          />
          <SchemaField.String
            name="DatePicker"
            title="DatePicker"
            x-decorator="FormItem"
            x-component="DatePicker"
            required
          />
          <SchemaField.String
            name="NumberPicker"
            title="NumberPicker"
            x-decorator="FormItem"
            x-component="NumberPicker"
            required
          />
          <SchemaField.String
            name="TreeSelect"
            title="TreeSelect"
            x-decorator="FormItem"
            x-component="TreeSelect"
            required
          />
          <SchemaField.Boolean
            name="Switch"
            title="Switch"
            x-decorator="FormItem"
            x-component="Switch"
            required
          />
        </SchemaField.Void>
      </SchemaField>
    </FormProvider>
  )
}
```

## API

### FormItem

| Property name         | Type                                                   | Description                                                                                                                                   | Default value       |
| --------------------- | ------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------- | ------------------- |
| label                 | ReactNode                                              | label                                                                                                                                         | -                   |
| style                 | CSSProperties                                          | Style                                                                                                                                         | -                   |
| labelStyle            | CSSProperties                                          | Label style                                                                                                                                   | -                   |
| wrapperStyle          | CSSProperties                                          | Component container style                                                                                                                     | -                   |
| className             | string                                                 | Component style class name                                                                                                                    | -                   |
| colon                 | boolean                                                | colon                                                                                                                                         | true                |
| tooltip               | ReactNode                                              | Question mark prompt                                                                                                                          | -                   |
| tooltipLayout         | `"icon" \| "text"`                                     | Ask the prompt layout                                                                                                                         | `"icon"`            |
| tooltipIcon           | ReactNode                                              | Ask the prompt icon                                                                                                                           | `?`                 |
| labelAlign            | `"left"` \| `"right"`                                  | Label text alignment                                                                                                                          | `"right"`           |
| labelWrap             | boolean                                                | Label change, otherwise an ellipsis appears, hover has tooltip                                                                                | false               |
| labelWidth            | `number \| string`                                     | Label fixed width                                                                                                                             | -                   |
| wrapperWidth          | `number \| string`                                     | Content fixed width                                                                                                                           | -                   |
| labelCol              | number                                                 | The number of columns occupied by the label grid, and the number of content columns add up to 24                                              | -                   |
| wrapperCol            | number                                                 | The number of columns occupied by the content grid, and the number of label columns add up to 24                                              | -                   |
| wrapperAlign          | `"left"` \| `"right"`                                  | Content text alignment                                                                                                                        | `"left"`            |
| wrapperWrap           | boolean                                                | Change the content, otherwise an ellipsis appears, and hover has tooltip                                                                      | false               |
| fullness              | boolean                                                | fullness                                                                                                                                      | false               |
| addonBefore           | ReactNode                                              | Prefix content                                                                                                                                | -                   |
| addonAfter            | ReactNode                                              | Suffix content                                                                                                                                | -                   |
| size                  | `"small"` \| `"default"` \| `"large"`                  | size                                                                                                                                          | -                   |
| inset                 | boolean                                                | Is it an inline layout                                                                                                                        | false               |
| extra                 | ReactNode                                              | Extended description script                                                                                                                   | -                   |
| feedbackText          | ReactNode                                              | Feedback Case                                                                                                                                 | -                   |
| feedbackLayout        | `"loose"` \| `"terse"` \| `"popover" \| "none"`        | Feedback layout                                                                                                                               | -                   |
| feedbackStatus        | `"error"` \| `"warning"` \| `"success"` \| `"pending"` | Feedback layout                                                                                                                               | -                   |
| feedbackIcon          | ReactNode                                              | Feedback icon                                                                                                                                 | -                   |
| enableOutlineFeedback | boolean                                                | Enable the border color style of the abnormal state, it is recommended to turn off this item when there is a sub-form in the custom component | true                |
| getPopupContainer     | function(triggerNode)                                  | when `feedbackLayout` is popover， The DOM container of the tip, the default behavior is to create a div element in body                      | () => document.body |
| asterisk              | boolean                                                | Asterisk reminder                                                                                                                             | -                   |
| gridSpan              | number                                                 | Grid layout occupies width                                                                                                                    | -                   |
| bordered              | boolean                                                | Is there a border                                                                                                                             | -                   |

### FormItem.BaseItem

Pure style components, the properties are the same as FormItem, and Formily Core does not do state bridging. It is mainly used for scenarios that need to rely on the style layout capabilities of FormItem but do not want to access the Field state.
</file>

<file path="packages/antd/docs/components/FormItem.zh-CN.md">
# FormItem

> 全新的 FormItem 组件，相比于 Antd 的 FormItem，它支持的功能更多，同时它的定位是纯样式组件，不管理表单状态，所以也会更轻量，更方便定制

## Markup Schema 案例

```tsx
import React from 'react'
import { Input, Select, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    Select,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="input"
        title="输入框"
        x-decorator="FormItem"
        x-component="Input"
        required
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema 案例

```tsx
import React from 'react'
import { Input, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    input: {
      type: 'string',
      title: '输入框',
      'x-decorator': 'FormItem',
      'x-component': 'Input',
      'x-component-props': {
        style: {
          width: 240,
        },
      },
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## 纯 JSX 案例

```tsx
import React from 'react'
import { Input, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="input"
      title="输入框"
      required
      decorator={[FormItem]}
      component={[
        Input,
        {
          style: {
            width: 240,
          },
        },
      ]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## 常用属性案例

```tsx
import React from 'react'
import {
  Input,
  Radio,
  TreeSelect,
  Cascader,
  Select,
  DatePicker,
  FormItem,
  NumberPicker,
  Switch,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const Title = (props) => <h3>{props.text}</h3>

const SchemaField = createSchemaField({
  components: {
    Input,
    Select,
    Cascader,
    TreeSelect,
    DatePicker,
    NumberPicker,
    Switch,
    Radio,
    FormItem,
    Title,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Void
          x-component="Title"
          x-component-props={{ text: 'label为空时的展示' }}
        />
        <SchemaField.String
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            labelWidth: 300,
          }}
        />
        <SchemaField.String
          title=""
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            labelWidth: 300,
          }}
        />
        <SchemaField.Void
          x-component="Title"
          x-component-props={{ text: '冒号' }}
        />
        <SchemaField.String
          title="默认"
          x-decorator="FormItem"
          x-component="Input"
        />
        <SchemaField.String
          title="无冒号(colon=false)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            colon: false,
          }}
        />

        <SchemaField.Void
          x-component="Title"
          x-component-props={{ text: '固定宽度设置' }}
        />
        <SchemaField.String
          title="固定label宽度(labelWidth)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            labelWidth: 300,
          }}
        />
        <SchemaField.String
          title="固定label宽度(labelWidth)溢出溢出溢出溢出溢出溢出溢出溢出溢出溢出溢出溢出溢出溢出溢出溢出溢出溢出溢出溢出溢出溢出溢出溢出溢出溢出溢出溢出"
          description="描述描述"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            labelWidth: 300,
            tooltip: '提示提示',
            tooltipLayout: 'text',
          }}
        />
        <SchemaField.String
          title="固定label宽度(labelWidth)换行换行换行换行换行换行换行换行换行换行换行换行换行换行换行换行换行换行换行换行换行换行换行换行换行换行"
          description="描述描述"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            labelWidth: 300,
            labelWrap: true,
            tooltip: '提示提示',
          }}
        />
        <SchemaField.String
          title="固定内容宽度(wrapperWidth)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            labelWidth: 300,
            wrapperWidth: 300,
          }}
        />

        <SchemaField.Void
          x-component="Title"
          x-component-props={{ text: '对齐方式设置' }}
        />
        <SchemaField.String
          title="label左对齐(labelAlign=left)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            labelWidth: 300,
            labelAlign: 'left',
          }}
        />
        <SchemaField.String
          title="label右对齐(labelAlign=right默认)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            labelWidth: 300,
            labelAlign: 'right',
          }}
        />

        <SchemaField.String
          title="内容左对齐(wrapperAlign=left默认)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            labelWidth: 300,
            wrapperWidth: 240,
            wrapperAlign: 'left',
          }}
        />
        <SchemaField.String
          title="内容右对齐(wrapperAlign=right)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            labelWidth: 300,
            wrapperWidth: 240,
            wrapperAlign: 'right',
          }}
        />

        <SchemaField.String
          title="tooltip"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            tooltip: 'tooltip',
          }}
        />

        <SchemaField.Void
          x-component="Title"
          x-component-props={{ text: '是否撑满' }}
        />

        <SchemaField.String
          title="默认不撑满(fullness=false)"
          x-decorator="FormItem"
          x-component="Select"
        />
        <SchemaField.String
          title="撑满(fullness=true)"
          x-decorator="FormItem"
          x-component="Select"
          x-decorator-props={{
            fullness: true,
          }}
        />

        <SchemaField.Void
          x-component="Title"
          x-component-props={{ text: '辅助信息' }}
        />

        <SchemaField.String
          title="必填星号"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            asterisk: true,
            labelCol: 6,
            wrapperCol: 10,
          }}
        />

        <SchemaField.String
          title="前缀"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            addonBefore: 'addonBefore',
            labelCol: 6,
            wrapperCol: 10,
          }}
        />
        <SchemaField.String
          title="后缀"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            addonAfter: 'addonAfter',
            labelCol: 6,
            wrapperCol: 10,
          }}
        />

        <SchemaField.String
          title="帮助信息feedbackText"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            feedbackText: 'feedbackText',
            labelCol: 6,
            wrapperCol: 10,
          }}
        />

        <SchemaField.String
          title="额外信息extra"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            feedbackText: 'feedbackText',
            extra: 'extra',
            labelCol: 6,
            wrapperCol: 10,
          }}
        />
      </SchemaField>
    </FormProvider>
  )
}
```

## 必填样式

```tsx
import React, { useState } from 'react'
import { Input, FormItem, FormLayout } from '@formily/antd'
import { Radio, ConfigProvider } from 'antd'
import zhCN from 'antd/es/locale/zh_CN'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const form = createForm()

export default () => {
  const [requiredMark, setRequiredMark] = useState(true)
  return (
    <ConfigProvider locale={zhCN}>
      <p>
        Required Mark：
        <Radio.Group
          value={requiredMark}
          onChange={(e) => setRequiredMark(e.target.value)}
        >
          <Radio.Button value="optional">optional</Radio.Button>
          <Radio.Button value={true}>true</Radio.Button>
          <Radio.Button value={false}>false</Radio.Button>
        </Radio.Group>
      </p>
      <FormProvider form={form}>
        <FormLayout requiredMark={requiredMark}>
          <SchemaField>
            <SchemaField.String
              title="我是必填项"
              required
              x-decorator="FormItem"
              x-component="Input"
            />
            <SchemaField.String
              title="我是选填项"
              x-decorator="FormItem"
              x-component="Input"
            />
            <SchemaField.String
              default="字段不可编辑时，始终隐藏必填/选填标识"
              x-editable={false}
              x-decorator="FormItem"
              x-component="Input"
            />
            <SchemaField.String
              title="我是必填项"
              required
              default="不可编辑"
              x-editable={false}
              x-decorator="FormItem"
              x-component="Input"
            />
            <SchemaField.String
              title="我是选填项"
              default="不可编辑"
              x-editable={false}
              x-decorator="FormItem"
              x-component="Input"
            />
          </SchemaField>
        </FormLayout>
      </FormProvider>
    </ConfigProvider>
  )
}
```

## 无边框案例

设置去除组件边框

```tsx
import React from 'react'
import {
  Input,
  Radio,
  TreeSelect,
  Cascader,
  Select,
  DatePicker,
  FormItem,
  NumberPicker,
  Switch,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const Title = (props) => <h3>{props.text}</h3>

const SchemaField = createSchemaField({
  components: {
    Input,
    Select,
    Cascader,
    TreeSelect,
    DatePicker,
    NumberPicker,
    Switch,
    Radio,
    FormItem,
    Title,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.String
          name="input"
          title="Input"
          x-decorator="FormItem"
          x-component="Input"
          required
          x-decorator-props={{
            bordered: false,
          }}
        />
        <SchemaField.String
          name="Select"
          title="Select"
          x-decorator="FormItem"
          x-component="Select"
          required
          x-decorator-props={{
            bordered: false,
          }}
        />
        <SchemaField.String
          name="Select"
          title="Select"
          x-decorator="FormItem"
          x-component="Select"
          required
          x-decorator-props={{
            bordered: false,
          }}
        />
        <SchemaField.String
          name="Cascader"
          title="Cascader"
          x-decorator="FormItem"
          x-component="Cascader"
          required
          x-decorator-props={{
            bordered: false,
          }}
        />
        <SchemaField.String
          name="DatePicker"
          title="DatePicker"
          x-decorator="FormItem"
          x-component="DatePicker"
          required
          x-decorator-props={{
            bordered: false,
          }}
        />
        <SchemaField.String
          name="NumberPicker"
          title="NumberPicker"
          x-decorator="FormItem"
          x-component="NumberPicker"
          required
          x-decorator-props={{
            bordered: false,
          }}
        />
        <SchemaField.String
          name="TreeSelect"
          title="TreeSelect"
          x-decorator="FormItem"
          x-component="TreeSelect"
          required
          x-decorator-props={{
            bordered: false,
          }}
        />
        <SchemaField.Boolean
          name="Switch"
          title="Switch"
          x-decorator="FormItem"
          x-component="Switch"
          required
          x-decorator-props={{
            bordered: false,
          }}
        />
      </SchemaField>
    </FormProvider>
  )
}
```

## 内嵌模式案例

设置表单组件为内嵌模式

```tsx
import React from 'react'
import {
  Input,
  Radio,
  TreeSelect,
  Cascader,
  Select,
  DatePicker,
  FormItem,
  NumberPicker,
  Switch,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const Title = (props) => <h3>{props.text}</h3>

const SchemaField = createSchemaField({
  components: {
    Input,
    Select,
    Cascader,
    TreeSelect,
    DatePicker,
    NumberPicker,
    Switch,
    Radio,
    FormItem,
    Title,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.String
          name="input"
          title="Input"
          x-decorator="FormItem"
          x-component="Input"
          required
          x-decorator-props={{
            inset: true,
          }}
        />
        <SchemaField.String
          name="Select"
          title="Select"
          x-decorator="FormItem"
          x-component="Select"
          required
          x-decorator-props={{
            inset: true,
          }}
        />
        <SchemaField.String
          name="Select"
          title="Select"
          x-decorator="FormItem"
          x-component="Select"
          required
          x-decorator-props={{
            inset: true,
          }}
        />
        <SchemaField.String
          name="Cascader"
          title="Cascader"
          x-decorator="FormItem"
          x-component="Cascader"
          required
          x-decorator-props={{
            inset: true,
          }}
        />
        <SchemaField.String
          name="DatePicker"
          title="DatePicker"
          x-decorator="FormItem"
          x-component="DatePicker"
          required
          x-decorator-props={{
            inset: true,
          }}
        />
        <SchemaField.String
          name="NumberPicker"
          title="NumberPicker"
          x-decorator="FormItem"
          x-component="NumberPicker"
          required
          x-decorator-props={{
            inset: true,
          }}
        />
        <SchemaField.String
          name="TreeSelect"
          title="TreeSelect"
          x-decorator="FormItem"
          x-component="TreeSelect"
          required
          x-decorator-props={{
            inset: true,
          }}
        />
        <SchemaField.Boolean
          name="Switch"
          title="Switch"
          x-decorator="FormItem"
          x-component="Switch"
          required
          x-decorator-props={{
            inset: false,
          }}
        />
      </SchemaField>
    </FormProvider>
  )
}
```

## 反馈信息定制案例

可通过 `feedbackIcon` 传入指定反馈的按钮

```tsx
import React from 'react'
import {
  Input,
  Radio,
  TreeSelect,
  Cascader,
  Select,
  DatePicker,
  TimePicker,
  FormItem,
  FormLayout,
  NumberPicker,
  Switch,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { CheckCircleFilled, LoadingOutlined } from '@ant-design/icons'
const Title = (props) => <h3>{props.text}</h3>

const SchemaField = createSchemaField({
  components: {
    Input,
    Select,
    Cascader,
    TreeSelect,
    DatePicker,
    TimePicker,
    NumberPicker,
    Switch,
    Radio,
    FormItem,
    Title,
    FormLayout,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.String
          title="错误状态(feedbackStatus=error)"
          x-decorator="FormItem"
          x-component="Input"
          description="description"
          x-decorator-props={{
            feedbackStatus: 'error',
          }}
        />

        <SchemaField.String
          title="警告状态(feedbackStatus=warning)"
          x-decorator="FormItem"
          x-component="Input"
          description="description"
          x-decorator-props={{
            feedbackStatus: 'warning',
          }}
        />

        <SchemaField.String
          title="成功状态(feedbackStatus=success)"
          x-decorator="FormItem"
          x-component="Input"
          description="description"
          x-decorator-props={{
            feedbackStatus: 'success',
            feedbackIcon: <CheckCircleFilled style={{ color: '#52c41a' }} />,
          }}
        />

        <SchemaField.String
          title="加载状态(feedbackStatus=pending)"
          x-decorator="FormItem"
          x-component="Input"
          description="description"
          x-decorator-props={{
            feedbackStatus: 'pending',
            feedbackIcon: <LoadingOutlined style={{ color: '#1890ff' }} />,
          }}
        />

        <SchemaField.String
          title="禁用错误状态边框样式(feedbackStatus=error)"
          x-decorator="FormItem"
          x-component="Input"
          description="description"
          x-decorator-props={{
            enableOutlineFeedback: false,
            feedbackStatus: 'error',
          }}
        />

        <SchemaField.Void
          x-component="Title"
          x-component-props={{ text: '反馈信息的布局' }}
        />

        <SchemaField.String
          title="紧凑模式required"
          x-decorator="FormItem"
          x-component="Input"
          required
          x-decorator-props={{
            feedbackLayout: 'terse',
          }}
        />

        <SchemaField.String
          title="紧凑模式有feedback(feedbackLayout=terse)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            feedbackStatus: 'error',
            feedbackText: 'error message',
            feedbackLayout: 'terse',
          }}
        />

        <SchemaField.String
          title="紧凑模式无feedback(feedbackLayout=terse)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            feedbackLayout: 'terse',
          }}
        />

        <SchemaField.String
          title="松散模式(feedbackLayout=loose)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            feedbackStatus: 'error',
            feedbackText: 'error message',
            feedbackLayout: 'loose',
          }}
        />

        <SchemaField.String
          title="弹出模式(feedbackLayout=popover)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            feedbackStatus: 'warning',
            feedbackText: 'warning message',
            feedbackLayout: 'popover',
          }}
        />

        <SchemaField.String
          title="弹出模式(feedbackLayout=popover)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            feedbackStatus: 'error',
            feedbackText: 'error message',
            feedbackLayout: 'popover',
          }}
        />
        <SchemaField.String
          title="弹出模式(feedbackLayout=popover)"
          x-decorator="FormItem"
          x-component="Input"
          x-decorator-props={{
            feedbackStatus: 'success',
            feedbackText: 'success message',
            feedbackLayout: 'popover',
          }}
        />

        <SchemaField.Void
          x-component="Title"
          x-component-props={{ text: '组件的适配情况' }}
        />
        <SchemaField.Void
          x-component="FormLayout"
          x-component-props={{ layout: 'vertical' }}
        >
          <SchemaField.String
            title="Select"
            x-decorator="FormItem"
            x-component="Select"
            x-decorator-props={{
              feedbackStatus: 'success',
              feedbackIcon: <CheckCircleFilled style={{ color: '#52c41a' }} />,
            }}
          />

          <SchemaField.String
            title="DatePicker"
            x-decorator="FormItem"
            x-component="DatePicker"
            x-decorator-props={{
              feedbackStatus: 'success',
              feedbackIcon: <CheckCircleFilled style={{ color: '#52c41a' }} />,
            }}
          />
          <SchemaField.String
            title="DatePicker.RangePicker"
            x-decorator="FormItem"
            x-component="DatePicker.RangePicker"
            x-decorator-props={{
              feedbackStatus: 'success',
              feedbackIcon: <CheckCircleFilled style={{ color: '#52c41a' }} />,
            }}
          />
          <SchemaField.String
            title="DatePicker.YearPicker"
            x-decorator="FormItem"
            x-component="DatePicker.YearPicker"
            x-decorator-props={{
              feedbackStatus: 'success',
              feedbackIcon: <CheckCircleFilled style={{ color: '#52c41a' }} />,
            }}
          />
          <SchemaField.String
            title="DatePicker.MonthPicker"
            x-decorator="FormItem"
            x-component="DatePicker.MonthPicker"
            x-decorator-props={{
              feedbackStatus: 'success',
              feedbackIcon: <CheckCircleFilled style={{ color: '#52c41a' }} />,
            }}
          />
          <SchemaField.String
            title="DatePicker.TimePicker"
            x-decorator="FormItem"
            x-component="TimePicker"
            x-decorator-props={{
              feedbackStatus: 'success',
              feedbackIcon: <CheckCircleFilled style={{ color: '#52c41a' }} />,
            }}
          />
          <SchemaField.String
            title="NumberPicker"
            x-decorator="FormItem"
            x-component="NumberPicker"
            x-decorator-props={{
              feedbackStatus: 'success',
              feedbackIcon: <CheckCircleFilled style={{ color: '#52c41a' }} />,
            }}
          />

          <SchemaField.String
            title="TreeSelect"
            x-decorator="FormItem"
            x-component="TreeSelect"
            x-decorator-props={{
              feedbackStatus: 'success',
              feedbackIcon: <CheckCircleFilled style={{ color: '#52c41a' }} />,
            }}
          />

          <SchemaField.String
            title="Cascader"
            x-decorator="FormItem"
            x-component="Cascader"
            x-decorator-props={{
              feedbackStatus: 'success',
              feedbackIcon: <CheckCircleFilled style={{ color: '#52c41a' }} />,
            }}
          />
        </SchemaField.Void>
      </SchemaField>
    </FormProvider>
  )
}
```

## 尺寸控制案例

```tsx
import React from 'react'
import {
  Input,
  Radio,
  TreeSelect,
  Cascader,
  Select,
  DatePicker,
  FormItem,
  NumberPicker,
  Switch,
} from '@formily/antd'
import { createForm, onFieldChange } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const Div = (props) => <div {...props} />

const SchemaField = createSchemaField({
  components: {
    Input,
    Select,
    Cascader,
    TreeSelect,
    DatePicker,
    NumberPicker,
    Switch,
    Radio,
    FormItem,
    Div,
  },
})

const form = createForm({
  values: {
    size: 'default',
  },
  effects: () => {
    onFieldChange('size', ['value'], (field, form) => {
      form.setFieldState('sizeWrap.*', (state) => {
        if (state.decorator[1]) {
          state.decorator[1].size = field.value
        }
      })
    })
  },
})

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.String
          name="size"
          title="Radio.Group"
          x-decorator="FormItem"
          x-component="Radio.Group"
          enum={[
            { value: 'small', label: 'Small' },
            { value: 'default', label: 'Default' },
            { value: 'large', label: 'Large' },
          ]}
        />
        <SchemaField.Void name="sizeWrap" x-component="Div">
          <SchemaField.String
            name="input"
            title="Input"
            x-decorator="FormItem"
            x-component="Input"
            required
          />
          <SchemaField.String
            name="select1"
            title="Multiple Select"
            x-decorator="FormItem"
            x-component="Select"
            enum={[
              {
                label: '选项1',
                value: 1,
              },
              {
                label: '选项2',
                value: 2,
              },
            ]}
            x-component-props={{
              mode: 'multiple',
              placeholder: '请选择',
            }}
            required
          />
          <SchemaField.String
            name="select2"
            title="Select"
            x-decorator="FormItem"
            x-component="Select"
            enum={[
              {
                label: '选项1',
                value: 1,
              },
              {
                label: '选项2',
                value: 2,
              },
            ]}
            x-component-props={{
              placeholder: '请选择',
            }}
            required
          />
          <SchemaField.String
            name="Cascader"
            title="Cascader"
            x-decorator="FormItem"
            x-component="Cascader"
            required
          />
          <SchemaField.String
            name="DatePicker"
            title="DatePicker"
            x-decorator="FormItem"
            x-component="DatePicker"
            required
          />
          <SchemaField.String
            name="NumberPicker"
            title="NumberPicker"
            x-decorator="FormItem"
            x-component="NumberPicker"
            required
          />
          <SchemaField.String
            name="TreeSelect"
            title="TreeSelect"
            x-decorator="FormItem"
            x-component="TreeSelect"
            required
          />
          <SchemaField.Boolean
            name="Switch"
            title="Switch"
            x-decorator="FormItem"
            x-component="Switch"
            required
          />
        </SchemaField.Void>
      </SchemaField>
    </FormProvider>
  )
}
```

## API

### FormItem

| 属性名                | 类型                                                   | 描述                                                                | 默认值              |
| --------------------- | ------------------------------------------------------ | ------------------------------------------------------------------- | ------------------- |
| label                 | ReactNode                                              | 标签                                                                | -                   |
| style                 | CSSProperties                                          | 样式                                                                | -                   |
| labelStyle            | CSSProperties                                          | 标签样式                                                            | -                   |
| wrapperStyle          | CSSProperties                                          | 组件容器样式                                                        | -                   |
| className             | string                                                 | 组件样式类名                                                        | -                   |
| colon                 | boolean                                                | 冒号                                                                | true                |
| tooltip               | ReactNode                                              | 问号提示                                                            | -                   |
| tooltipLayout         | `"icon" \| "text"`                                     | 问号提示布局                                                        | `"icon"`            |
| tooltipIcon           | ReactNode                                              | 问号提示图标                                                        | `?`                 |
| labelAlign            | `"left"` \| `"right"`                                  | 标签文本对齐方式                                                    | `"right"`           |
| labelWrap             | boolean                                                | 标签换⾏，否则出现省略号，hover 有 tooltip                          | false               |
| labelWidth            | `number \| string`                                     | 标签固定宽度                                                        | -                   |
| wrapperWidth          | `number \| string`                                     | 内容固定宽度                                                        | -                   |
| labelCol              | number                                                 | 标签⽹格所占列数，和内容列数加起来总和为 24                         | -                   |
| wrapperCol            | number                                                 | 内容⽹格所占列数，和标签列数加起来总和为 24                         | -                   |
| wrapperAlign          | `"left"` \| `"right"`                                  | 内容文本对齐方式⻬                                                  | `"left"`            |
| wrapperWrap           | boolean                                                | 内容换⾏，否则出现省略号，hover 有 tooltip                          | false               |
| fullness              | boolean                                                | 内容撑满                                                            | false               |
| addonBefore           | ReactNode                                              | 前缀内容                                                            | -                   |
| addonAfter            | ReactNode                                              | 后缀内容                                                            | -                   |
| size                  | `"small"` \| `"default"` \| `"large"`                  | 尺⼨                                                                | -                   |
| inset                 | boolean                                                | 是否是内嵌布局                                                      | false               |
| extra                 | ReactNode                                              | 扩展描述⽂案                                                        | -                   |
| feedbackText          | ReactNode                                              | 反馈⽂案                                                            | -                   |
| feedbackLayout        | `"loose"` \| `"terse"` \| `"popover" \| "none"`        | 反馈布局                                                            | -                   |
| feedbackStatus        | `"error"` \| `"warning"` \| `"success"` \| `"pending"` | 反馈布局                                                            | -                   |
| feedbackIcon          | ReactNode                                              | 反馈图标                                                            | -                   |
| enableOutlineFeedback | boolean                                                | 开启异常状态的边框颜色样式，当自定义组件内存在子表单时建议关闭此项  | true                |
| getPopupContainer     | function(triggerNode)                                  | 当 feedbackLayout 为 popover 时，浮层渲染父节点，默认渲染到 body 上 | () => document.body |
| asterisk              | boolean                                                | 星号提醒                                                            | -                   |
| gridSpan              | number                                                 | ⽹格布局占宽                                                        | -                   |
| bordered              | boolean                                                | 是否有边框                                                          | -                   |

### FormItem.BaseItem

纯样式组件，属性与 FormItem 一样，与 Formily Core 不做状态桥接，主要用于一些需要依赖 FormItem 的样式布局能力，但不希望接入 Field 状态的场景
</file>

<file path="packages/antd/docs/components/FormLayout.md">
# FormLayout

> Block-level layout batch control component, with the help of this component, we can easily control the layout mode of all FormItem components enclosed by FormLayout

## Markup Schema example

```tsx
import React from 'react'
import { Input, Select, FormItem, FormLayout } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    Select,
    FormItem,
    FormLayout,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Void
        x-component="FormLayout"
        x-component-props={{
          labelCol: 6,
          wrapperCol: 10,
        }}
      >
        <SchemaField.String
          name="input"
          title="input box"
          x-decorator="FormItem"
          x-decorator-props={{
            tooltip: <div>123</div>,
          }}
          x-component="Input"
          required
        />
        <SchemaField.String
          name="select"
          title="select box"
          x-decorator="FormItem"
          x-component="Select"
          required
        />
      </SchemaField.Void>
    </SchemaField>
  </FormProvider>
)
```

## JSON Schema case

```tsx
import React from 'react'
import { Input, Select, FormItem, FormLayout } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    Select,
    FormItem,
    FormLayout,
  },
})

const schema = {
  type: 'object',
  properties: {
    layout: {
      type: 'void',
      'x-component': 'FormLayout',
      'x-component-props': {
        labelCol: 6,
        wrapperCol: 10,
        layout: 'vertical',
      },
      properties: {
        input: {
          type: 'string',
          title: 'input box',
          required: true,
          'x-decorator': 'FormItem',
          'x-decorator-props': {
            tooltip: <div>123</div>,
          },
          'x-component': 'Input',
        },
        select: {
          type: 'string',
          title: 'Select box',
          required: true,
          'x-decorator': 'FormItem',
          'x-component': 'Select',
        },
      },
    },
  },
}

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
  </FormProvider>
)
```

## Pure JSX case

```tsx
import React from 'react'
import {
  Input,
  Select,
  FormItem,
  FormButtonGroup,
  Submit,
  FormLayout,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <FormLayout labelCol={6} wrapperCol={10}>
      <Field
        name="input"
        required
        title="input box"
        decorator={[FormItem]}
        component={[Input]}
      />
      <Field
        name="select"
        required
        title="select box"
        decorator={[FormItem]}
        component={[Select]}
      />
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup.FormItem>
    </FormLayout>
  </FormProvider>
)
```

## API

| Property name  | Type                                                                                   | Description                                                 | Default value |
| -------------- | -------------------------------------------------------------------------------------- | ----------------------------------------------------------- | ------------- |
| style          | CSSProperties                                                                          | Style                                                       | -             |
| className      | string                                                                                 | class name                                                  | -             |
| colon          | boolean                                                                                | Is there a colon                                            | true          |
| requiredMark   | boolean \| `"optional"`                                                                | Required mark style. Can use required mark or optional mark | true          |
| labelAlign     | `'right' \| 'left' \| ('right' \| 'left')[]`                                           | Label content alignment                                     | -             |
| wrapperAlign   | `'right' \| 'left' \| ('right' \| 'left')[]`                                           | Component container content alignment                       | -             |
| labelWrap      | boolean                                                                                | Wrap label content                                          | false         |
| labelWidth     | number                                                                                 | Label width (px)                                            | -             |
| wrapperWidth   | number                                                                                 | Component container width (px)                              | -             |
| wrapperWrap    | boolean                                                                                | Component container wrap                                    | false         |
| labelCol       | `number \| number[]`                                                                   | Label width (24 column)                                     | -             |
| wrapperCol     | `number \| number[]`                                                                   | Component container width (24 column)                       | -             |
| fullness       | boolean                                                                                | Component container width 100%                              | false         |
| size           | `'small' \|'default' \|'large'`                                                        | component size                                              | default       |
| layout         | `'vertical' \| 'horizontal' \| 'inline' \| ('vertical' \| 'horizontal' \| 'inline')[]` | layout mode                                                 | horizontal    |
| direction      | `'rtl' \|'ltr'`                                                                        | direction (not supported yet)                               | ltr           |
| inset          | boolean                                                                                | Inline layout                                               | false         |
| shallow        | boolean                                                                                | shallow context transfer                                    | true          |
| feedbackLayout | `'loose' \|'terse' \|'popover' \|'none'`                                               | feedback layout                                             | true          |
| tooltipLayout  | `"icon" \| "text"`                                                                     | Ask the prompt layout                                       | `"icon"`      |
| tooltipIcon    | ReactNode                                                                              | Ask the prompt icon                                         | -             |
| bordered       | boolean                                                                                | Is there a border                                           | true          |
| breakpoints    | number[]                                                                               | Container size breakpoints                                  | -             |
| gridColumnGap  | number                                                                                 | Grid Column Gap                                             | 8             |
| gridRowGap     | number                                                                                 | Grid Row Gap                                                | 4             |
| spaceGap       | number                                                                                 | Space Gap                                                   | 8             |
</file>

<file path="packages/antd/docs/components/FormLayout.zh-CN.md">
# FormLayout

> 区块级布局批量控制组件，借助该组件，我们可以轻松的控制被 FormLayout 圈住的所有 FormItem 组件的布局模式

## Markup Schema 案例

```tsx
import React from 'react'
import { Input, Select, FormItem, FormLayout } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    Select,
    FormItem,
    FormLayout,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Void
        x-component="FormLayout"
        x-component-props={{
          labelCol: 6,
          wrapperCol: 10,
        }}
      >
        <SchemaField.String
          name="input"
          title="输入框"
          x-decorator="FormItem"
          x-decorator-props={{
            tooltip: <div>123</div>,
          }}
          x-component="Input"
          required
        />
        <SchemaField.String
          name="select"
          title="选择框"
          x-decorator="FormItem"
          x-component="Select"
          required
        />
      </SchemaField.Void>
    </SchemaField>
  </FormProvider>
)
```

## JSON Schema 案例

```tsx
import React from 'react'
import { Input, Select, FormItem, FormLayout } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    Select,
    FormItem,
    FormLayout,
  },
})

const schema = {
  type: 'object',
  properties: {
    layout: {
      type: 'void',
      'x-component': 'FormLayout',
      'x-component-props': {
        labelCol: 6,
        wrapperCol: 10,
        layout: 'vertical',
      },
      properties: {
        input: {
          type: 'string',
          title: '输入框',
          required: true,
          'x-decorator': 'FormItem',
          'x-decorator-props': {
            tooltip: <div>123</div>,
          },
          'x-component': 'Input',
        },
        select: {
          type: 'string',
          title: '选择框',
          required: true,
          'x-decorator': 'FormItem',
          'x-component': 'Select',
        },
      },
    },
  },
}

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
  </FormProvider>
)
```

## 纯 JSX 案例

```tsx
import React from 'react'
import {
  Input,
  Select,
  FormItem,
  FormButtonGroup,
  Submit,
  FormLayout,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <FormLayout
      breakpoints={[680]}
      layout={['vertical', 'horizontal']}
      labelAlign={['left', 'right']}
      labelCol={[24, 6]}
      wrapperCol={[24, 10]}
    >
      <Field
        name="input"
        required
        title="输入框"
        decorator={[FormItem]}
        component={[Input]}
      />
      <Field
        name="select"
        required
        title="选择框"
        decorator={[FormItem]}
        component={[Select]}
      />
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup.FormItem>
    </FormLayout>
  </FormProvider>
)
```

## API

| 属性名         | 类型                                                                                   | 描述                                     | 默认值     |
| -------------- | -------------------------------------------------------------------------------------- | ---------------------------------------- | ---------- |
| style          | CSSProperties                                                                          | 样式                                     | -          |
| className      | string                                                                                 | 类名                                     | -          |
| colon          | boolean                                                                                | 是否有冒号                               | true       |
| requiredMark   | boolean \| `"optional"`                                                                | 必选样式，可以切换为必选或者可选展示样式 | true       |
| labelAlign     | `'right' \| 'left' \| ('right' \| 'left')[]`                                           | 标签内容对齐                             | -          |
| wrapperAlign   | `'right' \| 'left' \| ('right' \| 'left')[]`                                           | 组件容器内容对齐                         | -          |
| labelWrap      | boolean                                                                                | 标签内容换行                             | false      |
| labelWidth     | number                                                                                 | 标签宽度(px)                             | -          |
| wrapperWidth   | number                                                                                 | 组件容器宽度(px)                         | -          |
| wrapperWrap    | boolean                                                                                | 组件容器换行                             | false      |
| labelCol       | `number \| number[]`                                                                   | 标签宽度(24 column)                      | -          |
| wrapperCol     | `number \| number[]`                                                                   | 组件容器宽度(24 column)                  | -          |
| fullness       | boolean                                                                                | 组件容器宽度 100%                        | false      |
| size           | `'small' \| 'default' \| 'large'`                                                      | 组件尺寸                                 | default    |
| layout         | `'vertical' \| 'horizontal' \| 'inline' \| ('vertical' \| 'horizontal' \| 'inline')[]` | 布局模式                                 | horizontal |
| direction      | `'rtl' \| 'ltr'`                                                                       | 方向(暂不支持)                           | ltr        |
| inset          | boolean                                                                                | 内联布局                                 | false      |
| shallow        | boolean                                                                                | 上下文浅层传递                           | true       |
| feedbackLayout | `'loose' \| 'terse' \| 'popover' \| 'none'`                                            | 反馈布局                                 | true       |
| tooltipLayout  | `"icon" \| "text"`                                                                     | 问号提示布局                             | `"icon"`   |
| tooltipIcon    | ReactNode                                                                              | 问号提示图标                             | -          |
| bordered       | boolean                                                                                | 是否有边框                               | true       |
| breakpoints    | number[]                                                                               | 容器尺寸断点                             | -          |
| gridColumnGap  | number                                                                                 | 网格布局列间距                           | 8          |
| gridRowGap     | number                                                                                 | 网格布局行间距                           | 4          |
| spaceGap       | number                                                                                 | 弹性间距                                 | 8          |
</file>

<file path="packages/antd/docs/components/FormStep.md">
# FormStep

> Step-by-step form components
>
> Note: This component can only be used in Schema scenarios

## Markup Schema example

```tsx
import React from 'react'
import { FormStep, FormItem, Input, FormButtonGroup } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, FormConsumer, createSchemaField } from '@formily/react'
import { Button } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    FormStep,
    Input,
  },
})

const form = createForm()
const formStep = FormStep.createFormStep()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Void
          x-component="FormStep"
          x-component-props={{ formStep }}
        >
          <SchemaField.Void
            x-component="FormStep.StepPane"
            x-component-props={{ title: 'First Step' }}
          >
            <SchemaField.String
              name="aaa"
              x-decorator="FormItem"
              required
              x-component="Input"
            />
          </SchemaField.Void>
          <SchemaField.Void
            x-component="FormStep.StepPane"
            x-component-props={{ title: 'Second Step' }}
          >
            <SchemaField.String
              name="bbb"
              x-decorator="FormItem"
              required
              x-component="Input"
            />
          </SchemaField.Void>
          <SchemaField.Void
            type="void"
            x-component="FormStep.StepPane"
            x-component-props={{ title: 'Step 3' }}
          >
            <SchemaField.String
              name="ccc"
              x-decorator="FormItem"
              required
              x-component="Input"
            />
          </SchemaField.Void>
        </SchemaField.Void>
      </SchemaField>
      <FormConsumer>
        {() => (
          <FormButtonGroup>
            <Button
              disabled={!formStep.allowBack}
              onClick={() => {
                formStep.back()
              }}
            >
              Previous
            </Button>
            <Button
              disabled={!formStep.allowNext}
              onClick={() => {
                formStep.next()
              }}
            >
              Next step
            </Button>
            <Button
              disabled={formStep.allowNext}
              onClick={() => {
                formStep.submit(console.log)
              }}
            >
              submit
            </Button>
          </FormButtonGroup>
        )}
      </FormConsumer>
    </FormProvider>
  )
}
```

## JSON Schema case

```tsx
import React from 'react'
import { FormStep, FormItem, Input, FormButtonGroup } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, FormConsumer, createSchemaField } from '@formily/react'
import { Button } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    FormStep,
    Input,
  },
})

const form = createForm()
const formStep = FormStep.createFormStep()

const schema = {
  type: 'object',
  properties: {
    step: {
      type: 'void',
      'x-component': 'FormStep',
      'x-component-props': {
        formStep: '{{formStep}}',
      },
      properties: {
        step1: {
          type: 'void',
          'x-component': 'FormStep.StepPane',
          'x-component-props': {
            title: 'First Step',
          },
          properties: {
            aaa: {
              type: 'string',
              title: 'AAA',
              required: true,
              'x-decorator': 'FormItem',
              'x-component': 'Input',
            },
          },
        },
        step2: {
          type: 'void',
          'x-component': 'FormStep.StepPane',
          'x-component-props': {
            title: 'Second Step',
          },
          properties: {
            bbb: {
              type: 'string',
              title: 'AAA',
              required: true,
              'x-decorator': 'FormItem',
              'x-component': 'Input',
            },
          },
        },
        step3: {
          type: 'void',
          'x-component': 'FormStep.StepPane',
          'x-component-props': {
            title: 'The third step',
          },
          properties: {
            ccc: {
              type: 'string',
              title: 'AAA',
              required: true,
              'x-decorator': 'FormItem',
              'x-component': 'Input',
            },
          },
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} scope={{ formStep }} />
      <FormConsumer>
        {() => (
          <FormButtonGroup>
            <Button
              disabled={!formStep.allowBack}
              onClick={() => {
                formStep.back()
              }}
            >
              Previous
            </Button>
            <Button
              disabled={!formStep.allowNext}
              onClick={() => {
                formStep.next()
              }}
            >
              Next step
            </Button>
            <Button
              disabled={formStep.allowNext}
              onClick={() => {
                formStep.submit(console.log)
              }}
            >
              submit
            </Button>
          </FormButtonGroup>
        )}
      </FormConsumer>
    </FormProvider>
  )
}
```

## API

### FormStep

| Property name | Type      | Description                                             | Default value |
| ------------- | --------- | ------------------------------------------------------- | ------------- |
| formStep      | IFormStep | Pass in the model created by createFormStep/useFormStep |               |

Other references https://ant.design/components/steps-cn/

### FormStep.StepPane

Refer to https://ant.design/components/steps-cn/ Steps.Step properties

### FormStep.createFormStep

```ts pure
import { Form } from '@formily/core'

interface createFormStep {
  (current?: number): IFormStep
}

interface IFormTab {
  //Current index
  current: number
  //Whether to allow backwards
  allowNext: boolean
  //Whether to allow forward
  allowBack: boolean
  //Set the current index
  setCurrent(key: number): void
  //submit Form
  submit: Form['submit']
  //backward
  next(): void
  //forward
  back(): void
}
```
</file>

<file path="packages/antd/docs/components/FormStep.zh-CN.md">
# FormStep

> 分步表单组件
>
> 注意：该组件只能用在 Schema 场景

## Markup Schema 案例

```tsx
import React from 'react'
import { FormStep, FormItem, Input, FormButtonGroup } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, FormConsumer, createSchemaField } from '@formily/react'
import { Button } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    FormStep,
    Input,
  },
})

const form = createForm()
const formStep = FormStep.createFormStep()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Void
          x-component="FormStep"
          x-component-props={{ formStep }}
        >
          <SchemaField.Void
            x-component="FormStep.StepPane"
            x-component-props={{ title: '第一步' }}
          >
            <SchemaField.String
              name="aaa"
              x-decorator="FormItem"
              required
              x-component="Input"
            />
          </SchemaField.Void>
          <SchemaField.Void
            x-component="FormStep.StepPane"
            x-component-props={{ title: '第二步' }}
          >
            <SchemaField.String
              name="bbb"
              x-decorator="FormItem"
              required
              x-component="Input"
            />
          </SchemaField.Void>
          <SchemaField.Void
            type="void"
            x-component="FormStep.StepPane"
            x-component-props={{ title: '第三步' }}
          >
            <SchemaField.String
              name="ccc"
              x-decorator="FormItem"
              required
              x-component="Input"
            />
          </SchemaField.Void>
        </SchemaField.Void>
      </SchemaField>
      <FormConsumer>
        {() => (
          <FormButtonGroup>
            <Button
              disabled={!formStep.allowBack}
              onClick={() => {
                formStep.back()
              }}
            >
              上一步
            </Button>
            <Button
              disabled={!formStep.allowNext}
              onClick={() => {
                formStep.next()
              }}
            >
              下一步
            </Button>
            <Button
              disabled={formStep.allowNext}
              onClick={() => {
                formStep.submit(console.log)
              }}
            >
              提交
            </Button>
          </FormButtonGroup>
        )}
      </FormConsumer>
    </FormProvider>
  )
}
```

## JSON Schema 案例

```tsx
import React from 'react'
import { FormStep, FormItem, Input, FormButtonGroup } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, FormConsumer, createSchemaField } from '@formily/react'
import { Button } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    FormStep,
    Input,
  },
})

const form = createForm()
const formStep = FormStep.createFormStep()

const schema = {
  type: 'object',
  properties: {
    step: {
      type: 'void',
      'x-component': 'FormStep',
      'x-component-props': {
        formStep: '{{formStep}}',
      },
      properties: {
        step1: {
          type: 'void',
          'x-component': 'FormStep.StepPane',
          'x-component-props': {
            title: '第一步',
          },
          properties: {
            aaa: {
              type: 'string',
              title: 'AAA',
              required: true,
              'x-decorator': 'FormItem',
              'x-component': 'Input',
            },
          },
        },
        step2: {
          type: 'void',
          'x-component': 'FormStep.StepPane',
          'x-component-props': {
            title: '第二步',
          },
          properties: {
            bbb: {
              type: 'string',
              title: 'AAA',
              required: true,
              'x-decorator': 'FormItem',
              'x-component': 'Input',
            },
          },
        },
        step3: {
          type: 'void',
          'x-component': 'FormStep.StepPane',
          'x-component-props': {
            title: '第三步',
          },
          properties: {
            ccc: {
              type: 'string',
              title: 'AAA',
              required: true,
              'x-decorator': 'FormItem',
              'x-component': 'Input',
            },
          },
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} scope={{ formStep }} />
      <FormConsumer>
        {() => (
          <FormButtonGroup>
            <Button
              disabled={!formStep.allowBack}
              onClick={() => {
                formStep.back()
              }}
            >
              上一步
            </Button>
            <Button
              disabled={!formStep.allowNext}
              onClick={() => {
                formStep.next()
              }}
            >
              下一步
            </Button>
            <Button
              disabled={formStep.allowNext}
              onClick={() => {
                formStep.submit(console.log)
              }}
            >
              提交
            </Button>
          </FormButtonGroup>
        )}
      </FormConsumer>
    </FormProvider>
  )
}
```

## API

### FormStep

| 属性名   | 类型      | 描述                                               | 默认值 |
| -------- | --------- | -------------------------------------------------- | ------ |
| formStep | IFormStep | 传入通过 createFormStep/useFormStep 创建出来的模型 |        |

其余参考 https://ant.design/components/steps-cn/

### FormStep.StepPane

参考 https://ant.design/components/steps-cn/ Steps.Step 属性

### FormStep.createFormStep

```ts pure
import { Form } from '@formily/core'

interface createFormStep {
  (current?: number): IFormStep
}

interface IFormTab {
  //当前索引
  current: number
  //是否允许向后
  allowNext: boolean
  //是否允许向前
  allowBack: boolean
  //设置当前索引
  setCurrent(key: number): void
  //提交表单
  submit: Form['submit']
  //向后
  next(): void
  //向前
  back(): void
}
```
</file>

<file path="packages/antd/docs/components/FormTab.md">
# FormTab

> Tab form
>
> Note: This component is only applicable to Schema scenarios

## Markup Schema example

```tsx
import React from 'react'
import {
  FormTab,
  FormItem,
  Input,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Button } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    FormTab,
    Input,
  },
})

const form = createForm()
const formTab = FormTab.createFormTab()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Void
          type="void"
          x-component="FormTab"
          x-component-props={{ formTab }}
        >
          <SchemaField.Void
            type="void"
            name="tab1"
            x-component="FormTab.TabPane"
            x-component-props={{ tab: 'A1' }}
          >
            <SchemaField.String
              name="aaa"
              x-decorator="FormItem"
              title="AAA"
              required
              x-component="Input"
            />
          </SchemaField.Void>
          <SchemaField.Void
            name="tab2"
            x-component="FormTab.TabPane"
            x-component-props={{ tab: 'A2' }}
          >
            <SchemaField.String
              name="bbb"
              x-decorator="FormItem"
              title="BBB"
              required
              x-component="Input"
            />
          </SchemaField.Void>
          <SchemaField.Void
            name="tab3"
            x-component="FormTab.TabPane"
            x-component-props={{ tab: 'A3' }}
          >
            <SchemaField.String
              name="ccc"
              x-decorator="FormItem"
              title="CCC"
              required
              x-component="Input"
            />
          </SchemaField.Void>
        </SchemaField.Void>
      </SchemaField>
      <FormButtonGroup.FormItem>
        <Button
          onClick={() => {
            form.query('tab3').take((field) => {
              field.visible = !field.visible
            })
          }}
        >
          Show/hide the last tab
        </Button>
        <Button
          onClick={() => {
            formTab.setActiveKey('tab2')
          }}
        >
          Switch to the second Tab
        </Button>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup.FormItem>
    </FormProvider>
  )
}
```

## JSON Schema case

```tsx
import React from 'react'
import {
  FormTab,
  FormItem,
  Input,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Button } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    FormTab,
    Input,
  },
})

const form = createForm()
const formTab = FormTab.createFormTab()

const schema = {
  type: 'object',
  properties: {
    collapse: {
      type: 'void',
      'x-component': 'FormTab',
      'x-component-props': {
        formTab: '{{formTab}}',
      },
      properties: {
        tab1: {
          type: 'void',
          'x-component': 'FormTab.TabPane',
          'x-component-props': {
            tab: 'A1',
          },
          properties: {
            aaa: {
              type: 'string',
              title: 'AAA',
              'x-decorator': 'FormItem',
              required: true,
              'x-component': 'Input',
            },
          },
        },
        tab2: {
          type: 'void',
          'x-component': 'FormTab.TabPane',
          'x-component-props': {
            tab: 'A2',
          },
          properties: {
            bbb: {
              type: 'string',
              title: 'BBB',
              'x-decorator': 'FormItem',
              required: true,
              'x-component': 'Input',
            },
          },
        },
        tab3: {
          type: 'void',
          'x-component': 'FormTab.TabPane',
          'x-component-props': {
            tab: 'A3',
          },
          properties: {
            ccc: {
              type: 'string',
              title: 'CCC',
              'x-decorator': 'FormItem',
              required: true,
              'x-component': 'Input',
            },
          },
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} scope={{ formTab }} />
      <FormButtonGroup.FormItem>
        <Button
          onClick={() => {
            form.query('tab3').take((field) => {
              field.visible = !field.visible
            })
          }}
        >
          Show/hide the last tab
        </Button>
        <Button
          onClick={() => {
            formTab.setActiveKey('tab2')
          }}
        >
          Switch to the second Tab
        </Button>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup.FormItem>
    </FormProvider>
  )
}
```

## API

### FormTab

| Property name | Type     | Description                                           | Default value |
| ------------- | -------- | ----------------------------------------------------- | ------------- |
| formTab       | IFormTab | Pass in the model created by createFormTab/useFormTab |               |

Other references https://ant.design/components/tabs-cn/

### FormTab.TabPane

Reference https://ant.design/components/tabs-cn/

### FormTab.createFormTab

```ts pure
type ActiveKey = string | number

interface createFormTab {
  (defaultActiveKey?: ActiveKey): IFormTab
}

interface IFormTab {
  //Activate the primary key
  activeKey: ActiveKey
  //Set the activation key
  setActiveKey(key: ActiveKey): void
}
```
</file>

<file path="packages/antd/docs/components/FormTab.zh-CN.md">
# FormTab

> 选项卡表单
>
> 注意：该组件只适用于 Schema 场景

## Markup Schema 案例

```tsx
import React from 'react'
import {
  FormTab,
  FormItem,
  Input,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Button } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    FormTab,
    Input,
  },
})

const form = createForm()
const formTab = FormTab.createFormTab()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Void
          type="void"
          x-component="FormTab"
          x-component-props={{ formTab }}
        >
          <SchemaField.Void
            type="void"
            name="tab1"
            x-component="FormTab.TabPane"
            x-component-props={{ tab: 'A1' }}
          >
            <SchemaField.String
              name="aaa"
              x-decorator="FormItem"
              title="AAA"
              required
              x-component="Input"
            />
          </SchemaField.Void>
          <SchemaField.Void
            name="tab2"
            x-component="FormTab.TabPane"
            x-component-props={{ tab: 'A2' }}
          >
            <SchemaField.String
              name="bbb"
              x-decorator="FormItem"
              title="BBB"
              required
              x-component="Input"
            />
          </SchemaField.Void>
          <SchemaField.Void
            name="tab3"
            x-component="FormTab.TabPane"
            x-component-props={{ tab: 'A3' }}
          >
            <SchemaField.String
              name="ccc"
              x-decorator="FormItem"
              title="CCC"
              required
              x-component="Input"
            />
          </SchemaField.Void>
        </SchemaField.Void>
      </SchemaField>
      <FormButtonGroup.FormItem>
        <Button
          onClick={() => {
            form.query('tab3').take((field) => {
              field.visible = !field.visible
            })
          }}
        >
          显示/隐藏最后一个Tab
        </Button>
        <Button
          onClick={() => {
            formTab.setActiveKey('tab2')
          }}
        >
          切换第二个Tab
        </Button>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup.FormItem>
    </FormProvider>
  )
}
```

## JSON Schema 案例

```tsx
import React from 'react'
import {
  FormTab,
  FormItem,
  Input,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Button } from 'antd'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    FormTab,
    Input,
  },
})

const form = createForm()
const formTab = FormTab.createFormTab()

const schema = {
  type: 'object',
  properties: {
    collapse: {
      type: 'void',
      'x-component': 'FormTab',
      'x-component-props': {
        formTab: '{{formTab}}',
      },
      properties: {
        tab1: {
          type: 'void',
          'x-component': 'FormTab.TabPane',
          'x-component-props': {
            tab: 'A1',
          },
          properties: {
            aaa: {
              type: 'string',
              title: 'AAA',
              'x-decorator': 'FormItem',
              required: true,
              'x-component': 'Input',
            },
          },
        },
        tab2: {
          type: 'void',
          'x-component': 'FormTab.TabPane',
          'x-component-props': {
            tab: 'A2',
          },
          properties: {
            bbb: {
              type: 'string',
              title: 'BBB',
              'x-decorator': 'FormItem',
              required: true,
              'x-component': 'Input',
            },
          },
        },
        tab3: {
          type: 'void',
          'x-component': 'FormTab.TabPane',
          'x-component-props': {
            tab: 'A3',
          },
          properties: {
            ccc: {
              type: 'string',
              title: 'CCC',
              'x-decorator': 'FormItem',
              required: true,
              'x-component': 'Input',
            },
          },
        },
      },
    },
  },
}

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField schema={schema} scope={{ formTab }} />
      <FormButtonGroup.FormItem>
        <Button
          onClick={() => {
            form.query('tab3').take((field) => {
              field.visible = !field.visible
            })
          }}
        >
          显示/隐藏最后一个Tab
        </Button>
        <Button
          onClick={() => {
            formTab.setActiveKey('tab2')
          }}
        >
          切换第二个Tab
        </Button>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup.FormItem>
    </FormProvider>
  )
}
```

## API

### FormTab

| 属性名  | 类型     | 描述                                             | 默认值 |
| ------- | -------- | ------------------------------------------------ | ------ |
| formTab | IFormTab | 传入通过 createFormTab/useFormTab 创建出来的模型 |        |

其余参考 https://ant.design/components/tabs-cn/

### FormTab.TabPane

参考 https://ant.design/components/tabs-cn/

### FormTab.createFormTab

```ts pure
type ActiveKey = string | number

interface createFormTab {
  (defaultActiveKey?: ActiveKey): IFormTab
}

interface IFormTab {
  //激活主键
  activeKey: ActiveKey
  //设置激活主键
  setActiveKey(key: ActiveKey): void
}
```
</file>

<file path="packages/antd/docs/components/index.md">
# Ant Design

## Introduction

@formily/antd is a professional component library for form scenarios based on Ant Design encapsulation. It has the following characteristics:

- Only Formily 2.x is supported
  - Most components are not backward compatible
  - Unfortunately, many components of 1.x have inherent flaws in the API design. This is also because the form scheme has been explored, so there will be version breaks.
- Richer component system
  - Layout components
    - FormLayout
    - FormItem
    - FormGrid
    - FormButtonGroup
    - Space
    - Submit
    - Reset
  - Input controls
    - Input
    - Password
    - Select
    - TreeSelect
    - DatePicker
    - TimePicker
    - NumberPicker
    - Transfer
    - Cascader
    - Radio
    - Checkbox
    - Upload
    - Switch
  - Scene components
    - ArrayCards
    - ArrayItems
    - ArrayTable
    - ArrayTabs
    - FormCollapse
    - FormStep
    - FormTab
    - FormDialog
    - FormDrawer
    - Editable
  - Reading state component
    - PreviewText
- Theme customization ability
  - Completely abandon the 1.x styled-components solution, follow the style system of the component library, it is more convenient to customize the theme
- Support secondary packaging
  - All components can be repackaged, and the 1.x component system cannot be repackaged, so providing this capability makes it more convenient for users to do business customization
- Support reading mode
  - Although 1.x also supports reading mode, 2.x provides a separate PreviewText component, users can make reading mode encapsulation based on it, which is more flexible
- Type is more friendly
  - Each component has an extremely complete type definition, and users can feel an unprecedented intelligent reminder experience during the actual development process
- More complete layout control capabilities
  - 1.x's layout capabilities have basically converged to FormMegaLayout. This time, we directly removed Mega. Mega is a standard component and is completely internalized into FormLayout and FormItem components. At the same time, MegaLayout's grid layout capabilities are placed in FormGrid components. In, it also provides smarter layout capabilities.
- More elegant and easy-to-use APIs, such as:
  - FormStep in the past has many problems. First, the type is not friendly. Second, the API is too hidden. To control the forward and backwards, you need to understand a bunch of private events. In the new version of FormStep, users only need to pay attention to the FormStep Reactive Model. You can create a Reactive Model through createFormStep and pass it to the FormStep component to quickly communicate. Similarly, FormTab/FormCollapse is the same communication mode.
  - Pop-up forms, drawer forms, presumably in the past, users had to write a lot of code on these two scenarios almost every time. This time, an extremely simple API is directly provided for users to use, which maximizes development efficiency.

## Installation

```bash
$ npm install --save antd moment
$ npm install --save @formily/core @formily/react @formily/antd

```

## Q/A

Q: I want to package a set of component libraries by myself, what should I do?

Answer: If it is an open source component library, you can directly participate in the project co-construction and provide PR. If it is a private component library in the enterprise, you can refer to the source code. The source code does not have too much complicated logic.

Question: Why do components such as ArrayCards/ArrayTable/FormStep only support Schema mode and not pure JSX mode?

Answer: This is the core advantage of Schema mode. With the help of protocols, we can do scene-based abstraction. On the contrary, pure JSX mode is limited by the unparseability of JSX. It is difficult for us to achieve UI-level scene-based abstraction. It's just an abstract hook.
</file>

<file path="packages/antd/docs/components/index.zh-CN.md">
# Ant Design

## 介绍

@formily/antd 是基于 Ant Design 封装的针对表单场景专业级(Professional)组件库，它主要有以下几个特点：

- 仅支持 Formily2.x
  - 大部分组件无法向后兼容
  - 很遗憾，1.x 的很多组件在 API 设计上存在本质上的缺陷，这也是因为表单方案一直在探索之中，所以才会出现版本断裂。
- 更丰富的组件体系
  - 布局组件
    - FormLayout
    - FormItem
    - FormGrid
    - FormButtonGroup
    - Space
    - Submit
    - Reset
  - 输入控件
    - Input
    - Password
    - Select
    - TreeSelect
    - DatePicker
    - TimePicker
    - NumberPicker
    - Transfer
    - Cascader
    - Radio
    - Checkbox
    - Upload
    - Switch
  - 场景组件
    - ArrayCards
    - ArrayItems
    - ArrayTable
    - ArrayTabs
    - FormCollapse
    - FormStep
    - FormTab
    - FormDialog
    - FormDrawer
    - Editable
  - 阅读态组件
    - PreviewText
- 主题定制能力
  - 完全放弃了 1.x styled-components 方案，follow 组件库的样式体系，更方便定制主题
- 支持二次封装
  - 所有组件都能二次封装，1.x 的组件体系是不能二次封装的，所以提供了这个能力则更方便用户做业务定制
- 支持阅读态
  - 虽然 1.x 同样支持阅读态，但是 2.x 单独提供了 PreviewText 组件，用户可以基于它自己做阅读态封装，灵活性更强
- 类型更加友好
  - 每个组件都有着极其完整的类型定义，用户在实际开发过程中，可以感受到前所未有的智能提示体验
- 更完备的布局控制能力
  - 1.x 的布局能力基本上都收敛到了 FormMegaLayout 上，这次，我们直接去掉 Mega，Mega 就是标准组件，完全内化到 FormLayout 和 FormItem 组件中，同时将 MegaLayout 的网格布局能力放到了 FormGrid 组件中，也提供了更智能的布局能力。
- 更优雅易用的 API，比如：
  - 过去的 FormStep，有很多问题，第一，类型不友好，第二，API 隐藏太深，想要控制前进后退需要理解一堆的私有事件。新版 FormStep，用户只需要关注 FormStep Reactive Model 即可，通过 createFormStep 就可以创建出 Reactive Model，传给 FormStep 组件即可快速通讯。同理，FormTab/FormCollapse 也是一样的通讯模式。
  - 弹窗表单，抽屉表单，想必过去，用户几乎每次都得在这两个场景上写大量的代码，这次直接提供了极其简易的 API 让用户使用，最大化提升开发效率。

## 安装

```bash
$ npm install --save antd moment
$ npm install --save @formily/core @formily/react @formily/antd

```

## Q/A

问：我想自己封装一套组件库，该怎么做？

答：如果是开源组件库，可以直接参与项目共建，提供 PR，如果是企业内私有组件库，参考源码即可，源码并没有太多复杂逻辑。

问：为什么 ArrayCards/ArrayTable/FormStep 这类组件只支持 Schema 模式，不支持纯 JSX 模式？

答：这就是 Schema 模式的核心优势，借助协议，我们可以做场景化抽象，相反，纯 JSX 模式，受限于 JSX 的不可解析性，我们很难做到 UI 级别的场景化抽象，更多的只是抽象 Hook。
</file>

<file path="packages/antd/docs/components/Input.md">
# Input

> Text input box

## Markup Schema example

```tsx
import React from 'react'
import { Input, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="input"
        title="input box"
        x-decorator="FormItem"
        x-component="Input"
        required
        x-component-props={{
          style: {
            width: 240,
          },
        }}
      />
      <SchemaField.String
        name="textarea"
        title="text box"
        x-decorator="FormItem"
        required
        x-component="Input.TextArea"
        x-component-props={{
          style: {
            width: 400,
          },
        }}
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema case

```tsx
import React from 'react'
import { Input, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    input: {
      type: 'string',
      title: 'input box',
      'x-decorator': 'FormItem',
      'x-component': 'Input',
      'x-component-props': {
        style: {
          width: 240,
        },
      },
    },
    textarea: {
      type: 'string',
      title: 'input box',
      'x-decorator': 'FormItem',
      'x-component': 'Input.TextArea',
      'x-component-props': {
        style: {
          width: 240,
        },
      },
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## Pure JSX case

```tsx
import React from 'react'
import { Input, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="input"
      title="input box"
      required
      decorator={[FormItem]}
      component={[
        Input,
        {
          style: {
            width: 240,
          },
        },
      ]}
    />
    <Field
      name="textarea"
      title="text box"
      required
      decorator={[FormItem]}
      component={[
        Input.TextArea,
        {
          style: {
            width: 400,
          },
        },
      ]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

Reference https://ant.design/components/input-cn/
</file>

<file path="packages/antd/docs/components/Input.zh-CN.md">
# Input

> 文本输入框

## Markup Schema 案例

```tsx
import React from 'react'
import { Input, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="input"
        title="输入框"
        x-decorator="FormItem"
        x-component="Input"
        required
        x-component-props={{
          style: {
            width: 240,
          },
        }}
      />
      <SchemaField.String
        name="textarea"
        title="文本框"
        x-decorator="FormItem"
        required
        x-component="Input.TextArea"
        x-component-props={{
          style: {
            width: 400,
          },
        }}
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema 案例

```tsx
import React from 'react'
import { Input, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    input: {
      type: 'string',
      title: '输入框',
      'x-decorator': 'FormItem',
      'x-component': 'Input',
      'x-component-props': {
        style: {
          width: 240,
        },
      },
    },
    textarea: {
      type: 'string',
      title: '输入框',
      'x-decorator': 'FormItem',
      'x-component': 'Input.TextArea',
      'x-component-props': {
        style: {
          width: 240,
        },
      },
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## 纯 JSX 案例

```tsx
import React from 'react'
import { Input, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="input"
      title="输入框"
      required
      decorator={[FormItem]}
      component={[
        Input,
        {
          style: {
            width: 240,
          },
        },
      ]}
    />
    <Field
      name="textarea"
      title="文本框"
      required
      decorator={[FormItem]}
      component={[
        Input.TextArea,
        {
          style: {
            width: 400,
          },
        },
      ]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

参考 https://ant.design/components/input-cn/
</file>

<file path="packages/antd/docs/components/NumberPicker.md">
# NumberPicker

> Number input box

## Markup Schema example

```tsx
import React from 'react'
import { NumberPicker, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    NumberPicker,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="input"
        title="input box"
        x-decorator="FormItem"
        x-component="NumberPicker"
        required
        x-component-props={{
          style: {
            width: 240,
          },
        }}
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema case

```tsx
import React from 'react'
import { NumberPicker, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    NumberPicker,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    input: {
      type: 'string',
      title: 'input box',
      'x-decorator': 'FormItem',
      'x-component': 'NumberPicker',
      'x-component-props': {
        style: {
          width: 240,
        },
      },
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## Pure JSX case

```tsx
import React from 'react'
import { NumberPicker, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="input"
      title="input box"
      required
      decorator={[FormItem]}
      component={[
        NumberPicker,
        {
          style: {
            width: 240,
          },
        },
      ]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

Reference https://ant.design/components/input-number-cn/
</file>

<file path="packages/antd/docs/components/NumberPicker.zh-CN.md">
# NumberPicker

> 数字输入框

## Markup Schema 案例

```tsx
import React from 'react'
import { NumberPicker, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    NumberPicker,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="input"
        title="输入框"
        x-decorator="FormItem"
        x-component="NumberPicker"
        required
        x-component-props={{
          style: {
            width: 240,
          },
        }}
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema 案例

```tsx
import React from 'react'
import { NumberPicker, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    NumberPicker,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    input: {
      type: 'string',
      title: '输入框',
      'x-decorator': 'FormItem',
      'x-component': 'NumberPicker',
      'x-component-props': {
        style: {
          width: 240,
        },
      },
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## 纯 JSX 案例

```tsx
import React from 'react'
import { NumberPicker, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="input"
      title="输入框"
      required
      decorator={[FormItem]}
      component={[
        NumberPicker,
        {
          style: {
            width: 240,
          },
        },
      ]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

参考 https://ant.design/components/input-number-cn/
</file>

<file path="packages/antd/docs/components/Password.md">
# Password

> Password input box

## Markup Schema example

```tsx
import React from 'react'
import {
  Password,
  FormItem,
  FormLayout,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Password,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <FormLayout labelCol={6} wrapperCol={10}>
      <SchemaField>
        <SchemaField.String
          name="input"
          title="input box"
          x-decorator="FormItem"
          x-component="Password"
          required
          x-component-props={{
            checkStrength: true,
          }}
        />
      </SchemaField>
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup.FormItem>
    </FormLayout>
  </FormProvider>
)
```

## JSON Schema case

```tsx
import React from 'react'
import {
  Password,
  FormItem,
  FormLayout,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Password,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    input: {
      type: 'string',
      title: 'input box',
      'x-decorator': 'FormItem',
      'x-component': 'Password',
      'x-component-props': {
        checkStrength: true,
      },
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <FormLayout labelCol={6} wrapperCol={10}>
      <SchemaField schema={schema} />
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup.FormItem>
    </FormLayout>
  </FormProvider>
)
```

## Pure JSX case

```tsx
import React from 'react'
import {
  Password,
  FormItem,
  FormLayout,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'
const form = createForm()

export default () => (
  <FormProvider form={form}>
    <FormLayout labelCol={6} wrapperCol={10}>
      <Field
        name="input"
        title="input box"
        required
        decorator={[FormItem]}
        component={[
          Password,
          {
            checkStrength: true,
          },
        ]}
      />
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup.FormItem>
    </FormLayout>
  </FormProvider>
)
```

## API

Reference https://ant.design/components/input-cn/
</file>

<file path="packages/antd/docs/components/Password.zh-CN.md">
# Password

> 密码输入框

## Markup Schema 案例

```tsx
import React from 'react'
import {
  Password,
  FormItem,
  FormLayout,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Password,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <FormLayout labelCol={6} wrapperCol={10}>
      <SchemaField>
        <SchemaField.String
          name="input"
          title="输入框"
          x-decorator="FormItem"
          x-component="Password"
          required
          x-component-props={{
            checkStrength: true,
          }}
        />
      </SchemaField>
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup.FormItem>
    </FormLayout>
  </FormProvider>
)
```

## JSON Schema 案例

```tsx
import React from 'react'
import {
  Password,
  FormItem,
  FormLayout,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Password,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    input: {
      type: 'string',
      title: '输入框',
      'x-decorator': 'FormItem',
      'x-component': 'Password',
      'x-component-props': {
        checkStrength: true,
      },
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <FormLayout labelCol={6} wrapperCol={10}>
      <SchemaField schema={schema} />
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup.FormItem>
    </FormLayout>
  </FormProvider>
)
```

## 纯 JSX 案例

```tsx
import React from 'react'
import {
  Password,
  FormItem,
  FormLayout,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'
const form = createForm()

export default () => (
  <FormProvider form={form}>
    <FormLayout labelCol={6} wrapperCol={10}>
      <Field
        name="input"
        title="输入框"
        required
        decorator={[FormItem]}
        component={[
          Password,
          {
            checkStrength: true,
          },
        ]}
      />
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup.FormItem>
    </FormLayout>
  </FormProvider>
)
```

## API

参考 https://ant.design/components/input-cn/
</file>

<file path="packages/antd/docs/components/PreviewText.md">
# PreviewText

> Reading state components, mainly used to implement the reading state of these components of class Input and DatePicker

## Simple use case

```tsx
import React from 'react'
import { PreviewText, FormItem, FormLayout } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    PreviewText,
  },
})

const form = createForm()

export default () => {
  return (
    <FormLayout labelCol={6} wrapperCol={10}>
      <FormProvider form={form}>
        <SchemaField>
          <SchemaField.String
            x-decorator="FormItem"
            title="text preview"
            x-component="PreviewText.Input"
            default={'Hello world'}
          />
          <SchemaField.String
            x-decorator="FormItem"
            title="Select item preview"
            x-component="PreviewText.Select"
            x-component-props={{
              mode: 'multiple',
            }}
            default={['123', '222']}
            enum={[
              { label: 'A111', value: '123' },
              { label: 'A222', value: '222' },
            ]}
          />

          <SchemaField.String
            x-decorator="FormItem"
            title="TreeSelect preview"
            x-component="PreviewText.TreeSelect"
            x-component-props={{
              multiple: true,
            }}
            default={['123', '222']}
            enum={[
              { label: 'A111', value: '123' },
              { label: 'A222', value: '222' },
            ]}
          />
          <SchemaField.String
            x-decorator="FormItem"
            title="TreeSelect（treeData）preview"
            x-component="PreviewText.TreeSelect"
            x-component-props={{
              multiple: true,
              treeNodeLabelProp: 'name',
              treeData: [
                { name: 'A111', value: '123' },
                { name: 'A222', value: '222' },
              ],
            }}
            default={['123', '222']}
          />
          <SchemaField.String
            x-decorator="FormItem"
            title="date preview"
            x-component="PreviewText.DatePicker"
            default={'2020-11-23 22:15:20'}
          />
          <SchemaField.String
            x-decorator="FormItem"
            title="Cascader Preview"
            x-component="PreviewText.Cascader"
            default={'yuhang'}
            enum={[
              {
                label: 'Hangzhou',
                value: 'hangzhou',
                children: [
                  {
                    label: 'Yuhang',
                    value: 'yuhang',
                  },
                ],
              },
            ]}
          />
        </SchemaField>
      </FormProvider>
    </FormLayout>
  )
}
```

## Extended reading mode

```tsx
import React from 'react'
import {
  PreviewText,
  FormItem,
  FormLayout,
  FormButtonGroup,
} from '@formily/antd'
import { createForm } from '@formily/core'
import {
  FormProvider,
  mapReadPretty,
  connect,
  createSchemaField,
} from '@formily/react'
import { Button, Input as AntdInput } from 'antd'

const Input = connect(AntdInput, mapReadPretty(PreviewText.Input))

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
    PreviewText,
  },
})

const form = createForm()

export default () => {
  return (
    <PreviewText.Placeholder value="No data currently available">
      <FormLayout labelCol={6} wrapperCol={10}>
        <FormProvider form={form}>
          <SchemaField>
            <SchemaField.Markup
              type="string"
              x-decorator="FormItem"
              title="text preview"
              required
              x-component="Input"
              default={'Hello world'}
            />
            <SchemaField.Markup
              type="string"
              x-decorator="FormItem"
              title="Select item preview"
              x-component="PreviewText.Select"
              x-component-props={{
                mode: 'multiple',
              }}
              default={['123']}
              enum={[
                { label: 'A111', value: '123' },
                { label: 'A222', value: '222' },
              ]}
            />
            <SchemaField.Markup
              type="string"
              x-decorator="FormItem"
              title="date preview"
              x-component="PreviewText.DatePicker"
            />
            <SchemaField.Markup
              type="string"
              x-decorator="FormItem"
              title="Cascader Preview"
              x-component="PreviewText.Cascader"
              default={'yuhang'}
              enum={[
                {
                  label: 'Hangzhou',
                  value: 'hangzhou',
                  children: [
                    {
                      label: 'Yuhang',
                      value: 'yuhang',
                    },
                  ],
                },
              ]}
            />
          </SchemaField>
          <FormButtonGroup.FormItem>
            <Button
              onClick={() => {
                form.setState((state) => {
                  state.editable = !state.editable
                })
              }}
            >
              Switch reading mode
            </Button>
          </FormButtonGroup.FormItem>
        </FormProvider>
      </FormLayout>
    </PreviewText.Placeholder>
  )
}
```

## API

### PreviewText.Input

Reference https://ant.design/components/input-cn/

### PreviewText.Select

Reference https://ant.design/components/select-cn/

### PreviewText.TreeSelect

Reference https://ant.design/components/tree-select-cn/

### PreviewText.Cascader

Reference https://ant.design/components/cascader-cn/

### PreviewText.DatePicker

Reference https://ant.design/components/date-picker-cn/

### PreviewText.DateRangePicker

Reference https://ant.design/components/date-picker-cn/

### PreviewText.TimePicker

Reference https://ant.design/components/time-picker-cn/

### PreviewText.TimeRangePicker

Reference https://ant.design/components/time-picker-cn/

### PreviewText.NumberPicker

参考 https://ant.design/components/input-number-cn/

### PreviewText.Placeholder

| Property name | Type   | Description         | Default value |
| ------------- | ------ | ------------------- | ------------- |
| value         | stirng | Default placeholder | N/A           |

### PreviewText.usePlaceholder

```ts pure
interface usePlaceholder {
  (): string
}
```
</file>

<file path="packages/antd/docs/components/PreviewText.zh-CN.md">
# PreviewText

> 阅读态组件，主要用来实现类 Input，类 DatePicker 这些组件的阅读态

## 简单用例

```tsx
import React from 'react'
import { PreviewText, FormItem, FormLayout } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    PreviewText,
  },
})

const form = createForm()

export default () => {
  return (
    <FormLayout labelCol={6} wrapperCol={10}>
      <FormProvider form={form}>
        <SchemaField>
          <SchemaField.String
            x-decorator="FormItem"
            title="文本预览"
            x-component="PreviewText.Input"
            default={'Hello world'}
          />
          <SchemaField.String
            x-decorator="FormItem"
            title="选择项预览"
            x-component="PreviewText.Select"
            x-component-props={{
              mode: 'multiple',
            }}
            default={['123', '222']}
            enum={[
              { label: 'A111', value: '123' },
              { label: 'A222', value: '222' },
            ]}
          />
          <SchemaField.String
            x-decorator="FormItem"
            title="树选择预览"
            x-component="PreviewText.TreeSelect"
            x-component-props={{
              multiple: true,
            }}
            default={['123', '222']}
            enum={[
              { label: 'A111', value: '123' },
              { label: 'A222', value: '222' },
            ]}
          />
          <SchemaField.String
            x-decorator="FormItem"
            title="树选择（treeData）预览"
            x-component="PreviewText.TreeSelect"
            x-component-props={{
              multiple: true,
              treeNodeLabelProp: 'name',
              treeData: [
                { name: 'A111', value: '123' },
                { name: 'A222', value: '222' },
              ],
            }}
            default={['123', '222']}
          />
          <SchemaField.String
            x-decorator="FormItem"
            title="日期预览"
            x-component="PreviewText.DatePicker"
            default={'2020-11-23 22:15:20'}
          />
          <SchemaField.String
            x-decorator="FormItem"
            title="Cascader预览"
            x-component="PreviewText.Cascader"
            default={'yuhang'}
            enum={[
              {
                label: '杭州',
                value: 'hangzhou',
                children: [
                  {
                    label: '余杭',
                    value: 'yuhang',
                  },
                ],
              },
            ]}
          />
        </SchemaField>
      </FormProvider>
    </FormLayout>
  )
}
```

## 扩展阅读态

```tsx
import React from 'react'
import {
  PreviewText,
  FormItem,
  FormLayout,
  FormButtonGroup,
} from '@formily/antd'
import { createForm } from '@formily/core'
import {
  FormProvider,
  mapReadPretty,
  connect,
  createSchemaField,
} from '@formily/react'
import { Button, Input as AntdInput } from 'antd'

const Input = connect(AntdInput, mapReadPretty(PreviewText.Input))

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
    PreviewText,
  },
})

const form = createForm()

export default () => {
  return (
    <PreviewText.Placeholder value="暂无数据">
      <FormLayout labelCol={6} wrapperCol={10}>
        <FormProvider form={form}>
          <SchemaField>
            <SchemaField.Markup
              type="string"
              x-decorator="FormItem"
              title="文本预览"
              required
              x-component="Input"
              default={'Hello world'}
            />
            <SchemaField.Markup
              type="string"
              x-decorator="FormItem"
              title="选择项预览"
              x-component="PreviewText.Select"
              x-component-props={{
                mode: 'multiple',
              }}
              default={['123']}
              enum={[
                { label: 'A111', value: '123' },
                { label: 'A222', value: '222' },
              ]}
            />
            <SchemaField.Markup
              type="string"
              x-decorator="FormItem"
              title="日期预览"
              x-component="PreviewText.DatePicker"
            />
            <SchemaField.Markup
              type="string"
              x-decorator="FormItem"
              title="Cascader预览"
              x-component="PreviewText.Cascader"
              default={'yuhang'}
              enum={[
                {
                  label: '杭州',
                  value: 'hangzhou',
                  children: [
                    {
                      label: '余杭',
                      value: 'yuhang',
                    },
                  ],
                },
              ]}
            />
          </SchemaField>
          <FormButtonGroup.FormItem>
            <Button
              onClick={() => {
                form.setState((state) => {
                  state.editable = !state.editable
                })
              }}
            >
              切换阅读态
            </Button>
          </FormButtonGroup.FormItem>
        </FormProvider>
      </FormLayout>
    </PreviewText.Placeholder>
  )
}
```

## API

### PreviewText.Input

参考 https://ant.design/components/input-cn/

### PreviewText.Select

参考 https://ant.design/components/select-cn/

### PreviewText.TreeSelect

参考 https://ant.design/components/tree-select-cn/

### PreviewText.Cascader

参考 https://ant.design/components/cascader-cn/

### PreviewText.DatePicker

参考 https://ant.design/components/date-picker-cn/

### PreviewText.DateRangePicker

参考 https://ant.design/components/date-picker-cn/

### PreviewText.TimePicker

参考 https://ant.design/components/time-picker-cn/

### PreviewText.TimeRangePicker

参考 https://ant.design/components/time-picker-cn/

### PreviewText.NumberPicker

参考 https://ant.design/components/input-number-cn/

### PreviewText.Placeholder

| 属性名 | 类型   | 描述       | 默认值 |
| ------ | ------ | ---------- | ------ |
| value  | stirng | 缺省占位符 | N/A    |

### PreviewText.usePlaceholder

```ts pure
interface usePlaceholder {
  (): string
}
```
</file>

<file path="packages/antd/docs/components/Radio.md">
# Radio

> Single selection box

## Markup Schema example

```tsx
import React from 'react'
import { Radio, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Radio,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Number
        name="radio"
        title="single choice"
        enum={[
          {
            label: 'Option 1',
            value: 1,
          },
          {
            label: 'Option 2',
            value: 2,
          },
        ]}
        x-decorator="FormItem"
        x-component="Radio.Group"
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema case

```tsx
import React from 'react'
import { Radio, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Radio,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    radio: {
      type: 'number',
      title: 'Single selection',
      enum: [
        {
          label: 'Option 1',
          value: 1,
        },
        {
          label: 'Option 2',
          value: 2,
        },
      ],
      'x-decorator': 'FormItem',
      'x-component': 'Radio.Group',
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## Pure JSX case

```tsx
import React from 'react'
import { Radio, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="radio"
      title="single choice"
      dataSource={[
        {
          label: 'Option 1',
          value: 1,
        },
        {
          label: 'Option 2',
          value: 2,
        },
      ]}
      decorator={FormItem}
      component={Radio.Group}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

Reference https://ant.design/components/radio-cn/
</file>

<file path="packages/antd/docs/components/Radio.zh-CN.md">
# Radio

> 单选框

## Markup Schema 案例

```tsx
import React from 'react'
import { Radio, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Radio,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Number
        name="radio"
        title="单选"
        enum={[
          {
            label: '选项1',
            value: 1,
          },
          {
            label: '选项2',
            value: 2,
          },
        ]}
        x-decorator="FormItem"
        x-component="Radio.Group"
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema 案例

```tsx
import React from 'react'
import { Radio, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Radio,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    radio: {
      type: 'number',
      title: '单选',
      enum: [
        {
          label: '选项1',
          value: 1,
        },
        {
          label: '选项2',
          value: 2,
        },
      ],
      'x-decorator': 'FormItem',
      'x-component': 'Radio.Group',
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## 纯 JSX 案例

```tsx
import React from 'react'
import { Radio, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="radio"
      title="单选"
      dataSource={[
        {
          label: '选项1',
          value: 1,
        },
        {
          label: '选项2',
          value: 2,
        },
      ]}
      decorator={FormItem}
      component={Radio.Group}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

参考 https://ant.design/components/radio-cn/
</file>

<file path="packages/antd/docs/components/Reset.md">
# Reset

> Reset button

## Normal reset

> Controls with default values cannot be cleared

```tsx
import React from 'react'
import { Input, FormItem, FormButtonGroup, Reset } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="input"
        title="input box"
        required
        x-decorator="FormItem"
        x-component="Input"
      />
      <SchemaField.String
        name="input2"
        title="input box"
        default="123"
        required
        x-decorator="FormItem"
        x-component="Input"
      />
    </SchemaField>
    <FormButtonGroup>
      <Reset>Reset</Reset>
    </FormButtonGroup>
  </FormProvider>
)
```

## Force empty reset

```tsx
import React from 'react'
import { Input, FormItem, FormButtonGroup, Reset } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="input"
        title="input box"
        required
        x-decorator="FormItem"
        x-component="Input"
      />
      <SchemaField.String
        name="input2"
        title="input box"
        default="123"
        required
        x-decorator="FormItem"
        x-component="Input"
      />
    </SchemaField>
    <FormButtonGroup>
      <Reset forceClear>Reset</Reset>
    </FormButtonGroup>
  </FormProvider>
)
```

## Reset and verify

```tsx
import React from 'react'
import { Input, FormItem, FormButtonGroup, Reset } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="input"
        title="input box"
        required
        x-decorator="FormItem"
        x-component="Input"
      />
      <SchemaField.String
        name="input2"
        title="input box"
        default="123"
        required
        x-decorator="FormItem"
        x-component="Input"
      />
    </SchemaField>
    <FormButtonGroup>
      <Reset validate>Reset</Reset>
    </FormButtonGroup>
  </FormProvider>
)
```

## Force empty reset and verify

```tsx
import React from 'react'
import { Input, FormItem, FormButtonGroup, Reset } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="input"
        title="input box"
        required
        x-decorator="FormItem"
        x-component="Input"
      />
      <SchemaField.String
        name="input2"
        title="input box"
        default="123"
        required
        x-decorator="FormItem"
        x-component="Input"
      />
    </SchemaField>
    <FormButtonGroup>
      <Reset forceClear validate>
        Reset
      </Reset>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

### Reset

Other API reference https://ant.design/components/button-cn/

| Property name          | Type                                                                                             | Description                                              | Default value |
| ---------------------- | ------------------------------------------------------------------------------------------------ | -------------------------------------------------------- | ------------- |
| onClick                | `(event: MouseEvent) => void \| boolean`                                                         | Click event, if it returns false, it can block resetting | -             |
| onResetValidateSuccess | (payload: any) => void                                                                           | Reset validation success event                           | -             |
| onResetValidateFailed  | (feedbacks: [IFormFeedback](https://core.formilyjs.org/api/models/form#iformfeedback)[]) => void | Reset validation failure event                           | -             |
</file>

<file path="packages/antd/docs/components/Reset.zh-CN.md">
# Reset

> 重置按钮

## 普通重置

> 有默认值的控件无法被清空

```tsx
import React from 'react'
import { Input, FormItem, FormButtonGroup, Reset } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="input"
        title="输入框"
        required
        x-decorator="FormItem"
        x-component="Input"
      />
      <SchemaField.String
        name="input2"
        title="输入框"
        default="123"
        required
        x-decorator="FormItem"
        x-component="Input"
      />
    </SchemaField>
    <FormButtonGroup>
      <Reset>重置</Reset>
    </FormButtonGroup>
  </FormProvider>
)
```

## 强制清空重置

```tsx
import React from 'react'
import { Input, FormItem, FormButtonGroup, Reset } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="input"
        title="输入框"
        required
        x-decorator="FormItem"
        x-component="Input"
      />
      <SchemaField.String
        name="input2"
        title="输入框"
        default="123"
        required
        x-decorator="FormItem"
        x-component="Input"
      />
    </SchemaField>
    <FormButtonGroup>
      <Reset forceClear>重置</Reset>
    </FormButtonGroup>
  </FormProvider>
)
```

## 重置并校验

```tsx
import React from 'react'
import { Input, FormItem, FormButtonGroup, Reset } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="input"
        title="输入框"
        required
        x-decorator="FormItem"
        x-component="Input"
      />
      <SchemaField.String
        name="input2"
        title="输入框"
        default="123"
        required
        x-decorator="FormItem"
        x-component="Input"
      />
    </SchemaField>
    <FormButtonGroup>
      <Reset validate>重置</Reset>
    </FormButtonGroup>
  </FormProvider>
)
```

## 强制清空重置并校验

```tsx
import React from 'react'
import { Input, FormItem, FormButtonGroup, Reset } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="input"
        title="输入框"
        required
        x-decorator="FormItem"
        x-component="Input"
      />
      <SchemaField.String
        name="input2"
        title="输入框"
        default="123"
        required
        x-decorator="FormItem"
        x-component="Input"
      />
    </SchemaField>
    <FormButtonGroup>
      <Reset forceClear validate>
        重置
      </Reset>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

### Reset

其余 API 参考 https://ant.design/components/button-cn/

| 属性名                 | 类型                                                                                                   | 描述                                  | 默认值 |
| ---------------------- | ------------------------------------------------------------------------------------------------------ | ------------------------------------- | ------ |
| onClick                | `(event: MouseEvent) => void \| boolean`                                                               | 点击事件，如果返回 false 可以阻塞重置 | -      |
| onResetValidateSuccess | (payload: any) => void                                                                                 | 重置校验成功事件                      | -      |
| onResetValidateFailed  | (feedbacks: [IFormFeedback](https://core.formilyjs.org/zh-CN/api/models/form#iformfeedback)[]) => void | 重置校验失败事件                      | -      |
</file>

<file path="packages/antd/docs/components/Select.md">
# Select

> Drop-down box components

## Markup Schema synchronization data source case

```tsx
import React from 'react'
import { Select, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Select,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Number
        name="select"
        title="select box"
        x-decorator="FormItem"
        x-component="Select"
        enum={[
          { label: 'Option 1', value: 1 },
          { label: 'Option 2', value: 2 },
        ]}
        x-component-props={{
          style: {
            width: 120,
          },
        }}
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## Markup Schema Asynchronous Search Case

```tsx
import React from 'react'
import { Select, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import {
  createForm,
  onFieldReact,
  onFieldInit,
  FormPathPattern,
  Field,
} from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { action, observable } from '@formily/reactive'
import { fetch } from 'mfetch'

let timeout
let currentValue

function fetchData(value, callback) {
  if (timeout) {
    clearTimeout(timeout)
    timeout = null
  }
  currentValue = value

  function fake() {
    fetch(`https://suggest.taobao.com/sug?q=${value}`, {
      method: 'jsonp',
    })
      .then((response) => response.json())
      .then((d) => {
        if (currentValue === value) {
          const { result } = d
          const data = []
          result.forEach((r) => {
            data.push({
              value: r[0],
              text: r[0],
            })
          })
          callback(data)
        }
      })
  }

  timeout = setTimeout(fake, 300)
}

const SchemaField = createSchemaField({
  components: {
    Select,
    FormItem,
  },
})

const useAsyncDataSource = (
  pattern: FormPathPattern,
  service: (param: {
    keyword: string
    field: Field
  }) => Promise<{ label: string; value: any }[]>
) => {
  const keyword = observable.ref('')

  onFieldInit(pattern, (field) => {
    field.setComponentProps({
      onSearch: (value) => {
        keyword.value = value
      },
    })
  })

  onFieldReact(pattern, (field) => {
    field.loading = true
    service({ field, keyword: keyword.value }).then(
      action.bound((data) => {
        field.dataSource = data
        field.loading = false
      })
    )
  })
}

const form = createForm({
  effects: () => {
    useAsyncDataSource('select', async ({ keyword }) => {
      if (!keyword) {
        return []
      }
      return new Promise((resolve) => {
        fetchData(keyword, resolve)
      })
    })
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="select"
        title="Asynchronous search select box"
        x-decorator="FormItem"
        x-component="Select"
        x-component-props={{
          showSearch: true,
          filterOption: false,
          style: {
            width: 300,
          },
        }}
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## Markup Schema Asynchronous Linkage Data Source Case

```tsx
import React from 'react'
import { Select, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm, onFieldReact, FormPathPattern, Field } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { action } from '@formily/reactive'

const SchemaField = createSchemaField({
  components: {
    Select,
    FormItem,
  },
})

const useAsyncDataSource = (
  pattern: FormPathPattern,
  service: (field: Field) => Promise<{ label: string; value: any }[]>
) => {
  onFieldReact(pattern, (field) => {
    field.loading = true
    service(field).then(
      action.bound((data) => {
        field.dataSource = data
        field.loading = false
      })
    )
  })
}

const form = createForm({
  effects: () => {
    useAsyncDataSource('select', async (field) => {
      const linkage = field.query('linkage').get('value')
      if (!linkage) return []
      return new Promise((resolve) => {
        setTimeout(() => {
          if (linkage === 1) {
            resolve([
              {
                label: 'AAA',
                value: 'aaa',
              },
              {
                label: 'BBB',
                value: 'ccc',
              },
            ])
          } else if (linkage === 2) {
            resolve([
              {
                label: 'CCC',
                value: 'ccc',
              },
              {
                label: 'DDD',
                value: 'ddd',
              },
            ])
          }
        }, 1500)
      })
    })
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Number
        name="linkage"
        title="Linkage selection box"
        x-decorator="FormItem"
        x-component="Select"
        enum={[
          { label: 'Request 1', value: 1 },
          { label: 'Request 2', value: 2 },
        ]}
        x-component-props={{
          style: {
            width: 120,
          },
        }}
      />
      <SchemaField.String
        name="select"
        title="Asynchronous select box"
        x-decorator="FormItem"
        x-component="Select"
        x-component-props={{
          style: {
            width: 120,
          },
        }}
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema synchronization data source case

```tsx
import React from 'react'
import { Select, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Select,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    select: {
      type: 'string',
      title: 'Select box',
      'x-decorator': 'FormItem',
      'x-component': 'Select',
      enum: [
        { label: 'Option 1', value: 1 },
        { label: 'Option 2', value: 2 },
      ],
      'x-component-props': {
        style: {
          width: 120,
        },
      },
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema asynchronous linkage data source case

```tsx
import React from 'react'
import { Select, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { action } from '@formily/reactive'

const SchemaField = createSchemaField({
  components: {
    Select,
    FormItem,
  },
})

const loadData = async (field) => {
  const linkage = field.query('linkage').get('value')
  if (!linkage) return []
  return new Promise((resolve) => {
    setTimeout(() => {
      if (linkage === 1) {
        resolve([
          {
            label: 'AAA',
            value: 'aaa',
          },
          {
            label: 'BBB',
            value: 'ccc',
          },
        ])
      } else if (linkage === 2) {
        resolve([
          {
            label: 'CCC',
            value: 'ccc',
          },
          {
            label: 'DDD',
            value: 'ddd',
          },
        ])
      }
    }, 1500)
  })
}

const useAsyncDataSource = (service) => (field) => {
  field.loading = true
  service(field).then(
    action.bound((data) => {
      field.dataSource = data
      field.loading = false
    })
  )
}

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    linkage: {
      type: 'string',
      title: 'Linkage selection box',
      enum: [
        { label: 'Request 1', value: 1 },
        { label: 'Request 2', value: 2 },
      ],
      'x-decorator': 'FormItem',
      'x-component': 'Select',
      'x-component-props': {
        style: {
          width: 120,
        },
      },
    },
    select: {
      type: 'string',
      title: 'Asynchronous selection box',
      'x-decorator': 'FormItem',
      'x-component': 'Select',
      'x-component-props': {
        style: {
          width: 120,
        },
      },
      'x-reactions': ['{{useAsyncDataSource(loadData)}}'],
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} scope={{ useAsyncDataSource, loadData }} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## Pure JSX synchronization data source case

```tsx
import React from 'react'
import { Select, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="select"
      title="select box"
      dataSource={[
        { label: 'Option 1', value: 1 },
        { label: 'Option 2', value: 2 },
      ]}
      decorator={[FormItem]}
      component={[
        Select,
        {
          style: {
            width: 120,
          },
        },
      ]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## Pure JSX asynchronous linkage data source case

```tsx
import React from 'react'
import { Select, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import {
  createForm,
  onFieldReact,
  FormPathPattern,
  Field as FieldType,
} from '@formily/core'
import { FormProvider, Field } from '@formily/react'
import { action } from '@formily/reactive'

const useAsyncDataSource = (
  pattern: FormPathPattern,
  service: (field: FieldType) => Promise<{ label: string; value: any }[]>
) => {
  onFieldReact(pattern, (field) => {
    field.loading = true
    service(field).then(
      action.bound((data) => {
        field.dataSource = data
        field.loading = false
      })
    )
  })
}

const form = createForm({
  effects: () => {
    useAsyncDataSource('select', async (field) => {
      const linkage = field.query('linkage').get('value')
      if (!linkage) return []
      return new Promise((resolve) => {
        setTimeout(() => {
          if (linkage === 1) {
            resolve([
              {
                label: 'AAA',
                value: 'aaa',
              },
              {
                label: 'BBB',
                value: 'ccc',
              },
            ])
          } else if (linkage === 2) {
            resolve([
              {
                label: 'CCC',
                value: 'ccc',
              },
              {
                label: 'DDD',
                value: 'ddd',
              },
            ])
          }
        }, 1500)
      })
    })
  },
})

export default () => (
  <FormProvider form={form}>
    <Field
      name="linkage"
      title="Linkage selection box"
      dataSource={[
        { label: 'Request 1', value: 1 },
        { label: 'Request 2', value: 2 },
      ]}
      decorator={[FormItem]}
      component={[
        Select,
        {
          style: {
            width: 120,
          },
        },
      ]}
    />
    <Field
      name="select"
      title="Asynchronous select box"
      decorator={[FormItem]}
      component={[
        Select,
        {
          style: {
            width: 120,
          },
        },
      ]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

Reference https://ant.design/components/select-cn/
</file>

<file path="packages/antd/docs/components/Select.zh-CN.md">
# Select

> 下拉框组件

## Markup Schema 同步数据源案例

```tsx
import React from 'react'
import { Select, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Select,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Number
        name="select"
        title="选择框"
        x-decorator="FormItem"
        x-component="Select"
        enum={[
          { label: '选项1', value: 1 },
          { label: '选项2', value: 2 },
        ]}
        x-component-props={{
          style: {
            width: 120,
          },
        }}
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## Markup Schema 异步搜索案例

```tsx
import React from 'react'
import { Select, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import {
  createForm,
  onFieldReact,
  onFieldInit,
  FormPathPattern,
  Field,
} from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { action, observable } from '@formily/reactive'
import { fetch } from 'mfetch'

let timeout
let currentValue

function fetchData(value, callback) {
  if (timeout) {
    clearTimeout(timeout)
    timeout = null
  }
  currentValue = value

  function fake() {
    fetch(`https://suggest.taobao.com/sug?q=${value}`, {
      method: 'jsonp',
    })
      .then((response) => response.json())
      .then((d) => {
        if (currentValue === value) {
          const { result } = d
          const data = []
          result.forEach((r) => {
            data.push({
              value: r[0],
              text: r[0],
            })
          })
          callback(data)
        }
      })
  }

  timeout = setTimeout(fake, 300)
}

const SchemaField = createSchemaField({
  components: {
    Select,
    FormItem,
  },
})

const useAsyncDataSource = (
  pattern: FormPathPattern,
  service: (param: {
    keyword: string
    field: Field
  }) => Promise<{ label: string; value: any }[]>
) => {
  const keyword = observable.ref('')

  onFieldInit(pattern, (field) => {
    field.setComponentProps({
      onSearch: (value) => {
        keyword.value = value
      },
    })
  })

  onFieldReact(pattern, (field) => {
    field.loading = true
    service({ field, keyword: keyword.value }).then(
      action.bound((data) => {
        field.dataSource = data
        field.loading = false
      })
    )
  })
}

const form = createForm({
  effects: () => {
    useAsyncDataSource('select', async ({ keyword }) => {
      if (!keyword) {
        return []
      }
      return new Promise((resolve) => {
        fetchData(keyword, resolve)
      })
    })
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="select"
        title="异步搜索选择框"
        x-decorator="FormItem"
        x-component="Select"
        x-component-props={{
          showSearch: true,
          filterOption: false,
          style: {
            width: 300,
          },
        }}
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## Markup Schema 异步联动数据源案例

```tsx
import React from 'react'
import { Select, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm, onFieldReact, FormPathPattern, Field } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { action } from '@formily/reactive'

const SchemaField = createSchemaField({
  components: {
    Select,
    FormItem,
  },
})

const useAsyncDataSource = (
  pattern: FormPathPattern,
  service: (field: Field) => Promise<{ label: string; value: any }[]>
) => {
  onFieldReact(pattern, (field) => {
    field.loading = true
    service(field).then(
      action.bound((data) => {
        field.dataSource = data
        field.loading = false
      })
    )
  })
}

const form = createForm({
  effects: () => {
    useAsyncDataSource('select', async (field) => {
      const linkage = field.query('linkage').get('value')
      if (!linkage) return []
      return new Promise((resolve) => {
        setTimeout(() => {
          if (linkage === 1) {
            resolve([
              {
                label: 'AAA',
                value: 'aaa',
              },
              {
                label: 'BBB',
                value: 'ccc',
              },
            ])
          } else if (linkage === 2) {
            resolve([
              {
                label: 'CCC',
                value: 'ccc',
              },
              {
                label: 'DDD',
                value: 'ddd',
              },
            ])
          }
        }, 1500)
      })
    })
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Number
        name="linkage"
        title="联动选择框"
        x-decorator="FormItem"
        x-component="Select"
        enum={[
          { label: '发请求1', value: 1 },
          { label: '发请求2', value: 2 },
        ]}
        x-component-props={{
          style: {
            width: 120,
          },
        }}
      />
      <SchemaField.String
        name="select"
        title="异步选择框"
        x-decorator="FormItem"
        x-component="Select"
        x-component-props={{
          style: {
            width: 120,
          },
        }}
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema 同步数据源案例

```tsx
import React from 'react'
import { Select, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Select,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    select: {
      type: 'string',
      title: '选择框',
      'x-decorator': 'FormItem',
      'x-component': 'Select',
      enum: [
        { label: '选项1', value: 1 },
        { label: '选项2', value: 2 },
      ],
      'x-component-props': {
        style: {
          width: 120,
        },
      },
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema 异步联动数据源案例

```tsx
import React from 'react'
import { Select, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { action } from '@formily/reactive'

const SchemaField = createSchemaField({
  components: {
    Select,
    FormItem,
  },
})

const loadData = async (field) => {
  const linkage = field.query('linkage').get('value')
  if (!linkage) return []
  return new Promise((resolve) => {
    setTimeout(() => {
      if (linkage === 1) {
        resolve([
          {
            label: 'AAA',
            value: 'aaa',
          },
          {
            label: 'BBB',
            value: 'ccc',
          },
        ])
      } else if (linkage === 2) {
        resolve([
          {
            label: 'CCC',
            value: 'ccc',
          },
          {
            label: 'DDD',
            value: 'ddd',
          },
        ])
      }
    }, 1500)
  })
}

const useAsyncDataSource = (service) => (field) => {
  field.loading = true
  service(field).then(
    action.bound((data) => {
      field.dataSource = data
      field.loading = false
    })
  )
}

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    linkage: {
      type: 'string',
      title: '联动选择框',
      enum: [
        { label: '发请求1', value: 1 },
        { label: '发请求2', value: 2 },
      ],
      'x-decorator': 'FormItem',
      'x-component': 'Select',
      'x-component-props': {
        style: {
          width: 120,
        },
      },
    },
    select: {
      type: 'string',
      title: '异步选择框',
      'x-decorator': 'FormItem',
      'x-component': 'Select',
      'x-component-props': {
        style: {
          width: 120,
        },
      },
      'x-reactions': ['{{useAsyncDataSource(loadData)}}'],
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} scope={{ useAsyncDataSource, loadData }} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## 纯 JSX 同步数据源案例

```tsx
import React from 'react'
import { Select, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="select"
      title="选择框"
      dataSource={[
        { label: '选项1', value: 1 },
        { label: '选项2', value: 2 },
      ]}
      decorator={[FormItem]}
      component={[
        Select,
        {
          style: {
            width: 120,
          },
        },
      ]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## 纯 JSX 异步联动数据源案例

```tsx
import React from 'react'
import { Select, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import {
  createForm,
  onFieldReact,
  FormPathPattern,
  Field as FieldType,
} from '@formily/core'
import { FormProvider, Field } from '@formily/react'
import { action } from '@formily/reactive'

const useAsyncDataSource = (
  pattern: FormPathPattern,
  service: (field: FieldType) => Promise<{ label: string; value: any }[]>
) => {
  onFieldReact(pattern, (field) => {
    field.loading = true
    service(field).then(
      action.bound((data) => {
        field.dataSource = data
        field.loading = false
      })
    )
  })
}

const form = createForm({
  effects: () => {
    useAsyncDataSource('select', async (field) => {
      const linkage = field.query('linkage').get('value')
      if (!linkage) return []
      return new Promise((resolve) => {
        setTimeout(() => {
          if (linkage === 1) {
            resolve([
              {
                label: 'AAA',
                value: 'aaa',
              },
              {
                label: 'BBB',
                value: 'ccc',
              },
            ])
          } else if (linkage === 2) {
            resolve([
              {
                label: 'CCC',
                value: 'ccc',
              },
              {
                label: 'DDD',
                value: 'ddd',
              },
            ])
          }
        }, 1500)
      })
    })
  },
})

export default () => (
  <FormProvider form={form}>
    <Field
      name="linkage"
      title="联动选择框"
      dataSource={[
        { label: '发请求1', value: 1 },
        { label: '发请求2', value: 2 },
      ]}
      decorator={[FormItem]}
      component={[
        Select,
        {
          style: {
            width: 120,
          },
        },
      ]}
    />
    <Field
      name="select"
      title="异步选择框"
      decorator={[FormItem]}
      component={[
        Select,
        {
          style: {
            width: 120,
          },
        },
      ]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

参考 https://ant.design/components/select-cn/
</file>

<file path="packages/antd/docs/components/SelectTable.md">
# SelectTable

> Optional table components

## Markup Schema single case

```tsx
import React from 'react'
import { FormItem, FormButtonGroup, Submit, SelectTable } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    SelectTable,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Object
          type="string"
          name="selectTable"
          x-decorator="FormItem"
          x-component="SelectTable"
          x-component-props={{
            bordered: false,
            mode: 'single',
          }}
          enum={[
            { key: '1', name: 'Title-1', description: 'description-1' },
            { key: '2', name: 'Title-2', description: 'description-2' },
          ]}
        >
          <SchemaField.Void
            name="name"
            title="Title"
            x-component="SelectTable.Column"
          />
          <SchemaField.Void
            name="description"
            title="Description"
            x-component="SelectTable.Column"
          />
        </SchemaField.Object>
      </SchemaField>
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup.FormItem>
    </FormProvider>
  )
}
```

## Markup Schema filter case

```tsx
import React from 'react'
import { FormItem, FormButtonGroup, Submit, SelectTable } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    SelectTable,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Array
          type="array"
          name="selectTable"
          x-decorator="FormItem"
          x-component="SelectTable"
          x-component-props={{
            bordered: false,
            showSearch: true,
            optionAsValue: true,
          }}
          enum={[
            { key: '1', name: 'Title-1', description: 'description-1' },
            { key: '2', name: 'Title-2', description: 'description-2' },
          ]}
        >
          <SchemaField.Object>
            <SchemaField.Void
              name="name"
              title="Title"
              x-component="SelectTable.Column"
            />
            <SchemaField.Void
              name="description"
              title="Description"
              x-component="SelectTable.Column"
            />
          </SchemaField.Object>
        </SchemaField.Array>
      </SchemaField>
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup.FormItem>
    </FormProvider>
  )
}
```

## Markup Schema async data source case

```tsx
import React from 'react'
import { FormItem, FormButtonGroup, Submit, SelectTable } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    SelectTable,
  },
})

const form = createForm()

export default () => {
  const onSearch = (value) => {
    const field = form.query('selectTable').take()
    field.loading = true
    setTimeout(() => {
      field.setState({
        dataSource: [
          {
            key: '3',
            name: 'AAA' + value,
            description: 'aaa',
          },
          {
            key: '4',
            name: 'BBB' + value,
            description: 'bbb',
          },
        ],
        loading: false,
      })
    }, 1500)
  }

  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Object
          type="object"
          name="selectTable"
          x-decorator="FormItem"
          x-component="SelectTable"
          x-component-props={{
            showSearch: true,
            filterOption: false,
            onSearch,
          }}
          enum={[
            { key: '1', name: 'title-1', description: 'description-1' },
            { key: '2', name: 'title-2', description: 'description-2' },
          ]}
        >
          <SchemaField.Void
            name="name"
            title="Title"
            x-component="SelectTable.Column"
          />
          <SchemaField.Void
            name="description"
            title="Description"
            x-component="SelectTable.Column"
          />
        </SchemaField.Object>
      </SchemaField>
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup.FormItem>
    </FormProvider>
  )
}
```

## Markup Schema read-pretty case

```tsx
import React from 'react'
import {
  Form,
  FormItem,
  FormButtonGroup,
  Submit,
  SelectTable,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    SelectTable,
  },
})

const form = createForm()

export default () => {
  return (
    <Form form={form} layout="vertical">
      <SchemaField>
        <SchemaField.Object
          title="single"
          type="string"
          name="selectTable1"
          x-decorator="FormItem"
          x-component="SelectTable"
          x-component-props={{
            mode: 'single',
          }}
          default="1"
          enum={[
            { key: '1', name: 'title-1', description: 'description-1' },
            { key: '2', name: 'Title-2', description: 'description-2' },
          ]}
          x-read-pretty={true}
        >
          <SchemaField.Void
            name="name"
            title="Title"
            x-component="SelectTable.Column"
          />
          <SchemaField.Void
            name="description"
            title="Description"
            x-component="SelectTable.Column"
          />
        </SchemaField.Object>
        <SchemaField.Object
          title="single + optionAsValue"
          type="string"
          name="selectTable2"
          x-decorator="FormItem"
          x-component="SelectTable"
          x-component-props={{
            mode: 'single',
            optionAsValue: true,
          }}
          default={{ key: '1', name: 'Title1', description: 'Description1' }}
          enum={[
            { key: '1', name: 'title-1', description: 'description-1' },
            { key: '2', name: 'Title-2', description: 'description-2' },
          ]}
          x-read-pretty={true}
        >
          <SchemaField.Void
            name="name"
            title="Title"
            x-component="SelectTable.Column"
          />
          <SchemaField.Void
            name="description"
            title="Description"
            x-component="SelectTable.Column"
          />
        </SchemaField.Object>
        <SchemaField.Array
          title="multiple"
          type="array"
          name="selectTable3"
          x-decorator="FormItem"
          x-component="SelectTable"
          default={['1', '3']}
          enum={[
            { key: '1', name: 'title-1', description: 'description-1' },
            { key: '2', name: 'Title-2', description: 'description-2' },
            { key: '3', name: 'title-3', description: 'description-3' },
          ]}
          x-read-pretty={true}
        >
          <SchemaField.Object>
            <SchemaField.Void
              name="name"
              title="Title"
              x-component="SelectTable.Column"
            />
            <SchemaField.Void
              name="description"
              title="Description"
              x-component="SelectTable.Column"
            />
          </SchemaField.Object>
        </SchemaField.Array>
        <SchemaField.Array
          title="multiple + optionAsValue"
          type="array"
          name="selectTable4"
          x-decorator="FormItem"
          x-component="SelectTable"
          x-component-props={{
            optionAsValue: true,
          }}
          default={[
            { key: '1', name: 'title-1', description: 'description-1' },
            { key: '3', name: 'title-3', description: 'description-3' },
          ]}
          enum={[
            { key: '1', name: 'title-1', description: 'description-1' },
            { key: '2', name: 'Title-2', description: 'description-2' },
            { key: '3', name: 'title-3', description: 'description-3' },
          ]}
          x-read-pretty={true}
        >
          <SchemaField.Object>
            <SchemaField.Void
              name="name"
              title="Title"
              x-component="SelectTable.Column"
            />
            <SchemaField.Void
              name="description"
              title="Description"
              x-component="SelectTable.Column"
            />
          </SchemaField.Object>
        </SchemaField.Array>
      </SchemaField>
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup.FormItem>
    </Form>
  )
}
```

## JSON Schema multiple case

```tsx
import React from 'react'
import { FormItem, FormButtonGroup, Submit, SelectTable } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    SelectTable,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    selectTable: {
      type: 'array',
      'x-decorator': 'FormItem',
      'x-component': 'SelectTable',
      'x-component-props': {
        bordered: false,
        mode: 'multiple',
      },
      enum: [
        { key: '1', name: 'Title-1', description: 'description-1' },
        { key: '2', name: 'Title-2', description: 'description-2' },
      ],
      properties: {
        name: {
          title: 'Title',
          type: 'string',
          'x-component': 'SelectTable.Column',
          'x-component-props': {
            width: '40%',
          },
        },
        description: {
          title: 'Description',
          type: 'string',
          'x-component': 'SelectTable.Column',
          'x-component-props': {
            width: '60%',
          },
        },
      },
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema custom filter case

```tsx
import React from 'react'
import { FormItem, FormButtonGroup, Submit, SelectTable } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    SelectTable,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    selectTable: {
      type: 'array',
      'x-decorator': 'FormItem',
      'x-component': 'SelectTable',
      'x-component-props': {
        bordered: false,
        showSearch: true,
        primaryKey: 'key',
        isTree: true,
        filterOption: (input, option) =>
          option.description.toLowerCase().indexOf(input.toLowerCase()) >= 0,
        filterSort: (optionA, optionB) =>
          optionA.description
            .toLowerCase()
            .localeCompare(optionB.description.toLowerCase()),
        optionAsValue: true,
        rowSelection: {
          checkStrictly: false,
        },
      },
      enum: [
        { key: '1', name: 'title-1', description: 'A-description' },
        {
          key: '2',
          name: 'title-2',
          description: 'X-description',
          children: [
            {
              key: '2-1',
              name: 'title2-1',
              description: 'Y-description',
              children: [
                {
                  key: '2-1-1',
                  name: 'title-2-1-1',
                  description: 'Z-description',
                },
              ],
            },
            {
              key: '2-2',
              name: 'title2-2',
              description: 'YY-description',
            },
          ],
        },
        { key: '3', name: 'title-3', description: 'C-description' },
      ],
      properties: {
        name: {
          title: 'Title',
          type: 'string',
          'x-component': 'SelectTable.Column',
          'x-component-props': {
            width: '40%',
          },
        },
        description: {
          title: 'Description',
          type: 'string',
          'x-component': 'SelectTable.Column',
          'x-component-props': {
            width: '60%',
          },
        },
      },
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema async data source case

```tsx
import React from 'react'
import { FormItem, FormButtonGroup, Submit, SelectTable } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    SelectTable,
    FormItem,
  },
})

const loadData = async (value) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([
        { key: '3', name: 'AAA' + value, description: 'aaa' },
        { key: '4', name: 'BBB' + value, description: 'bbb' },
      ])
    }, 1500)
  })
}

const useAsyncDataSource = (service, field) => (value) => {
  field.loading = true
  service(value).then((data) => {
    field.setState({
      dataSource: data,
      loading: false,
    })
  })
}

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    selectTable: {
      type: 'array',
      'x-decorator': 'FormItem',
      'x-component': 'SelectTable',
      'x-component-props': {
        showSearch: true,
        filterOption: false,
        onSearch: '{{useAsyncDataSource(loadData,$self)}}',
      },
      enum: [
        { key: '1', name: 'title-1', description: 'description-1' },
        { key: '2', name: 'title-2', description: 'description-2' },
      ],
      properties: {
        name: {
          title: 'Title',
          type: 'string',
          'x-component': 'SelectTable.Column',
          'x-component-props': {
            width: '40%',
          },
        },
        description: {
          title: 'Description',
          type: 'string',
          'x-component': 'SelectTable.Column',
          'x-component-props': {
            width: '60%',
          },
        },
      },
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} scope={{ useAsyncDataSource, loadData }} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## Pure JSX case

```tsx
import React from 'react'
import { FormItem, FormButtonGroup, Submit, SelectTable } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="SelectTable"
      dataSource={[
        { key: '1', name: 'title-1', description: 'description-1' },
        { key: '2', name: 'title-2', description: 'description-2' },
      ]}
      decorator={[FormItem]}
      component={[
        SelectTable,
        {
          columns: [
            { dataIndex: 'name', title: 'Title' },
            { dataIndex: 'description', title: 'Description' },
          ],
        },
      ]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

### SelectTable

| Property name | Type                                               | Description                                                                                                                                                                                                                                                 | Default value |
| ------------- | -------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------- |
| mode          | `'multiple' \| 'single'`                           | Set mode of SelectTable                                                                                                                                                                                                                                     | `'multiple'`  |
| valueType     | `'all' \| 'parent' \| 'child' \| 'path'`           | value type, Only applies when checkStrictly is set to `false`                                                                                                                                                                                               | `'all'`       |
| optionAsValue | boolean                                            | use `option` as value, Only applies when valueType is not set to `'path'`                                                                                                                                                                                   | false         |
| showSearch    | boolean                                            | show `Search` component                                                                                                                                                                                                                                     | false         |
| searchProps   | object                                             | `Search` component props                                                                                                                                                                                                                                    | -             |
| primaryKey    | `string \| (record) => string`                     | Row's unique key                                                                                                                                                                                                                                            | `'key'`       |
| filterOption  | `boolean \| (inputValue, option) => boolean`       | If true, filter options by input, if function, filter options against it. The function will receive two arguments, `inputValue` and `option`, if the function returns true, the option will be included in the filtered set; Otherwise, it will be excluded |
| filterSort    | (optionA, optionB) => number                       | Sort function for search options sorting, see Array.sort's compareFunction                                                                                                                                                                                  | -             |
| onSearch      | Callback function that is fired when input changed | (inputValue) => void                                                                                                                                                                                                                                        | -             |

`TableProps` type definition reference antd https://ant.design/components/table/

### rowSelection

| Property name | Type    | Description                                                                | Default value |
| ------------- | ------- | -------------------------------------------------------------------------- | ------------- |
| checkStrictly | boolean | Check table row precisely; parent row and children rows are not associated | true          |

`rowSelectionProps` type definition reference antd https://ant.design/components/table/#rowSelection

### SelectTable.Column

`ColumnProps` type definition reference antd https://ant.design/components/table/ Table.Column
</file>

<file path="packages/antd/docs/components/SelectTable.zh-CN.md">
# SelectTable

> 表格选择组件

## Markup Schema 单选案例

```tsx
import React from 'react'
import { FormItem, FormButtonGroup, Submit, SelectTable } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    SelectTable,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Object
          type="string"
          name="selectTable"
          x-decorator="FormItem"
          x-component="SelectTable"
          x-component-props={{
            bordered: false,
            mode: 'single',
          }}
          enum={[
            { key: '1', name: '标题1', description: '描述1' },
            { key: '2', name: '标题2', description: '描述2' },
          ]}
        >
          <SchemaField.Void
            name="name"
            title="标题"
            x-component="SelectTable.Column"
          />
          <SchemaField.Void
            name="description"
            title="描述"
            x-component="SelectTable.Column"
          />
        </SchemaField.Object>
      </SchemaField>
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup.FormItem>
    </FormProvider>
  )
}
```

## Markup Schema 筛选案例

```tsx
import React from 'react'
import { FormItem, FormButtonGroup, Submit, SelectTable } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    SelectTable,
  },
})

const form = createForm()

export default () => {
  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Array
          type="array"
          name="selectTable"
          x-decorator="FormItem"
          x-component="SelectTable"
          x-component-props={{
            bordered: false,
            showSearch: true,
            optionAsValue: true,
          }}
          enum={[
            { key: '1', name: '标题1', description: '描述1' },
            { key: '2', name: '标题2', description: '描述2' },
          ]}
        >
          <SchemaField.Object>
            <SchemaField.Void
              name="name"
              title="标题"
              x-component="SelectTable.Column"
            />
            <SchemaField.Void
              name="description"
              title="描述"
              x-component="SelectTable.Column"
            />
          </SchemaField.Object>
        </SchemaField.Array>
      </SchemaField>
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup.FormItem>
    </FormProvider>
  )
}
```

## Markup Schema 异步数据源案例

```tsx
import React from 'react'
import { FormItem, FormButtonGroup, Submit, SelectTable } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    SelectTable,
  },
})

const form = createForm()

export default () => {
  const onSearch = (value) => {
    const field = form.query('selectTable').take()
    field.loading = true
    setTimeout(() => {
      field.setState({
        dataSource: [
          {
            key: '3',
            name: 'AAA' + value,
            description: 'aaa',
          },
          {
            key: '4',
            name: 'BBB' + value,
            description: 'bbb',
          },
        ],
        loading: false,
      })
    }, 1500)
  }

  return (
    <FormProvider form={form}>
      <SchemaField>
        <SchemaField.Object
          type="object"
          name="selectTable"
          x-decorator="FormItem"
          x-component="SelectTable"
          x-component-props={{
            showSearch: true,
            filterOption: false,
            onSearch,
          }}
          enum={[
            { key: '1', name: '标题1', description: '描述1' },
            { key: '2', name: '标题2', description: '描述2' },
          ]}
        >
          <SchemaField.Void
            name="name"
            title="标题"
            x-component="SelectTable.Column"
          />
          <SchemaField.Void
            name="description"
            title="描述"
            x-component="SelectTable.Column"
          />
        </SchemaField.Object>
      </SchemaField>
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup.FormItem>
    </FormProvider>
  )
}
```

## Markup Schema 阅读态案例

```tsx
import React from 'react'
import {
  Form,
  FormItem,
  FormButtonGroup,
  Submit,
  SelectTable,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    FormItem,
    SelectTable,
  },
})

const form = createForm()

export default () => {
  return (
    <Form form={form} layout="vertical">
      <SchemaField>
        <SchemaField.Object
          title="单选"
          type="string"
          name="selectTable1"
          x-decorator="FormItem"
          x-component="SelectTable"
          x-component-props={{
            mode: 'single',
          }}
          default="1"
          enum={[
            { key: '1', name: '标题1', description: '描述1' },
            { key: '2', name: '标题2', description: '描述2' },
          ]}
          x-read-pretty={true}
        >
          <SchemaField.Void
            name="name"
            title="标题"
            x-component="SelectTable.Column"
          />
          <SchemaField.Void
            name="description"
            title="描述"
            x-component="SelectTable.Column"
          />
        </SchemaField.Object>
        <SchemaField.Object
          title="单选 + optionAsValue"
          type="string"
          name="selectTable2"
          x-decorator="FormItem"
          x-component="SelectTable"
          x-component-props={{
            mode: 'single',
            optionAsValue: true,
          }}
          default={{ key: '1', name: '标题1', description: '描述1' }}
          enum={[
            { key: '1', name: '标题1', description: '描述1' },
            { key: '2', name: '标题2', description: '描述2' },
          ]}
          x-read-pretty={true}
        >
          <SchemaField.Void
            name="name"
            title="标题"
            x-component="SelectTable.Column"
          />
          <SchemaField.Void
            name="description"
            title="描述"
            x-component="SelectTable.Column"
          />
        </SchemaField.Object>
        <SchemaField.Array
          title="多选"
          type="array"
          name="selectTable3"
          x-decorator="FormItem"
          x-component="SelectTable"
          default={['1', '3']}
          enum={[
            { key: '1', name: '标题1', description: '描述1' },
            { key: '2', name: '标题2', description: '描述2' },
            { key: '3', name: '标题3', description: '描述3' },
          ]}
          x-read-pretty={true}
        >
          <SchemaField.Object>
            <SchemaField.Void
              name="name"
              title="标题"
              x-component="SelectTable.Column"
            />
            <SchemaField.Void
              name="description"
              title="描述"
              x-component="SelectTable.Column"
            />
          </SchemaField.Object>
        </SchemaField.Array>
        <SchemaField.Array
          title="多选 + optionAsValue"
          type="array"
          name="selectTable4"
          x-decorator="FormItem"
          x-component="SelectTable"
          x-component-props={{
            optionAsValue: true,
          }}
          default={[
            { key: '1', name: '标题1', description: '描述1' },
            { key: '3', name: '标题3', description: '描述3' },
          ]}
          enum={[
            { key: '1', name: '标题1', description: '描述1' },
            { key: '2', name: '标题2', description: '描述2' },
            { key: '3', name: '标题3', description: '描述3' },
          ]}
          x-read-pretty={true}
        >
          <SchemaField.Object>
            <SchemaField.Void
              name="name"
              title="标题"
              x-component="SelectTable.Column"
            />
            <SchemaField.Void
              name="description"
              title="描述"
              x-component="SelectTable.Column"
            />
          </SchemaField.Object>
        </SchemaField.Array>
      </SchemaField>
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup.FormItem>
    </Form>
  )
}
```

## JSON Schema 多选案例

```tsx
import React from 'react'
import { FormItem, FormButtonGroup, Submit, SelectTable } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    SelectTable,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    selectTable: {
      type: 'array',
      'x-decorator': 'FormItem',
      'x-component': 'SelectTable',
      'x-component-props': {
        bordered: false,
        mode: 'multiple',
      },
      enum: [
        { key: '1', name: '标题1', description: '描述1' },
        { key: '2', name: '标题2', description: '描述2' },
      ],
      properties: {
        name: {
          title: '标题',
          type: 'string',
          'x-component': 'SelectTable.Column',
          'x-component-props': {
            width: '40%',
          },
        },
        description: {
          title: '描述',
          type: 'string',
          'x-component': 'SelectTable.Column',
          'x-component-props': {
            width: '60%',
          },
        },
      },
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema 自定义筛选案例

```tsx
import React from 'react'
import { FormItem, FormButtonGroup, Submit, SelectTable } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    SelectTable,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    selectTable: {
      type: 'array',
      'x-decorator': 'FormItem',
      'x-component': 'SelectTable',
      'x-component-props': {
        bordered: false,
        showSearch: true,
        primaryKey: 'key',
        isTree: true,
        filterOption: (input, option) =>
          option.description.toLowerCase().indexOf(input.toLowerCase()) >= 0,
        filterSort: (optionA, optionB) =>
          optionA.description
            .toLowerCase()
            .localeCompare(optionB.description.toLowerCase()),
        optionAsValue: true,
        rowSelection: {
          checkStrictly: false,
        },
      },
      enum: [
        { key: '1', name: '标题1', description: 'A-描述' },
        {
          key: '2',
          name: '标题2',
          description: 'X-描述',
          children: [
            {
              key: '2-1',
              name: '标题2-1',
              description: 'Y-描述',
              children: [
                { key: '2-1-1', name: '标题2-1-1', description: 'Z-描述' },
              ],
            },
            {
              key: '2-2',
              name: '标题2-2',
              description: 'YY-描述',
            },
          ],
        },
        { key: '3', name: '标题3', description: 'C-描述' },
      ],
      properties: {
        name: {
          title: '标题',
          type: 'string',
          'x-component': 'SelectTable.Column',
          'x-component-props': {
            width: '40%',
          },
        },
        description: {
          title: '描述',
          type: 'string',
          'x-component': 'SelectTable.Column',
          'x-component-props': {
            width: '60%',
          },
        },
      },
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema 异步数据源案例

```tsx
import React from 'react'
import { FormItem, FormButtonGroup, Submit, SelectTable } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    SelectTable,
    FormItem,
  },
})

const loadData = async (value) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve([
        { key: '3', name: 'AAA' + value, description: 'aaa' },
        { key: '4', name: 'BBB' + value, description: 'bbb' },
      ])
    }, 1500)
  })
}

const useAsyncDataSource = (service, field) => (value) => {
  field.loading = true
  service(value).then((data) => {
    field.setState({
      dataSource: data,
      loading: false,
    })
  })
}

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    selectTable: {
      type: 'array',
      'x-decorator': 'FormItem',
      'x-component': 'SelectTable',
      'x-component-props': {
        showSearch: true,
        filterOption: false,
        onSearch: '{{useAsyncDataSource(loadData,$self)}}',
      },
      enum: [
        { key: '1', name: '标题1', description: '描述1' },
        { key: '2', name: '标题2', description: '描述2' },
      ],
      properties: {
        name: {
          title: '标题',
          type: 'string',
          'x-component': 'SelectTable.Column',
          'x-component-props': {
            width: '40%',
          },
        },
        description: {
          title: '描述',
          type: 'string',
          'x-component': 'SelectTable.Column',
          'x-component-props': {
            width: '60%',
          },
        },
      },
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} scope={{ useAsyncDataSource, loadData }} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## 纯 JSX 案例

```tsx
import React from 'react'
import { FormItem, FormButtonGroup, Submit, SelectTable } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="SelectTable"
      dataSource={[
        { key: '1', name: '标题1', description: '描述1' },
        { key: '2', name: '标题2', description: '描述2' },
      ]}
      decorator={[FormItem]}
      component={[
        SelectTable,
        {
          columns: [
            { dataIndex: 'name', title: '标题' },
            { dataIndex: 'description', title: '描述' },
          ],
        },
      ]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

### SelectTable

| 属性名        | 类型                                         | 描述                                                                                                                                 | 默认值       |
| ------------- | -------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------ | ------------ |
| mode          | `'multiple' \| 'single'`                     | 设置 SelectTable 模式为单选或多选                                                                                                    | `'multiple'` |
| valueType     | `'all' \| 'parent' \| 'child' \| 'path'`     | 返回值类型，checkStrictly 设置为 `false` 时有效                                                                                      | `'all'`      |
| optionAsValue | boolean                                      | 使用表格行数据作为值，valueType 值为 `'path'` 时无效                                                                                 | false        |
| showSearch    | boolean                                      | 是否显示搜索组件                                                                                                                     | false        |
| searchProps   | object                                       | Search 组件属性                                                                                                                      | -            |
| primaryKey    | `string \| (record) => string`               | 表格行 key 的取值                                                                                                                    | `'key'`      |
| filterOption  | `boolean \| (inputValue, option) => boolean` | 是否根据输入项进行筛选。当其为一个函数时，会接收 inputValue option 两个参数，当 option 符合筛选条件时，应返回 true，反之则返回 false | true         |
| filterSort    | (optionA, optionB) => number                 | 搜索时对筛选结果项的排序函数, 类似 Array.sort 里的 compareFunction                                                                   | -            |
| onSearch      | 文本框值变化时回调                           | (inputValue) => void                                                                                                                 | -            |

参考 https://ant.design/components/table-cn/

### rowSelection

| 属性名        | 类型    | 描述                                                         | 默认值 |
| ------------- | ------- | ------------------------------------------------------------ | ------ |
| checkStrictly | boolean | checkable 状态下节点选择完全受控（父子数据选中状态不再关联） | true   |

参考 https://ant.design/components/table/#rowSelection

### SelectTable.Column

参考 https://ant.design/components/table-cn/ Table.Column 属性
</file>

<file path="packages/antd/docs/components/Space.md">
# Space

> Super convenient Flex layout component, can help users quickly realize the layout of any element side by side next to each other

## Markup Schema example

```tsx
import React from 'react'
import {
  Input,
  FormItem,
  FormLayout,
  FormButtonGroup,
  Submit,
  Space,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
    Space,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <FormLayout labelCol={6} wrapperCol={16}>
      <SchemaField>
        <SchemaField.Void
          title="name"
          x-decorator="FormItem"
          x-decorator-props={{
            asterisk: true,
            feedbackLayout: 'none',
          }}
          x-component="Space"
        >
          <SchemaField.String
            name="firstName"
            x-decorator="FormItem"
            x-component="Input"
            required
          />
          <SchemaField.String
            name="lastName"
            x-decorator="FormItem"
            x-component="Input"
            required
          />
        </SchemaField.Void>
        <SchemaField.Void
          title="Text concatenation"
          x-decorator="FormItem"
          x-decorator-props={{
            asterisk: true,
            feedbackLayout: 'none',
          }}
          x-component="Space"
        >
          <SchemaField.String
            name="aa"
            x-decorator="FormItem"
            x-component="Input"
            x-decorator-props={{
              addonAfter: 'Unit',
            }}
            required
          />
          <SchemaField.String
            name="bb"
            x-decorator="FormItem"
            x-component="Input"
            x-decorator-props={{
              addonAfter: 'Unit',
            }}
            required
          />
          <SchemaField.String
            name="cc"
            x-decorator="FormItem"
            x-component="Input"
            x-decorator-props={{
              addonAfter: 'Unit',
            }}
            required
          />
        </SchemaField.Void>
        <SchemaField.String
          name="textarea"
          title="text box"
          x-decorator="FormItem"
          required
          x-component="Input.TextArea"
          x-component-props={{
            style: {
              width: 400,
            },
          }}
        />
      </SchemaField>
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup.FormItem>
    </FormLayout>
  </FormProvider>
)
```

## JSON Schema case

```tsx
import React from 'react'
import {
  Input,
  FormItem,
  FormLayout,
  FormButtonGroup,
  Submit,
  Space,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
    Space,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    name: {
      type: 'void',
      title: 'Name',
      'x-decorator': 'FormItem',
      'x-decorator-props': {
        asterisk: true,
        feedbackLayout: 'none',
      },
      'x-component': 'Space',
      properties: {
        firstName: {
          type: 'string',
          'x-decorator': 'FormItem',
          'x-component': 'Input',
          required: true,
        },
        lastName: {
          type: 'string',
          'x-decorator': 'FormItem',
          'x-component': 'Input',
          required: true,
        },
      },
    },
    texts: {
      type: 'void',
      title: 'Text concatenation',
      'x-decorator': 'FormItem',
      'x-decorator-props': {
        asterisk: true,
        feedbackLayout: 'none',
      },
      'x-component': 'Space',
      properties: {
        aa: {
          type: 'string',
          'x-decorator': 'FormItem',
          'x-decorator-props': {
            addonAfter: 'Unit',
          },
          'x-component': 'Input',
          required: true,
        },
        bb: {
          type: 'string',
          'x-decorator': 'FormItem',
          'x-decorator-props': {
            addonAfter: 'Unit',
          },
          'x-component': 'Input',
          required: true,
        },
        cc: {
          type: 'string',
          'x-decorator': 'FormItem',
          'x-decorator-props': {
            addonAfter: 'Unit',
          },
          'x-component': 'Input',
          required: true,
        },
      },
    },

    textarea: {
      type: 'string',
      title: 'Text box',
      'x-decorator': 'FormItem',
      'x-component': 'Input.TextArea',
      'x-component-props': {
        style: {
          width: 400,
        },
      },
      required: true,
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <FormLayout labelCol={6} wrapperCol={16}>
      <SchemaField schema={schema} />
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup.FormItem>
    </FormLayout>
  </FormProvider>
)
```

## Pure JSX case

```tsx
import React from 'react'
import {
  Input,
  FormItem,
  FormLayout,
  FormButtonGroup,
  Submit,
  Space,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field, VoidField } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <FormLayout labelCol={6} wrapperCol={16}>
      <VoidField
        name="name"
        title="name"
        decorator={[
          FormItem,
          {
            asterisk: true,
            feedbackLayout: 'none',
          },
        ]}
        component={[Space]}
      >
        <Field
          name="firstName"
          decorator={[FormItem]}
          component={[Input]}
          required
        />
        <Field
          name="lastName"
          decorator={[FormItem]}
          component={[Input]}
          required
        />
      </VoidField>
      <VoidField
        name="texts"
        title="Text concatenation"
        decorator={[
          FormItem,
          {
            asterisk: true,
            feedbackLayout: 'none',
          },
        ]}
        component={[Space]}
      >
        <Field
          name="aa"
          decorator={[
            FormItem,
            {
              addonAfter: 'Unit',
            },
          ]}
          component={[Input]}
          required
        />
        <Field
          name="bb"
          decorator={[
            FormItem,
            {
              addonAfter: 'Unit',
            },
          ]}
          component={[Input]}
          required
        />
        <Field
          name="cc"
          decorator={[
            FormItem,
            {
              addonAfter: 'Unit',
            },
          ]}
          component={[Input]}
          required
        />
      </VoidField>
      <Field
        name="textarea"
        title="text box"
        decorator={[FormItem]}
        component={[
          Input.TextArea,
          {
            style: {
              width: 400,
            },
          },
        ]}
        required
      />
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup.FormItem>
    </FormLayout>
  </FormProvider>
)
```

## API

Reference https://ant.design/components/space-cn/
</file>

<file path="packages/antd/docs/components/Space.zh-CN.md">
# Space

> 超级便捷的 Flex 布局组件，可以帮助用户快速实现任何元素的并排紧挨布局

## Markup Schema 案例

```tsx
import React from 'react'
import {
  Input,
  FormItem,
  FormLayout,
  FormButtonGroup,
  Submit,
  Space,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
    Space,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <FormLayout labelCol={6} wrapperCol={16}>
      <SchemaField>
        <SchemaField.Void
          title="姓名"
          x-decorator="FormItem"
          x-decorator-props={{
            asterisk: true,
            feedbackLayout: 'none',
          }}
          x-component="Space"
        >
          <SchemaField.String
            name="firstName"
            x-decorator="FormItem"
            x-component="Input"
            required
          />
          <SchemaField.String
            name="lastName"
            x-decorator="FormItem"
            x-component="Input"
            required
          />
        </SchemaField.Void>
        <SchemaField.Void
          title="文本串联"
          x-decorator="FormItem"
          x-decorator-props={{
            asterisk: true,
            feedbackLayout: 'none',
          }}
          x-component="Space"
        >
          <SchemaField.String
            name="aa"
            x-decorator="FormItem"
            x-component="Input"
            x-decorator-props={{
              addonAfter: '单位',
            }}
            required
          />
          <SchemaField.String
            name="bb"
            x-decorator="FormItem"
            x-component="Input"
            x-decorator-props={{
              addonAfter: '单位',
            }}
            required
          />
          <SchemaField.String
            name="cc"
            x-decorator="FormItem"
            x-component="Input"
            x-decorator-props={{
              addonAfter: '单位',
            }}
            required
          />
        </SchemaField.Void>
        <SchemaField.String
          name="textarea"
          title="文本框"
          x-decorator="FormItem"
          required
          x-component="Input.TextArea"
          x-component-props={{
            style: {
              width: 400,
            },
          }}
        />
      </SchemaField>
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup.FormItem>
    </FormLayout>
  </FormProvider>
)
```

## JSON Schema 案例

```tsx
import React from 'react'
import {
  Input,
  FormItem,
  FormLayout,
  FormButtonGroup,
  Submit,
  Space,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
    Space,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    name: {
      type: 'void',
      title: '姓名',
      'x-decorator': 'FormItem',
      'x-decorator-props': {
        asterisk: true,
        feedbackLayout: 'none',
      },
      'x-component': 'Space',
      properties: {
        firstName: {
          type: 'string',
          'x-decorator': 'FormItem',
          'x-component': 'Input',
          required: true,
        },
        lastName: {
          type: 'string',
          'x-decorator': 'FormItem',
          'x-component': 'Input',
          required: true,
        },
      },
    },
    texts: {
      type: 'void',
      title: '文本串联',
      'x-decorator': 'FormItem',
      'x-decorator-props': {
        asterisk: true,
        feedbackLayout: 'none',
      },
      'x-component': 'Space',
      properties: {
        aa: {
          type: 'string',
          'x-decorator': 'FormItem',
          'x-decorator-props': {
            addonAfter: '单位',
          },
          'x-component': 'Input',
          required: true,
        },
        bb: {
          type: 'string',
          'x-decorator': 'FormItem',
          'x-decorator-props': {
            addonAfter: '单位',
          },
          'x-component': 'Input',
          required: true,
        },
        cc: {
          type: 'string',
          'x-decorator': 'FormItem',
          'x-decorator-props': {
            addonAfter: '单位',
          },
          'x-component': 'Input',
          required: true,
        },
      },
    },

    textarea: {
      type: 'string',
      title: '文本框',
      'x-decorator': 'FormItem',
      'x-component': 'Input.TextArea',
      'x-component-props': {
        style: {
          width: 400,
        },
      },
      required: true,
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <FormLayout labelCol={6} wrapperCol={16}>
      <SchemaField schema={schema} />
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup.FormItem>
    </FormLayout>
  </FormProvider>
)
```

## 纯 JSX 案例

```tsx
import React from 'react'
import {
  Input,
  FormItem,
  FormLayout,
  FormButtonGroup,
  Submit,
  Space,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field, VoidField } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <FormLayout labelCol={6} wrapperCol={16}>
      <VoidField
        name="name"
        title="姓名"
        decorator={[
          FormItem,
          {
            asterisk: true,
            feedbackLayout: 'none',
          },
        ]}
        component={[Space]}
      >
        <Field
          name="firstName"
          decorator={[FormItem]}
          component={[Input]}
          required
        />
        <Field
          name="lastName"
          decorator={[FormItem]}
          component={[Input]}
          required
        />
      </VoidField>
      <VoidField
        name="texts"
        title="文本串联"
        decorator={[
          FormItem,
          {
            asterisk: true,
            feedbackLayout: 'none',
          },
        ]}
        component={[Space]}
      >
        <Field
          name="aa"
          decorator={[
            FormItem,
            {
              addonAfter: '单位',
            },
          ]}
          component={[Input]}
          required
        />
        <Field
          name="bb"
          decorator={[
            FormItem,
            {
              addonAfter: '单位',
            },
          ]}
          component={[Input]}
          required
        />
        <Field
          name="cc"
          decorator={[
            FormItem,
            {
              addonAfter: '单位',
            },
          ]}
          component={[Input]}
          required
        />
      </VoidField>
      <Field
        name="textarea"
        title="文本框"
        decorator={[FormItem]}
        component={[
          Input.TextArea,
          {
            style: {
              width: 400,
            },
          },
        ]}
        required
      />
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup.FormItem>
    </FormLayout>
  </FormProvider>
)
```

## API

参考 https://ant.design/components/space-cn/
</file>

<file path="packages/antd/docs/components/Submit.md">
# Submit

> Submit button

## Ordinary submission

```tsx
import React from 'react'
import { Input, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="input"
        title="input box"
        required
        x-decorator="FormItem"
        x-component="Input"
      />
      <SchemaField.String
        name="input2"
        title="input box"
        default="123"
        required
        x-decorator="FormItem"
        x-component="Input"
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## Prevent Duplicate Submission (Loading)

```tsx
import React from 'react'
import { Input, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="input"
        title="input box"
        required
        x-decorator="FormItem"
        x-component="Input"
      />
      <SchemaField.String
        name="input2"
        title="input box"
        default="123"
        required
        x-decorator="FormItem"
        x-component="Input"
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit
        onSubmit={(values) => {
          return new Promise((resolve) => {
            setTimeout(() => {
              console.log(values)
              resolve()
            }, 2000)
          })
        }}
        onSubmitFailed={console.log}
      >
        submit
      </Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

For button-related API properties, we can refer to https://ant.design/components/button-cn/, and the rest are the unique API properties of the Submit component

| Property name   | Type                                                                                             | Description                                               | Default value |
| --------------- | ------------------------------------------------------------------------------------------------ | --------------------------------------------------------- | ------------- |
| onClick         | `(event: MouseEvent) => void \| boolean`                                                         | Click event, if it returns false, it can block submission | -             |
| onSubmit        | `(values: any) => Promise<any> \| any`                                                           | Submit event callback                                     | -             |
| onSubmitSuccess | (payload: any) => void                                                                           | Submit successful response event                          | -             |
| onSubmitFailed  | (feedbacks: [IFormFeedback](https://core.formilyjs.org/api/models/form#iformfeedback)[]) => void | Submit verification failure event callback                | -             |
</file>

<file path="packages/antd/docs/components/Submit.zh-CN.md">
# Submit

> 提交按钮

## 普通提交

```tsx
import React from 'react'
import { Input, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="input"
        title="输入框"
        required
        x-decorator="FormItem"
        x-component="Input"
      />
      <SchemaField.String
        name="input2"
        title="输入框"
        default="123"
        required
        x-decorator="FormItem"
        x-component="Input"
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## 防重复提交(Loading)

```tsx
import React from 'react'
import { Input, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Input,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="input"
        title="输入框"
        required
        x-decorator="FormItem"
        x-component="Input"
      />
      <SchemaField.String
        name="input2"
        title="输入框"
        default="123"
        required
        x-decorator="FormItem"
        x-component="Input"
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit
        onSubmit={(values) => {
          return new Promise((resolve) => {
            setTimeout(() => {
              console.log(values)
              resolve()
            }, 2000)
          })
        }}
        onSubmitFailed={console.log}
      >
        提交
      </Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

按钮相关的 API 属性，我们参考 https://ant.design/components/button-cn/ 即可，剩下是 Submit 组件独有的 API 属性

| 属性名          | 类型                                                                                                   | 描述                                  | 默认值 |
| --------------- | ------------------------------------------------------------------------------------------------------ | ------------------------------------- | ------ |
| onClick         | `(event: MouseEvent) => void \| boolean`                                                               | 点击事件，如果返回 false 可以阻塞提交 | -      |
| onSubmit        | `(values: any) => Promise<any> \| any`                                                                 | 提交事件回调                          | -      |
| onSubmitSuccess | (payload: any) => void                                                                                 | 提交成功响应事件                      | -      |
| onSubmitFailed  | (feedbacks: [IFormFeedback](https://core.formilyjs.org/zh-CN/api/models/form#iformfeedback)[]) => void | 提交校验失败事件回调                  | -      |
</file>

<file path="packages/antd/docs/components/Switch.md">
# Switch

> Switch Components

## Markup Schema example

```tsx
import React from 'react'
import { Switch, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Switch,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Boolean
        name="switch"
        title="Switch"
        x-decorator="FormItem"
        x-component="Switch"
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema case

```tsx
import React from 'react'
import { Switch, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Switch,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    switch: {
      type: 'boolean',
      title: 'Switch',
      'x-decorator': 'FormItem',
      'x-component': 'Switch',
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## Pure JSX case

```tsx
import React from 'react'
import { Switch, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="switch"
      title="Switch"
      decorator={[FormItem]}
      component={[Switch]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

Reference https://ant.design/components/switch-cn/
</file>

<file path="packages/antd/docs/components/Switch.zh-CN.md">
# Switch

> 开关组件

## Markup Schema 案例

```tsx
import React from 'react'
import { Switch, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Switch,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Boolean
        name="switch"
        title="开关"
        x-decorator="FormItem"
        x-component="Switch"
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema 案例

```tsx
import React from 'react'
import { Switch, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Switch,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    switch: {
      type: 'boolean',
      title: '开关',
      'x-decorator': 'FormItem',
      'x-component': 'Switch',
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## 纯 JSX 案例

```tsx
import React from 'react'
import { Switch, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="switch"
      title="开关"
      decorator={[FormItem]}
      component={[Switch]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

参考 https://ant.design/components/switch-cn/
</file>

<file path="packages/antd/docs/components/TimePicker.md">
# TimePicker

> Time Picker

## Markup Schema example

```tsx
import React from 'react'
import { TimePicker, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    TimePicker,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="time"
        title="time"
        required
        x-decorator="FormItem"
        x-component="TimePicker"
      />
      <SchemaField.String
        name="[startTime,endTime]"
        title="time range"
        x-decorator="FormItem"
        x-component="TimePicker.RangePicker"
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema case

```tsx
import React from 'react'
import { TimePicker, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    TimePicker,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    time: {
      title: 'Time',
      'x-decorator': 'FormItem',
      'x-component': 'TimePicker',
      type: 'string',
    },
    '[startTime,endTime]': {
      title: 'Time Range',
      'x-decorator': 'FormItem',
      'x-component': 'TimePicker.RangePicker',
      type: 'string',
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## Pure JSX case

```tsx
import React from 'react'
import { TimePicker, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="time"
      title="time"
      decorator={[FormItem]}
      component={[TimePicker]}
    />
    <Field
      name="[startTime,endTime]"
      title="time range"
      decorator={[FormItem]}
      component={[TimePicker.RangePicker]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

Reference https://ant.design/components/time-picker-cn/
</file>

<file path="packages/antd/docs/components/TimePicker.zh-CN.md">
# TimePicker

> 时间选择器

## Markup Schema 案例

```tsx
import React from 'react'
import { TimePicker, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    TimePicker,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        name="time"
        title="时间"
        required
        x-decorator="FormItem"
        x-component="TimePicker"
      />
      <SchemaField.String
        name="[startTime,endTime]"
        title="时间范围"
        x-decorator="FormItem"
        x-component="TimePicker.RangePicker"
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema 案例

```tsx
import React from 'react'
import { TimePicker, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    TimePicker,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    time: {
      title: '时间',
      'x-decorator': 'FormItem',
      'x-component': 'TimePicker',
      type: 'string',
    },
    '[startTime,endTime]': {
      title: '时间范围',
      'x-decorator': 'FormItem',
      'x-component': 'TimePicker.RangePicker',
      type: 'string',
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## 纯 JSX 案例

```tsx
import React from 'react'
import { TimePicker, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="time"
      title="时间"
      decorator={[FormItem]}
      component={[TimePicker]}
    />
    <Field
      name="[startTime,endTime]"
      title="时间范围"
      decorator={[FormItem]}
      component={[TimePicker.RangePicker]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

参考 https://ant.design/components/time-picker-cn/
</file>

<file path="packages/antd/docs/components/Transfer.md">
# Transfer

> Shuttle Box

## Markup Schema example

```tsx
import React from 'react'
import { Transfer, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Transfer,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Array
        name="transfer"
        title="shuttle box"
        x-decorator="FormItem"
        x-component="Transfer"
        enum={[
          { title: 'Option 1', key: 1 },
          { title: 'Option 2', key: 2 },
        ]}
        x-component-props={{
          render: (item) => item.title,
        }}
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema case

```tsx
import React from 'react'
import { Transfer, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Transfer,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    transfer: {
      type: 'array',
      title: 'shuttle box',
      'x-decorator': 'FormItem',
      'x-component': 'Transfer',
      enum: [
        { title: 'Option 1', key: 1 },
        { title: 'Option 2', key: 2 },
      ],
      'x-component-props': {
        render: '{{renderTitle}}',
      },
    },
  },
}

const renderTitle = (item) => item.title

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} scope={{ renderTitle }} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## Pure JSX case

```tsx
import React from 'react'
import { Transfer, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="transfer"
      title="shuttle box"
      dataSource={[
        { title: 'Option 1', key: 1 },
        { title: 'Option 2', key: 2 },
      ]}
      decorator={[FormItem]}
      component={[
        Transfer,
        {
          render: (item) => item.title,
        },
      ]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

Reference https://ant.design/components/transfer-cn/
</file>

<file path="packages/antd/docs/components/Transfer.zh-CN.md">
# Transfer

> 穿梭框

## Markup Schema 案例

```tsx
import React from 'react'
import { Transfer, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Transfer,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Array
        name="transfer"
        title="穿梭框"
        x-decorator="FormItem"
        x-component="Transfer"
        enum={[
          { title: '选项1', key: 1 },
          { title: '选项2', key: 2 },
        ]}
        x-component-props={{
          render: (item) => item.title,
        }}
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema 案例

```tsx
import React from 'react'
import { Transfer, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    Transfer,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    transfer: {
      type: 'array',
      title: '穿梭框',
      'x-decorator': 'FormItem',
      'x-component': 'Transfer',
      enum: [
        { title: '选项1', key: 1 },
        { title: '选项2', key: 2 },
      ],
      'x-component-props': {
        render: '{{renderTitle}}',
      },
    },
  },
}

const renderTitle = (item) => item.title

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} scope={{ renderTitle }} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## 纯 JSX 案例

```tsx
import React from 'react'
import { Transfer, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="transfer"
      title="穿梭框"
      dataSource={[
        { title: '选项1', key: 1 },
        { title: '选项2', key: 2 },
      ]}
      decorator={[FormItem]}
      component={[
        Transfer,
        {
          render: (item) => item.title,
        },
      ]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

参考 https://ant.design/components/transfer-cn/
</file>

<file path="packages/antd/docs/components/TreeSelect.md">
# TreeSelect

> Tree selector

## Markup Schema synchronization data source case

```tsx
import React from 'react'
import { TreeSelect, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    TreeSelect,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Number
        name="select"
        title="select box"
        x-decorator="FormItem"
        x-component="TreeSelect"
        enum={[
          {
            label: 'Option 1',
            value: 1,
            children: [
              {
                title: 'Child Node1',
                value: '0-0-0',
                key: '0-0-0',
              },
              {
                title: 'Child Node2',
                value: '0-0-1',
                key: '0-0-1',
              },
              {
                title: 'Child Node3',
                value: '0-0-2',
                key: '0-0-2',
              },
            ],
          },
          {
            label: 'Option 2',
            value: 2,
            children: [
              {
                title: 'Child Node3',
                value: '0-1-0',
                key: '0-1-0',
              },
              {
                title: 'Child Node4',
                value: '0-1-1',
                key: '0-1-1',
              },
              {
                title: 'Child Node5',
                value: '0-1-2',
                key: '0-1-2',
              },
            ],
          },
        ]}
        x-component-props={{
          style: {
            width: 200,
          },
        }}
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## Markup Schema Asynchronous Linkage Data Source Case

```tsx
import React from 'react'
import {
  TreeSelect,
  Select,
  FormItem,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm, onFieldReact, FormPathPattern, Field } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { action } from '@formily/reactive'

const SchemaField = createSchemaField({
  components: {
    Select,
    TreeSelect,
    FormItem,
  },
})

const useAsyncDataSource = (
  pattern: FormPathPattern,
  service: (field: Field) => Promise<{ label: string; value: any }[]>
) => {
  onFieldReact(pattern, (field) => {
    field.loading = true
    service(field).then(
      action.bound((data) => {
        field.dataSource = data
        field.loading = false
      })
    )
  })
}

const form = createForm({
  effects: () => {
    useAsyncDataSource('select', async (field) => {
      const linkage = field.query('linkage').get('value')
      if (!linkage) return []
      return new Promise((resolve) => {
        setTimeout(() => {
          if (linkage === 1) {
            resolve([
              {
                label: 'AAA',
                value: 'aaa',
                children: [
                  {
                    title: 'Child Node1',
                    value: '0-0-0',
                    key: '0-0-0',
                  },
                  {
                    title: 'Child Node2',
                    value: '0-0-1',
                    key: '0-0-1',
                  },
                  {
                    title: 'Child Node3',
                    value: '0-0-2',
                    key: '0-0-2',
                  },
                ],
              },
              {
                label: 'BBB',
                value: 'ccc',
                children: [
                  {
                    title: 'Child Node1',
                    value: '0-1-0',
                    key: '0-1-0',
                  },
                  {
                    title: 'Child Node2',
                    value: '0-1-1',
                    key: '0-1-1',
                  },
                  {
                    title: 'Child Node3',
                    value: '0-1-2',
                    key: '0-1-2',
                  },
                ],
              },
            ])
          } else if (linkage === 2) {
            resolve([
              {
                label: 'CCC',
                value: 'ccc',
                children: [
                  {
                    title: 'Child Node1',
                    value: '0-0-0',
                    key: '0-0-0',
                  },
                  {
                    title: 'Child Node2',
                    value: '0-0-1',
                    key: '0-0-1',
                  },
                  {
                    title: 'Child Node3',
                    value: '0-0-2',
                    key: '0-0-2',
                  },
                ],
              },
              {
                label: 'DDD',
                value: 'ddd',
                children: [
                  {
                    title: 'Child Node1',
                    value: '0-1-0',
                    key: '0-1-0',
                  },
                  {
                    title: 'Child Node2',
                    value: '0-1-1',
                    key: '0-1-1',
                  },
                  {
                    title: 'Child Node3',
                    value: '0-1-2',
                    key: '0-1-2',
                  },
                ],
              },
            ])
          }
        }, 1500)
      })
    })
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Number
        name="linkage"
        title="Linkage selection box"
        x-decorator="FormItem"
        x-component="Select"
        enum={[
          { label: 'Request 1', value: 1 },
          { label: 'Request 2', value: 2 },
        ]}
        x-component-props={{
          style: {
            width: 200,
          },
        }}
      />
      <SchemaField.String
        name="select"
        title="Asynchronous select box"
        x-decorator="FormItem"
        x-component="TreeSelect"
        x-component-props={{
          style: {
            width: 200,
          },
        }}
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema synchronization data source case

```tsx
import React from 'react'
import { TreeSelect, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    TreeSelect,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    select: {
      type: 'string',
      title: 'Select box',
      'x-decorator': 'FormItem',
      'x-component': 'TreeSelect',
      enum: [
        {
          label: 'Option 1',
          value: 1,
          children: [
            {
              title: 'Child Node1',
              value: '0-0-0',
              key: '0-0-0',
            },
            {
              title: 'Child Node2',
              value: '0-0-1',
              key: '0-0-1',
            },
            {
              title: 'Child Node3',
              value: '0-0-2',
              key: '0-0-2',
            },
          ],
        },
        {
          label: 'Option 2',
          value: 2,
          children: [
            {
              title: 'Child Node1',
              value: '0-1-0',
              key: '0-1-0',
            },
            {
              title: 'Child Node2',
              value: '0-1-1',
              key: '0-1-1',
            },
            {
              title: 'Child Node3',
              value: '0-1-2',
              key: '0-1-2',
            },
          ],
        },
      ],
      'x-component-props': {
        style: {
          width: 200,
        },
      },
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema asynchronous linkage data source case

```tsx
import React from 'react'
import {
  TreeSelect,
  Select,
  FormItem,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { action } from '@formily/reactive'

const SchemaField = createSchemaField({
  components: {
    Select,
    TreeSelect,
    FormItem,
  },
})

const loadData = async (field) => {
  const linkage = field.query('linkage').get('value')
  if (!linkage) return []
  return new Promise((resolve) => {
    setTimeout(() => {
      if (linkage === 1) {
        resolve([
          {
            label: 'AAA',
            value: 'aaa',
            children: [
              {
                title: 'Child Node1',
                value: '0-0-0',
                key: '0-0-0',
              },
              {
                title: 'Child Node2',
                value: '0-0-1',
                key: '0-0-1',
              },
              {
                title: 'Child Node3',
                value: '0-0-2',
                key: '0-0-2',
              },
            ],
          },
          {
            label: 'BBB',
            value: 'ccc',
            children: [
              {
                title: 'Child Node1',
                value: '0-1-0',
                key: '0-1-0',
              },
              {
                title: 'Child Node2',
                value: '0-1-1',
                key: '0-1-1',
              },
              {
                title: 'Child Node3',
                value: '0-1-2',
                key: '0-1-2',
              },
            ],
          },
        ])
      } else if (linkage === 2) {
        resolve([
          {
            label: 'CCC',
            value: 'ccc',
            children: [
              {
                title: 'Child Node1',
                value: '0-0-0',
                key: '0-0-0',
              },
              {
                title: 'Child Node2',
                value: '0-0-1',
                key: '0-0-1',
              },
              {
                title: 'Child Node3',
                value: '0-0-2',
                key: '0-0-2',
              },
            ],
          },
          {
            label: 'DDD',
            value: 'ddd',
            children: [
              {
                title: 'Child Node1',
                value: '0-1-0',
                key: '0-1-0',
              },
              {
                title: 'Child Node2',
                value: '0-1-1',
                key: '0-1-1',
              },
              {
                title: 'Child Node3',
                value: '0-1-2',
                key: '0-1-2',
              },
            ],
          },
        ])
      }
    }, 1500)
  })
}

const useAsyncDataSource = (service) => (field) => {
  field.loading = true
  service(field).then(
    action.bound((data) => {
      field.dataSource = data
      field.loading = false
    })
  )
}

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    linkage: {
      type: 'string',
      title: 'Linkage selection box',
      enum: [
        { label: 'Request 1', value: 1 },
        { label: 'Request 2', value: 2 },
      ],
      'x-decorator': 'FormItem',
      'x-component': 'Select',
      'x-component-props': {
        style: {
          width: 200,
        },
      },
    },
    select: {
      type: 'string',
      title: 'Asynchronous selection box',
      'x-decorator': 'FormItem',
      'x-component': 'TreeSelect',
      'x-component-props': {
        style: {
          width: 200,
        },
      },
      'x-reactions': ['{{useAsyncDataSource(loadData)}}'],
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} scope={{ useAsyncDataSource, loadData }} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## Pure JSX synchronization data source case

```tsx
import React from 'react'
import { TreeSelect, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="select"
      title="select box"
      dataSource={[
        {
          label: 'Option 1',
          value: 1,
          children: [
            {
              title: 'Child Node1',
              value: '0-0-0',
              key: '0-0-0',
            },
            {
              title: 'Child Node2',
              value: '0-0-1',
              key: '0-0-1',
            },
            {
              title: 'Child Node3',
              value: '0-0-2',
              key: '0-0-2',
            },
          ],
        },
        {
          label: 'Option 2',
          value: 2,
          children: [
            {
              title: 'Child Node3',
              value: '0-1-0',
              key: '0-1-0',
            },
            {
              title: 'Child Node4',
              value: '0-1-1',
              key: '0-1-1',
            },
            {
              title: 'Child Node5',
              value: '0-1-2',
              key: '0-1-2',
            },
          ],
        },
      ]}
      decorator={[FormItem]}
      component={[TreeSelect]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## Pure JSX asynchronous linkage data source case

```tsx
import React from 'react'
import {
  TreeSelect,
  Select,
  FormItem,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import {
  createForm,
  onFieldReact,
  FormPathPattern,
  Field as FieldType,
} from '@formily/core'
import { FormProvider, Field } from '@formily/react'
import { action } from '@formily/reactive'

const useAsyncDataSource = (
  pattern: FormPathPattern,
  service: (field: FieldType) => Promise<{ label: string; value: any }[]>
) => {
  onFieldReact(pattern, (field) => {
    field.loading = true
    service(field).then(
      action.bound((data) => {
        field.dataSource = data
        field.loading = false
      })
    )
  })
}

const form = createForm({
  effects: () => {
    useAsyncDataSource('select', async (field) => {
      const linkage = field.query('linkage').get('value')
      if (!linkage) return []
      return new Promise((resolve) => {
        setTimeout(() => {
          if (linkage === 1) {
            resolve([
              {
                label: 'AAA',
                value: 'aaa',
                children: [
                  {
                    title: 'Child Node1',
                    value: '0-0-0',
                    key: '0-0-0',
                  },
                  {
                    title: 'Child Node2',
                    value: '0-0-1',
                    key: '0-0-1',
                  },
                  {
                    title: 'Child Node3',
                    value: '0-0-2',
                    key: '0-0-2',
                  },
                ],
              },
              {
                label: 'BBB',
                value: 'ccc',
                children: [
                  {
                    title: 'Child Node1',
                    value: '0-1-0',
                    key: '0-1-0',
                  },
                  {
                    title: 'Child Node2',
                    value: '0-1-1',
                    key: '0-1-1',
                  },
                  {
                    title: 'Child Node3',
                    value: '0-1-2',
                    key: '0-1-2',
                  },
                ],
              },
            ])
          } else if (linkage === 2) {
            resolve([
              {
                label: 'CCC',
                value: 'ccc',
                children: [
                  {
                    title: 'Child Node1',
                    value: '0-0-0',
                    key: '0-0-0',
                  },
                  {
                    title: 'Child Node2',
                    value: '0-0-1',
                    key: '0-0-1',
                  },
                  {
                    title: 'Child Node3',
                    value: '0-0-2',
                    key: '0-0-2',
                  },
                ],
              },
              {
                label: 'DDD',
                value: 'ddd',
                children: [
                  {
                    title: 'Child Node1',
                    value: '0-1-0',
                    key: '0-1-0',
                  },
                  {
                    title: 'Child Node2',
                    value: '0-1-1',
                    key: '0-1-1',
                  },
                  {
                    title: 'Child Node3',
                    value: '0-1-2',
                    key: '0-1-2',
                  },
                ],
              },
            ])
          }
        }, 1500)
      })
    })
  },
})

export default () => (
  <FormProvider form={form}>
    <Field
      name="linkage"
      title="Linkage selection box"
      dataSource={[
        { label: 'Request 1', value: 1 },
        { label: 'Request 2', value: 2 },
      ]}
      decorator={[FormItem]}
      component={[
        Select,
        {
          style: {
            width: 200,
          },
        },
      ]}
    />
    <Field
      name="select"
      title="Asynchronous select box"
      decorator={[FormItem]}
      component={[
        TreeSelect,
        {
          style: {
            width: 200,
          },
        },
      ]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>Submit</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

Reference https://ant.design/components/tree-select-cn/
</file>

<file path="packages/antd/docs/components/TreeSelect.zh-CN.md">
# TreeSelect

> 树选择器

## Markup Schema 同步数据源案例

```tsx
import React from 'react'
import { TreeSelect, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    TreeSelect,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Number
        name="select"
        title="选择框"
        x-decorator="FormItem"
        x-component="TreeSelect"
        enum={[
          {
            label: '选项1',
            value: 1,
            children: [
              {
                title: 'Child Node1',
                value: '0-0-0',
                key: '0-0-0',
              },
              {
                title: 'Child Node2',
                value: '0-0-1',
                key: '0-0-1',
              },
              {
                title: 'Child Node3',
                value: '0-0-2',
                key: '0-0-2',
              },
            ],
          },
          {
            label: '选项2',
            value: 2,
            children: [
              {
                title: 'Child Node3',
                value: '0-1-0',
                key: '0-1-0',
              },
              {
                title: 'Child Node4',
                value: '0-1-1',
                key: '0-1-1',
              },
              {
                title: 'Child Node5',
                value: '0-1-2',
                key: '0-1-2',
              },
            ],
          },
        ]}
        x-component-props={{
          style: {
            width: 200,
          },
        }}
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## Markup Schema 异步联动数据源案例

```tsx
import React from 'react'
import {
  TreeSelect,
  Select,
  FormItem,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm, onFieldReact, FormPathPattern, Field } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { action } from '@formily/reactive'

const SchemaField = createSchemaField({
  components: {
    Select,
    TreeSelect,
    FormItem,
  },
})

const useAsyncDataSource = (
  pattern: FormPathPattern,
  service: (field: Field) => Promise<{ label: string; value: any }[]>
) => {
  onFieldReact(pattern, (field) => {
    field.loading = true
    service(field).then(
      action.bound((data) => {
        field.dataSource = data
        field.loading = false
      })
    )
  })
}

const form = createForm({
  effects: () => {
    useAsyncDataSource('select', async (field) => {
      const linkage = field.query('linkage').get('value')
      if (!linkage) return []
      return new Promise((resolve) => {
        setTimeout(() => {
          if (linkage === 1) {
            resolve([
              {
                label: 'AAA',
                value: 'aaa',
                children: [
                  {
                    title: 'Child Node1',
                    value: '0-0-0',
                    key: '0-0-0',
                  },
                  {
                    title: 'Child Node2',
                    value: '0-0-1',
                    key: '0-0-1',
                  },
                  {
                    title: 'Child Node3',
                    value: '0-0-2',
                    key: '0-0-2',
                  },
                ],
              },
              {
                label: 'BBB',
                value: 'ccc',
                children: [
                  {
                    title: 'Child Node1',
                    value: '0-1-0',
                    key: '0-1-0',
                  },
                  {
                    title: 'Child Node2',
                    value: '0-1-1',
                    key: '0-1-1',
                  },
                  {
                    title: 'Child Node3',
                    value: '0-1-2',
                    key: '0-1-2',
                  },
                ],
              },
            ])
          } else if (linkage === 2) {
            resolve([
              {
                label: 'CCC',
                value: 'ccc',
                children: [
                  {
                    title: 'Child Node1',
                    value: '0-0-0',
                    key: '0-0-0',
                  },
                  {
                    title: 'Child Node2',
                    value: '0-0-1',
                    key: '0-0-1',
                  },
                  {
                    title: 'Child Node3',
                    value: '0-0-2',
                    key: '0-0-2',
                  },
                ],
              },
              {
                label: 'DDD',
                value: 'ddd',
                children: [
                  {
                    title: 'Child Node1',
                    value: '0-1-0',
                    key: '0-1-0',
                  },
                  {
                    title: 'Child Node2',
                    value: '0-1-1',
                    key: '0-1-1',
                  },
                  {
                    title: 'Child Node3',
                    value: '0-1-2',
                    key: '0-1-2',
                  },
                ],
              },
            ])
          }
        }, 1500)
      })
    })
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Number
        name="linkage"
        title="联动选择框"
        x-decorator="FormItem"
        x-component="Select"
        enum={[
          { label: '发请求1', value: 1 },
          { label: '发请求2', value: 2 },
        ]}
        x-component-props={{
          style: {
            width: 200,
          },
        }}
      />
      <SchemaField.String
        name="select"
        title="异步选择框"
        x-decorator="FormItem"
        x-component="TreeSelect"
        x-component-props={{
          style: {
            width: 200,
          },
        }}
      />
    </SchemaField>
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema 同步数据源案例

```tsx
import React from 'react'
import { TreeSelect, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'

const SchemaField = createSchemaField({
  components: {
    TreeSelect,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    select: {
      type: 'string',
      title: '选择框',
      'x-decorator': 'FormItem',
      'x-component': 'TreeSelect',
      enum: [
        {
          label: '选项1',
          value: 1,
          children: [
            {
              title: 'Child Node1',
              value: '0-0-0',
              key: '0-0-0',
            },
            {
              title: 'Child Node2',
              value: '0-0-1',
              key: '0-0-1',
            },
            {
              title: 'Child Node3',
              value: '0-0-2',
              key: '0-0-2',
            },
          ],
        },
        {
          label: '选项2',
          value: 2,
          children: [
            {
              title: 'Child Node1',
              value: '0-1-0',
              key: '0-1-0',
            },
            {
              title: 'Child Node2',
              value: '0-1-1',
              key: '0-1-1',
            },
            {
              title: 'Child Node3',
              value: '0-1-2',
              key: '0-1-2',
            },
          ],
        },
      ],
      'x-component-props': {
        style: {
          width: 200,
        },
      },
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## JSON Schema 异步联动数据源案例

```tsx
import React from 'react'
import {
  TreeSelect,
  Select,
  FormItem,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { action } from '@formily/reactive'

const SchemaField = createSchemaField({
  components: {
    Select,
    TreeSelect,
    FormItem,
  },
})

const loadData = async (field) => {
  const linkage = field.query('linkage').get('value')
  if (!linkage) return []
  return new Promise((resolve) => {
    setTimeout(() => {
      if (linkage === 1) {
        resolve([
          {
            label: 'AAA',
            value: 'aaa',
            children: [
              {
                title: 'Child Node1',
                value: '0-0-0',
                key: '0-0-0',
              },
              {
                title: 'Child Node2',
                value: '0-0-1',
                key: '0-0-1',
              },
              {
                title: 'Child Node3',
                value: '0-0-2',
                key: '0-0-2',
              },
            ],
          },
          {
            label: 'BBB',
            value: 'ccc',
            children: [
              {
                title: 'Child Node1',
                value: '0-1-0',
                key: '0-1-0',
              },
              {
                title: 'Child Node2',
                value: '0-1-1',
                key: '0-1-1',
              },
              {
                title: 'Child Node3',
                value: '0-1-2',
                key: '0-1-2',
              },
            ],
          },
        ])
      } else if (linkage === 2) {
        resolve([
          {
            label: 'CCC',
            value: 'ccc',
            children: [
              {
                title: 'Child Node1',
                value: '0-0-0',
                key: '0-0-0',
              },
              {
                title: 'Child Node2',
                value: '0-0-1',
                key: '0-0-1',
              },
              {
                title: 'Child Node3',
                value: '0-0-2',
                key: '0-0-2',
              },
            ],
          },
          {
            label: 'DDD',
            value: 'ddd',
            children: [
              {
                title: 'Child Node1',
                value: '0-1-0',
                key: '0-1-0',
              },
              {
                title: 'Child Node2',
                value: '0-1-1',
                key: '0-1-1',
              },
              {
                title: 'Child Node3',
                value: '0-1-2',
                key: '0-1-2',
              },
            ],
          },
        ])
      }
    }, 1500)
  })
}

const useAsyncDataSource = (service) => (field) => {
  field.loading = true
  service(field).then(
    action.bound((data) => {
      field.dataSource = data
      field.loading = false
    })
  )
}

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    linkage: {
      type: 'string',
      title: '联动选择框',
      enum: [
        { label: '发请求1', value: 1 },
        { label: '发请求2', value: 2 },
      ],
      'x-decorator': 'FormItem',
      'x-component': 'Select',
      'x-component-props': {
        style: {
          width: 200,
        },
      },
    },
    select: {
      type: 'string',
      title: '异步选择框',
      'x-decorator': 'FormItem',
      'x-component': 'TreeSelect',
      'x-component-props': {
        style: {
          width: 200,
        },
      },
      'x-reactions': ['{{useAsyncDataSource(loadData)}}'],
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <SchemaField schema={schema} scope={{ useAsyncDataSource, loadData }} />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## 纯 JSX 同步数据源案例

```tsx
import React from 'react'
import { TreeSelect, FormItem, FormButtonGroup, Submit } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field
      name="select"
      title="选择框"
      dataSource={[
        {
          label: '选项1',
          value: 1,
          children: [
            {
              title: 'Child Node1',
              value: '0-0-0',
              key: '0-0-0',
            },
            {
              title: 'Child Node2',
              value: '0-0-1',
              key: '0-0-1',
            },
            {
              title: 'Child Node3',
              value: '0-0-2',
              key: '0-0-2',
            },
          ],
        },
        {
          label: '选项2',
          value: 2,
          children: [
            {
              title: 'Child Node3',
              value: '0-1-0',
              key: '0-1-0',
            },
            {
              title: 'Child Node4',
              value: '0-1-1',
              key: '0-1-1',
            },
            {
              title: 'Child Node5',
              value: '0-1-2',
              key: '0-1-2',
            },
          ],
        },
      ]}
      decorator={[FormItem]}
      component={[TreeSelect]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## 纯 JSX 异步联动数据源案例

```tsx
import React from 'react'
import {
  TreeSelect,
  Select,
  FormItem,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import {
  createForm,
  onFieldReact,
  FormPathPattern,
  Field as FieldType,
} from '@formily/core'
import { FormProvider, Field } from '@formily/react'
import { action } from '@formily/reactive'

const useAsyncDataSource = (
  pattern: FormPathPattern,
  service: (field: FieldType) => Promise<{ label: string; value: any }[]>
) => {
  onFieldReact(pattern, (field) => {
    field.loading = true
    service(field).then(
      action.bound((data) => {
        field.dataSource = data
        field.loading = false
      })
    )
  })
}

const form = createForm({
  effects: () => {
    useAsyncDataSource('select', async (field) => {
      const linkage = field.query('linkage').get('value')
      if (!linkage) return []
      return new Promise((resolve) => {
        setTimeout(() => {
          if (linkage === 1) {
            resolve([
              {
                label: 'AAA',
                value: 'aaa',
                children: [
                  {
                    title: 'Child Node1',
                    value: '0-0-0',
                    key: '0-0-0',
                  },
                  {
                    title: 'Child Node2',
                    value: '0-0-1',
                    key: '0-0-1',
                  },
                  {
                    title: 'Child Node3',
                    value: '0-0-2',
                    key: '0-0-2',
                  },
                ],
              },
              {
                label: 'BBB',
                value: 'ccc',
                children: [
                  {
                    title: 'Child Node1',
                    value: '0-1-0',
                    key: '0-1-0',
                  },
                  {
                    title: 'Child Node2',
                    value: '0-1-1',
                    key: '0-1-1',
                  },
                  {
                    title: 'Child Node3',
                    value: '0-1-2',
                    key: '0-1-2',
                  },
                ],
              },
            ])
          } else if (linkage === 2) {
            resolve([
              {
                label: 'CCC',
                value: 'ccc',
                children: [
                  {
                    title: 'Child Node1',
                    value: '0-0-0',
                    key: '0-0-0',
                  },
                  {
                    title: 'Child Node2',
                    value: '0-0-1',
                    key: '0-0-1',
                  },
                  {
                    title: 'Child Node3',
                    value: '0-0-2',
                    key: '0-0-2',
                  },
                ],
              },
              {
                label: 'DDD',
                value: 'ddd',
                children: [
                  {
                    title: 'Child Node1',
                    value: '0-1-0',
                    key: '0-1-0',
                  },
                  {
                    title: 'Child Node2',
                    value: '0-1-1',
                    key: '0-1-1',
                  },
                  {
                    title: 'Child Node3',
                    value: '0-1-2',
                    key: '0-1-2',
                  },
                ],
              },
            ])
          }
        }, 1500)
      })
    })
  },
})

export default () => (
  <FormProvider form={form}>
    <Field
      name="linkage"
      title="联动选择框"
      dataSource={[
        { label: '发请求1', value: 1 },
        { label: '发请求2', value: 2 },
      ]}
      decorator={[FormItem]}
      component={[
        Select,
        {
          style: {
            width: 200,
          },
        },
      ]}
    />
    <Field
      name="select"
      title="异步选择框"
      decorator={[FormItem]}
      component={[
        TreeSelect,
        {
          style: {
            width: 200,
          },
        },
      ]}
    />
    <FormButtonGroup>
      <Submit onSubmit={console.log}>提交</Submit>
    </FormButtonGroup>
  </FormProvider>
)
```

## API

参考 https://ant.design/components/tree-select-cn/
</file>

<file path="packages/antd/docs/components/Upload.md">
# Upload

> Upload components
>
> Note: Using the upload component, it is recommended that users perform secondary packaging. Users do not need to care about the data communication between the upload component and Formily, only the style and basic upload configuration are required.

## Markup Schema example

```tsx
import React from 'react'
import {
  Upload,
  FormItem,
  FormLayout,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Button } from 'antd'
import { UploadOutlined, InboxOutlined } from '@ant-design/icons'

const NormalUpload = (props) => {
  return (
    <Upload
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
      headers={{
        authorization: 'authorization-text',
      }}
    >
      <Button icon={<UploadOutlined />}>Upload files</Button>
    </Upload>
  )
}

const CardUpload = (props) => {
  return (
    <Upload
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
      listType="picture-card"
      headers={{
        authorization: 'authorization-text',
      }}
    >
      <UploadOutlined style={{ fontSize: 20 }} />
    </Upload>
  )
}

const DraggerUpload = (props) => {
  return (
    <Upload.Dragger
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
    >
      <p className="ant-upload-drag-icon">
        <InboxOutlined />
      </p>
      <p className="ant-upload-text">
        Click or drag file to this area to upload
      </p>
      <p className="ant-upload-hint">
        Support for a single or bulk upload. Strictly prohibit from uploading
        company data or other band files
      </p>
    </Upload.Dragger>
  )
}

const SchemaField = createSchemaField({
  components: {
    NormalUpload,
    CardUpload,
    DraggerUpload,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <FormLayout labelCol={6} wrapperCol={10}>
      <SchemaField>
        <SchemaField.Array
          name="upload"
          title="Upload"
          x-decorator="FormItem"
          x-component="NormalUpload"
          required
        />
        <SchemaField.Array
          name="upload2"
          title="Card upload"
          x-decorator="FormItem"
          x-component="CardUpload"
          required
        />
        <SchemaField.Array
          name="upload3"
          title="Drag and drop upload"
          x-decorator="FormItem"
          x-component="DraggerUpload"
          required
        />
      </SchemaField>
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup.FormItem>
    </FormLayout>
  </FormProvider>
)
```

## JSON Schema case

```tsx
import React from 'react'
import {
  Upload,
  FormItem,
  FormLayout,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Button } from 'antd'
import { UploadOutlined, InboxOutlined } from '@ant-design/icons'

const NormalUpload = (props) => {
  return (
    <Upload
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
      headers={{
        authorization: 'authorization-text',
      }}
    >
      <Button icon={<UploadOutlined />}>Upload files</Button>
    </Upload>
  )
}

const CardUpload = (props) => {
  return (
    <Upload
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
      listType="picture-card"
      headers={{
        authorization: 'authorization-text',
      }}
    >
      <UploadOutlined style={{ fontSize: 20 }} />
    </Upload>
  )
}

const DraggerUpload = (props) => {
  return (
    <Upload.Dragger
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
    >
      <p className="ant-upload-drag-icon">
        <InboxOutlined />
      </p>
      <p className="ant-upload-text">
        Click or drag file to this area to upload
      </p>
      <p className="ant-upload-hint">
        Support for a single or bulk upload. Strictly prohibit from uploading
        company data or other band files
      </p>
    </Upload.Dragger>
  )
}

const SchemaField = createSchemaField({
  components: {
    NormalUpload,
    CardUpload,
    DraggerUpload,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    upload: {
      type: 'array',
      title: 'Upload',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'NormalUpload',
    },
    upload2: {
      type: 'array',
      title: 'Card upload',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'CardUpload',
    },
    upload3: {
      type: 'array',
      title: 'Drag and drop upload',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'DraggerUpload',
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <FormLayout labelCol={6} wrapperCol={10}>
      <SchemaField schema={schema} />
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup.FormItem>
    </FormLayout>
  </FormProvider>
)
```

## Pure JSX case

```tsx
import React from 'react'
import {
  Upload,
  FormItem,
  FormLayout,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'
import { Button } from 'antd'
import { UploadOutlined, InboxOutlined } from '@ant-design/icons'

const NormalUpload = (props) => {
  return (
    <Upload
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
      headers={{
        authorization: 'authorization-text',
      }}
    >
      <Button icon={<UploadOutlined />}>Upload files</Button>
    </Upload>
  )
}

const CardUpload = (props) => {
  return (
    <Upload
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
      listType="picture-card"
      headers={{
        authorization: 'authorization-text',
      }}
    >
      <UploadOutlined style={{ fontSize: 20 }} />
    </Upload>
  )
}

const DraggerUpload = (props) => {
  return (
    <Upload.Dragger
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
    >
      <p className="ant-upload-drag-icon">
        <InboxOutlined />
      </p>
      <p className="ant-upload-text">
        Click or drag file to this area to upload
      </p>
      <p className="ant-upload-hint">
        Support for a single or bulk upload. Strictly prohibit from uploading
        company data or other band files
      </p>
    </Upload.Dragger>
  )
}

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <FormLayout labelCol={6} wrapperCol={10}>
      <Field
        name="upload"
        title="Upload"
        required
        decorator={[FormItem]}
        component={[NormalUpload]}
      />
      <Field
        name="upload2"
        title="Card upload"
        required
        decorator={[FormItem]}
        component={[CardUpload]}
      />
      <Field
        name="upload3"
        title="Drag and drop upload"
        required
        decorator={[FormItem]}
        component={[DraggerUpload]}
      />
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>Submit</Submit>
      </FormButtonGroup.FormItem>
    </FormLayout>
  </FormProvider>
)
```

## API

Reference https://ant.design/components/upload-cn/
</file>

<file path="packages/antd/docs/components/Upload.zh-CN.md">
# Upload

> 上传组件
>
> 注意：使用上传组件，推荐用户进行二次封装，用户无需关心上传组件与 Formily 的数据通信，只需要处理样式与基本上传配置即可。

## Markup Schema 案例

```tsx
import React from 'react'
import {
  Upload,
  FormItem,
  FormLayout,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Button } from 'antd'
import { UploadOutlined, InboxOutlined } from '@ant-design/icons'

const NormalUpload = (props) => {
  return (
    <Upload
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
      headers={{
        authorization: 'authorization-text',
      }}
    >
      <Button icon={<UploadOutlined />}>上传文件</Button>
    </Upload>
  )
}

const CardUpload = (props) => {
  return (
    <Upload
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
      listType="picture-card"
      headers={{
        authorization: 'authorization-text',
      }}
    >
      <UploadOutlined style={{ fontSize: 20 }} />
    </Upload>
  )
}

const DraggerUpload = (props) => {
  return (
    <Upload.Dragger
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
    >
      <p className="ant-upload-drag-icon">
        <InboxOutlined />
      </p>
      <p className="ant-upload-text">
        Click or drag file to this area to upload
      </p>
      <p className="ant-upload-hint">
        Support for a single or bulk upload. Strictly prohibit from uploading
        company data or other band files
      </p>
    </Upload.Dragger>
  )
}

const SchemaField = createSchemaField({
  components: {
    NormalUpload,
    CardUpload,
    DraggerUpload,
    FormItem,
  },
})

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <FormLayout labelCol={6} wrapperCol={10}>
      <SchemaField>
        <SchemaField.Array
          name="upload"
          title="上传"
          x-decorator="FormItem"
          x-component="NormalUpload"
          required
        />
        <SchemaField.Array
          name="upload2"
          title="卡片上传"
          x-decorator="FormItem"
          x-component="CardUpload"
          required
        />
        <SchemaField.Array
          name="upload3"
          title="拖拽上传"
          x-decorator="FormItem"
          x-component="DraggerUpload"
          required
        />
      </SchemaField>
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup.FormItem>
    </FormLayout>
  </FormProvider>
)
```

## JSON Schema 案例

```tsx
import React from 'react'
import {
  Upload,
  FormItem,
  FormLayout,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Button } from 'antd'
import { UploadOutlined, InboxOutlined } from '@ant-design/icons'

const NormalUpload = (props) => {
  return (
    <Upload
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
      headers={{
        authorization: 'authorization-text',
      }}
    >
      <Button icon={<UploadOutlined />}>上传文件</Button>
    </Upload>
  )
}

const CardUpload = (props) => {
  return (
    <Upload
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
      listType="picture-card"
      headers={{
        authorization: 'authorization-text',
      }}
    >
      <UploadOutlined style={{ fontSize: 20 }} />
    </Upload>
  )
}

const DraggerUpload = (props) => {
  return (
    <Upload.Dragger
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
    >
      <p className="ant-upload-drag-icon">
        <InboxOutlined />
      </p>
      <p className="ant-upload-text">
        Click or drag file to this area to upload
      </p>
      <p className="ant-upload-hint">
        Support for a single or bulk upload. Strictly prohibit from uploading
        company data or other band files
      </p>
    </Upload.Dragger>
  )
}

const SchemaField = createSchemaField({
  components: {
    NormalUpload,
    CardUpload,
    DraggerUpload,
    FormItem,
  },
})

const form = createForm()

const schema = {
  type: 'object',
  properties: {
    upload: {
      type: 'array',
      title: '上传',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'NormalUpload',
    },
    upload2: {
      type: 'array',
      title: '卡片上传',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'CardUpload',
    },
    upload3: {
      type: 'array',
      title: '拖拽上传',
      required: true,
      'x-decorator': 'FormItem',
      'x-component': 'DraggerUpload',
    },
  },
}

export default () => (
  <FormProvider form={form}>
    <FormLayout labelCol={6} wrapperCol={10}>
      <SchemaField schema={schema} />
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup.FormItem>
    </FormLayout>
  </FormProvider>
)
```

## 纯 JSX 案例

```tsx
import React from 'react'
import {
  Upload,
  FormItem,
  FormLayout,
  FormButtonGroup,
  Submit,
} from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'
import { Button } from 'antd'
import { UploadOutlined, InboxOutlined } from '@ant-design/icons'

const NormalUpload = (props) => {
  return (
    <Upload
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
      headers={{
        authorization: 'authorization-text',
      }}
    >
      <Button icon={<UploadOutlined />}>上传文件</Button>
    </Upload>
  )
}

const CardUpload = (props) => {
  return (
    <Upload
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
      listType="picture-card"
      headers={{
        authorization: 'authorization-text',
      }}
    >
      <UploadOutlined style={{ fontSize: 20 }} />
    </Upload>
  )
}

const DraggerUpload = (props) => {
  return (
    <Upload.Dragger
      {...props}
      action="https://www.mocky.io/v2/5cc8019d300000980a055e76"
    >
      <p className="ant-upload-drag-icon">
        <InboxOutlined />
      </p>
      <p className="ant-upload-text">
        Click or drag file to this area to upload
      </p>
      <p className="ant-upload-hint">
        Support for a single or bulk upload. Strictly prohibit from uploading
        company data or other band files
      </p>
    </Upload.Dragger>
  )
}

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <FormLayout labelCol={6} wrapperCol={10}>
      <Field
        name="upload"
        title="上传"
        required
        decorator={[FormItem]}
        component={[NormalUpload]}
      />
      <Field
        name="upload2"
        title="卡片上传"
        required
        decorator={[FormItem]}
        component={[CardUpload]}
      />
      <Field
        name="upload3"
        title="拖拽上传"
        required
        decorator={[FormItem]}
        component={[DraggerUpload]}
      />
      <FormButtonGroup.FormItem>
        <Submit onSubmit={console.log}>提交</Submit>
      </FormButtonGroup.FormItem>
    </FormLayout>
  </FormProvider>
)
```

## API

参考 https://ant.design/components/upload-cn/
</file>

<file path="packages/antd/docs/index.md">
---
title: Formily-Alibaba unified front-end form solution
order: 10
hero:
  title: Formily Antd
  desc: Formily Component System Based on Ant Design Encapsulation
  actions:
    - text: Home Site
      link: //formilyjs.org
    - text: Document
      link: /components
features:
  - icon: https://img.alicdn.com/imgextra/i2/O1CN016i72sH1c5wh1kyy9U_!!6000000003550-55-tps-800-800.svg
    title: Easier To Use
    desc: Out of the box, rich cases
  - icon: https://img.alicdn.com/imgextra/i1/O1CN01bHdrZJ1rEOESvXEi5_!!6000000005599-55-tps-800-800.svg
    title: More Efficient
    desc: Stupid writing, super high performance
  - icon: https://img.alicdn.com/imgextra/i3/O1CN01xlETZk1G0WSQT6Xii_!!6000000000560-55-tps-800-800.svg
    title: More Professional
    desc: complete, flexible, elegant
footer: Open-source MIT Licensed | Copyright © 2019-present<br />Powered by self
---

## Installation

```bash
$ npm install --save antd moment
$ npm install --save @formily/core @formily/react @formily/antd

```

## Quick start

```tsx
/**
 * defaultShowCode: true
 */
import React from 'react'
import { NumberPicker, FormItem, Space } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, FormConsumer, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Space>
      <Field
        name="price"
        title="price"
        initialValue={5.2}
        decorator={[FormItem]}
        component={[
          NumberPicker,
          {
            placeholder: 'Please enter',
            style: {
              width: 100,
            },
          },
        ]}
      />
      <FormItem>×</FormItem>
      <Field
        name="count"
        title="quantity"
        initialValue={100}
        decorator={[FormItem]}
        component={[
          NumberPicker,
          {
            placeholder: 'Please enter',
            style: {
              width: 100,
            },
          },
        ]}
      />
      <FormConsumer>
        {(form) => (
          <FormItem>={` ${form.values.price * form.values.count}元`}</FormItem>
        )}
      </FormConsumer>
    </Space>
  </FormProvider>
)
```
</file>

<file path="packages/antd/docs/index.zh-CN.md">
---
title: Formily - 阿里巴巴统一前端表单解决方案
order: 10
hero:
  title: Formily Antd
  desc: 基于Ant Design封装的优雅且易用的Formily2.x组件体系
  actions:
    - text: 主站文档
      link: //formilyjs.org
    - text: 组件文档
      link: /zh-CN/components
features:
  - icon: https://img.alicdn.com/imgextra/i2/O1CN016i72sH1c5wh1kyy9U_!!6000000003550-55-tps-800-800.svg
    title: 更易用
    desc: 开箱即用，案例丰富
  - icon: https://img.alicdn.com/imgextra/i1/O1CN01bHdrZJ1rEOESvXEi5_!!6000000005599-55-tps-800-800.svg
    title: 更高效
    desc: 傻瓜写法，超高性能
  - icon: https://img.alicdn.com/imgextra/i3/O1CN01xlETZk1G0WSQT6Xii_!!6000000000560-55-tps-800-800.svg
    title: 更专业
    desc: 完备，灵活，优雅
footer: Open-source MIT Licensed | Copyright © 2019-present<br />Powered by self
---

## 安装

```bash
$ npm install --save antd moment
$ npm install --save @formily/core @formily/react @formily/antd

```

## 快速开始

```tsx
/**
 * defaultShowCode: true
 */
import React from 'react'
import { NumberPicker, FormItem, Space } from '@formily/antd'
import { createForm } from '@formily/core'
import { FormProvider, FormConsumer, Field } from '@formily/react'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Space>
      <Field
        name="price"
        title="价格"
        initialValue={5.2}
        decorator={[FormItem]}
        component={[
          NumberPicker,
          {
            placeholder: '请输入',
            style: {
              width: 100,
            },
          },
        ]}
      />
      <FormItem>×</FormItem>
      <Field
        name="count"
        title="数量"
        initialValue={100}
        decorator={[FormItem]}
        component={[
          NumberPicker,
          {
            placeholder: '请输入',
            style: {
              width: 100,
            },
          },
        ]}
      />
      <FormConsumer>
        {(form) => (
          <FormItem>={` ${form.values.price * form.values.count} 元`}</FormItem>
        )}
      </FormConsumer>
    </Space>
  </FormProvider>
)
```
</file>

<file path="packages/core/docs/api/entry/createForm.md">
---
order: 0
---

# createForm

## Description

Create a Form instance as a ViewModel for consumption by the UI framework layer

## Signature

```ts
interface createForm {
  (props: IFormProps): Form
}
```

## IFormProps

| Property      | Description                                                | Type                                                     | Default Value |
| ------------- | ---------------------------------------------------------- | -------------------------------------------------------- | ------------- |
| values        | form values                                                | Object                                                   | `{}`          |
| initialValues | Form default values                                        | Object                                                   | `{}`          |
| pattern       | Form interaction mode                                      | `"editable" \| "disabled" \| "readOnly" \| "readPretty"` | `"editable"`  |
| display       | The form is visible and hidden                             | `"visible" \| "hidden" \| "none"`                        | `"visible`    |
| hidden        | UI hidden                                                  | Boolean                                                  | `false`       |
| visible       | show/hide (data hiding)                                    | Boolean                                                  | `true`        |
| editable      | Editable                                                   | Boolean                                                  | `true`        |
| disabled      | Whether to disable                                         | Boolean                                                  | `false`       |
| readOnly      | Is it read-only                                            | Boolean                                                  | `false`       |
| readPretty    | Is it an elegant reading state                             | Boolean                                                  | `false`       |
| effects       | Side effect logic, used to implement various linkage logic | `(form:Form)=>void`                                      |               |
| validateFirst | Whether to validate only the first illegal rule            | Boolean                                                  | `false`       |

## Example

```ts
import { createForm } from '@formily/core'

const form = createForm({
  initialValues: {
    say: 'hello',
  },
})
```
</file>

<file path="packages/core/docs/api/entry/createForm.zh-CN.md">
---
order: 0
---

# createForm

## 描述

创建一个 Form 实例，作为 ViewModel 给 UI 框架层消费

## 签名

```ts
interface createForm {
  (props: IFormProps): Form
}
```

## IFormProps

| 属性          | 描述                             | 类型                                                     | 默认值       |
| ------------- | -------------------------------- | -------------------------------------------------------- | ------------ |
| values        | 表单值                           | Object                                                   | `{}`         |
| initialValues | 表单默认值                       | Object                                                   | `{}`         |
| pattern       | 表单交互模式                     | `"editable" \| "disabled" \| "readOnly" \| "readPretty"` | `"editable"` |
| display       | 表单显隐                         | `"visible" \| "hidden" \| "none"`                        | `"visible`   |
| hidden        | UI 隐藏                          | Boolean                                                  | `false`      |
| visible       | 显示/隐藏(数据隐藏)              | Boolean                                                  | `true`       |
| editable      | 是否可编辑                       | Boolean                                                  | `true`       |
| disabled      | 是否禁用                         | Boolean                                                  | `false`      |
| readOnly      | 是否只读                         | Boolean                                                  | `false`      |
| readPretty    | 是否是优雅阅读态                 | Boolean                                                  | `false`      |
| effects       | 副作用逻辑，用于实现各种联动逻辑 | `(form:Form)=>void`                                      |              |
| validateFirst | 是否只校验第一个非法规则         | Boolean                                                  | `false`      |

## 用例

```ts
import { createForm } from '@formily/core'

const form = createForm({
  initialValues: {
    say: 'hello',
  },
})
```
</file>

<file path="packages/core/docs/api/entry/FieldEffectHooks.md">
---
order: 2
---

# Field Effect Hooks

## onFieldInit

#### Description

Used to monitor the side effect hook of a field initialization, we will trigger the field initialization event when we call createField

#### Signature

```ts
interface onFieldInit {
  (pattern: FormPathPattern, callback: (field: Field, form: Form) => void)
}
```

<Alert>
  For the syntax format of FormPathPattern, please refer to <a href="/api/entry/form-path">FormPath</a>
</Alert>

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFieldInit } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFieldInit('target', () => {
            setResponse('target has been initialized')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.createField({ name: 'target' })
        }}
      >
        Create field
      </button>
    </ActionResponse>
  )
}
```

## onFieldMount

#### Description

Used to monitor the side-effect hook of a field that has been mounted, we will trigger the field mount event when we call onMount

#### Signature

```ts
interface onFieldMount {
  (pattern: FormPathPattern, callback: (field: Field, form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFieldMount } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFieldMount('target', () => {
            setResponse('target is mounted')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.createField({ name: 'target' }).onMount()
        }}
      >
        Create and mount fields
      </button>
    </ActionResponse>
  )
}
```

## onFieldUnmount

#### Description

It is used to monitor the side effect hook that a field has been unloaded. When we call onUnmount, the unmount event will be triggered

#### Signature

```ts
interface onFieldUnmount {
  (pattern: FormPathPattern, callback: (field: Field, form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFieldMount, onFieldUnmount } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFieldMount('target', () => {
            setResponse('target is mounted')
          })
          onFieldUnmount('target', () => {
            setResponse('target has been uninstalled')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.createField({ name: 'target' }).onMount()
        }}
      >
        Create and mount fields
      </button>
      <button
        onClick={() => {
          form.createField({ name: 'target' }).onUnmount()
        }}
      >
        Unload field
      </button>
    </ActionResponse>
  )
}
```

## onFieldReact

A side-effect hook used to implement field reactive logic. Its core principle is that the callback function will be executed when the field is initialized, and the dependency will be automatically tracked at the same time. The callback function will be executed repeatedly when the dependent data changes.

#### Signature

```ts
interface onFieldReact {
  (pattern: FormPathPattern, callback: (field: Field, form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFieldReact } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects(form) {
          onFieldReact('target', () => {
            setResponse(
              'target ' + (form.values.other === 123 ? 'display' : 'hide')
            )
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.createField({ name: 'target' })
        }}
      >
        Initialize target
      </button>
      <button
        onClick={() => {
          const field = form.createField({ name: 'other' })
          field.setValue(123)
        }}
      >
        Assign other = 123
      </button>
      <button
        onClick={() => {
          const field = form.createField({ name: 'other' })
          field.setValue(null)
        }}
      >
        Assign other = null
      </button>
    </ActionResponse>
  )
}
```

> This example will track the changes of values.other, if it is equal to 123, it will control the display of the target, otherwise it will be hidden

## onFieldChange

#### Description

Side effect hook used to monitor the property changes of a field

#### Signature

```ts
interface onFieldChange {
  (
    pattern: FormPathPattern,
    watches?: string[],
    callback: (field: Field, form: Form) => void
  )
  (pattern: FormPathPattern, callback: (field: Field, form: Form) => void)
}
```

You can pass in the specific set of attributes you want to monitor, or you can leave it alone, the default is to monitor value changes

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFieldChange } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFieldChange('target', (field) => {
            setResponse('target value change:' + field.value)
          })
          onFieldChange('target', ['component'], () => {
            setResponse('target component change')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          const field = form.createField({ name: 'target' })
          field.setValue(field.value ? field.value + 1 : 1)
        }}
      >
        Settings
      </button>
      <button
        onClick={() => {
          const field = form.createField({ name: 'target' })
          field.setComponent('Input')
        }}
      >
        Set up components
      </button>
    </ActionResponse>
  )
}
```

## onFieldValueChange

Side effect hooks used to monitor changes in a field value

#### Signature

```ts
interface onFieldValueChange {
  (pattern: FormPathPattern, callback: (field: Field, form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFieldValueChange } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFieldValueChange('target', (field) => {
            setResponse('target value change:' + field.value)
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          const field = form.createField({ name: 'target' })
          field.setValue(field.value ? field.value + 1 : 1)
        }}
      >
        Settings
      </button>
    </ActionResponse>
  )
}
```

## onFieldInitialValueChange

Side-effect hooks used to monitor changes in the default value of a field

#### Signature

```ts
interface onFieldInitialValueChange {
  (pattern: FormPathPattern, callback: (field: Field, form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFieldInitialValueChange } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFieldInitialValueChange('target', (field) => {
            setResponse('target default value change:' + field.value)
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          const field = form.createField({ name: 'target' })
          field.setInitialValue(field.value ? field.value + 1 : 1)
        }}
      >
        Settings
      </button>
    </ActionResponse>
  )
}
```

## onFieldInputValueChange

Used to monitor the side effect hook triggered by a field onInput

#### Signature

```ts
interface onFieldInputValueChange {
  (pattern: FormPathPattern, callback: (field: Field, form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFieldInputValueChange } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFieldInputValueChange('target', (field) => {
            setResponse('target value change:' + field.value)
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          const field = form.createField({ name: 'target' })
          field.onInput(field.value ? field.value + 1 : 1)
        }}
      >
        Call onInput
      </button>
    </ActionResponse>
  )
}
```

## onFieldValidateStart

#### Description

Monitor the side effect hook that triggers the start of a certain field verification

#### Signature

```ts
interface onFieldValidateStart {
  (pattern: FormPathPattern, callback: (field: Field, form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFieldValidateStart } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFieldValidateStart('target', () => {
            setResponse('target verification start')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          const field = form.createField({ name: 'target', required: true })
          field.onInput('')
        }}
      >
        Trigger verification
      </button>
    </ActionResponse>
  )
}
```

## onFieldValidateEnd

#### Description

Monitor the side effect hook that triggers the end of a certain field verification

#### Signature

```ts
interface onFieldValidateEnd {
  (pattern: FormPathPattern, callback: (field: Field, form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFieldValidateEnd } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFieldValidateEnd('target', () => {
            setResponse('target verification is over')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          const field = form.createField({ name: 'target', required: true })
          field.onInput('')
        }}
      >
        Trigger verification
      </button>
    </ActionResponse>
  )
}
```

## onFieldValidateFailed

#### Description

Listen to the side-effect hook of a field verification trigger failure

#### Signature

```ts
interface onFieldValidateFailed {
  (pattern: FormPathPattern, callback: (field: Field, form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFieldValidateFailed } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFieldValidateFailed('target', () => {
            setResponse('target verification failed')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          const field = form.createField({ name: 'target', required: true })
          field.onInput('')
        }}
      >
        Trigger verification
      </button>
    </ActionResponse>
  )
}
```

## onFieldValidateSuccess

#### Description

Monitor the side effect hook that triggers a successful verification of a certain field

#### Signature

```ts
interface onFieldValidateSuccess {
  (pattern: FormPathPattern, callback: (field: Field, form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import {
  createForm,
  onFieldValidateFailed,
  onFieldValidateSuccess,
} from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFieldValidateFailed('target', () => {
            setResponse('target verification failed')
          })
          onFieldValidateSuccess('target', () => {
            setResponse('target verification succeeded')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          const field = form.createField({ name: 'target', required: true })
          field.onInput('')
        }}
      >
        Trigger failed
      </button>
      <button
        onClick={() => {
          const field = form.createField({ name: 'target', required: true })
          field.onInput('123')
        }}
      >
        Triggered successfully
      </button>
    </ActionResponse>
  )
}
```
</file>

<file path="packages/core/docs/api/entry/FieldEffectHooks.zh-CN.md">
---
order: 2
---

# Field Effect Hooks

## onFieldInit

#### 描述

用于监听某个字段初始化的副作用钩子，我们在调用 createField 的时候就会触发字段初始化事件

#### 签名

```ts
interface onFieldInit {
  (pattern: FormPathPattern, callback: (field: Field, form: Form) => void)
}
```

<Alert>
  FormPathPattern的语法格式请参考 <a href="/api/entry/form-path">FormPath</a>
</Alert>

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFieldInit } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFieldInit('target', () => {
            setResponse('target已初始化')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.createField({ name: 'target' })
        }}
      >
        创建字段
      </button>
    </ActionResponse>
  )
}
```

## onFieldMount

#### 描述

用于监听某个字段已挂载的副作用钩子，我们在调用 onMount 的时候就会触发字段挂载事件

#### 签名

```ts
interface onFieldMount {
  (pattern: FormPathPattern, callback: (field: Field, form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFieldMount } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFieldMount('target', () => {
            setResponse('target已挂载')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.createField({ name: 'target' }).onMount()
        }}
      >
        创建并挂载字段
      </button>
    </ActionResponse>
  )
}
```

## onFieldUnmount

#### 描述

用于监听某个字段已卸载的副作用钩子，我们在调用 onUnmount 的时候就会触发卸载事件

#### 签名

```ts
interface onFieldUnmount {
  (pattern: FormPathPattern, callback: (field: Field, form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFieldMount, onFieldUnmount } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFieldMount('target', () => {
            setResponse('target已挂载')
          })
          onFieldUnmount('target', () => {
            setResponse('target已卸载')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.createField({ name: 'target' }).onMount()
        }}
      >
        创建并挂载字段
      </button>
      <button
        onClick={() => {
          form.createField({ name: 'target' }).onUnmount()
        }}
      >
        卸载字段
      </button>
    </ActionResponse>
  )
}
```

## onFieldReact

用于实现字段响应式逻辑的副作用钩子，它的核心原理就是字段初始化的时候会执行回调函数，同时自动追踪依赖，依赖数据发生变化时回调函数会重复执行

#### 签名

```ts
interface onFieldReact {
  (pattern: FormPathPattern, callback: (field: Field, form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFieldReact } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects(form) {
          onFieldReact('target', () => {
            setResponse(
              'target ' + (form.values.other === 123 ? '显示' : '隐藏')
            )
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.createField({ name: 'target' })
        }}
      >
        初始化target
      </button>
      <button
        onClick={() => {
          const field = form.createField({ name: 'other' })
          field.setValue(123)
        }}
      >
        赋值other = 123
      </button>
      <button
        onClick={() => {
          const field = form.createField({ name: 'other' })
          field.setValue(null)
        }}
      >
        赋值other = null
      </button>
    </ActionResponse>
  )
}
```

> 该示例会追踪 values.other 的变化，如果等于 123，就会控制 target 显示，否则隐藏

## onFieldChange

#### 描述

用于监听某个字段的属性变化的副作用钩子

#### 签名

```ts
interface onFieldChange {
  (
    pattern: FormPathPattern,
    watches?: string[],
    callback: (field: Field, form: Form) => void
  )
  (pattern: FormPathPattern, callback: (field: Field, form: Form) => void)
}
```

可以传入具体要监听的的属性集合，也可以不传，默认是监听 value 变化

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFieldChange } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFieldChange('target', (field) => {
            setResponse('target值变化：' + field.value)
          })
          onFieldChange('target', ['component'], () => {
            setResponse('target组件变化')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          const field = form.createField({ name: 'target' })
          field.setValue(field.value ? field.value + 1 : 1)
        }}
      >
        设置值
      </button>
      <button
        onClick={() => {
          const field = form.createField({ name: 'target' })
          field.setComponent('Input')
        }}
      >
        设置组件
      </button>
    </ActionResponse>
  )
}
```

## onFieldValueChange

用于监听某个字段值变化的副作用钩子

#### 签名

```ts
interface onFieldValueChange {
  (pattern: FormPathPattern, callback: (field: Field, form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFieldValueChange } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFieldValueChange('target', (field) => {
            setResponse('target值变化：' + field.value)
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          const field = form.createField({ name: 'target' })
          field.setValue(field.value ? field.value + 1 : 1)
        }}
      >
        设置值
      </button>
    </ActionResponse>
  )
}
```

## onFieldInitialValueChange

用于监听某个字段默认值变化的副作用钩子

#### 签名

```ts
interface onFieldInitialValueChange {
  (pattern: FormPathPattern, callback: (field: Field, form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFieldInitialValueChange } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFieldInitialValueChange('target', (field) => {
            setResponse('target默认值变化：' + field.value)
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          const field = form.createField({ name: 'target' })
          field.setInitialValue(field.value ? field.value + 1 : 1)
        }}
      >
        设置值
      </button>
    </ActionResponse>
  )
}
```

## onFieldInputValueChange

用于监听某个字段 onInput 触发的副作用钩子

#### 签名

```ts
interface onFieldInputValueChange {
  (pattern: FormPathPattern, callback: (field: Field, form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFieldInputValueChange } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFieldInputValueChange('target', (field) => {
            setResponse('target 值变化：' + field.value)
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          const field = form.createField({ name: 'target' })
          field.onInput(field.value ? field.value + 1 : 1)
        }}
      >
        调用onInput
      </button>
    </ActionResponse>
  )
}
```

## onFieldValidateStart

#### 描述

监听某个字段校验触发开始的副作用钩子

#### 签名

```ts
interface onFieldValidateStart {
  (pattern: FormPathPattern, callback: (field: Field, form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFieldValidateStart } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFieldValidateStart('target', () => {
            setResponse('target校验开始')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          const field = form.createField({ name: 'target', required: true })
          field.onInput('')
        }}
      >
        触发校验
      </button>
    </ActionResponse>
  )
}
```

## onFieldValidateEnd

#### 描述

监听某个字段校验触发结束的副作用钩子

#### 签名

```ts
interface onFieldValidateEnd {
  (pattern: FormPathPattern, callback: (field: Field, form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFieldValidateEnd } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFieldValidateEnd('target', () => {
            setResponse('target校验结束')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          const field = form.createField({ name: 'target', required: true })
          field.onInput('')
        }}
      >
        触发校验
      </button>
    </ActionResponse>
  )
}
```

## onFieldValidateFailed

#### 描述

监听某个字段校验触发失败的副作用钩子

#### 签名

```ts
interface onFieldValidateFailed {
  (pattern: FormPathPattern, callback: (field: Field, form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFieldValidateFailed } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFieldValidateFailed('target', () => {
            setResponse('target校验失败')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          const field = form.createField({ name: 'target', required: true })
          field.onInput('')
        }}
      >
        触发校验
      </button>
    </ActionResponse>
  )
}
```

## onFieldValidateSuccess

#### 描述

监听某个字段校验触发成功的副作用钩子

#### 签名

```ts
interface onFieldValidateSuccess {
  (pattern: FormPathPattern, callback: (field: Field, form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import {
  createForm,
  onFieldValidateFailed,
  onFieldValidateSuccess,
} from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFieldValidateFailed('target', () => {
            setResponse('target校验失败')
          })
          onFieldValidateSuccess('target', () => {
            setResponse('target校验成功')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          const field = form.createField({ name: 'target', required: true })
          field.onInput('')
        }}
      >
        触发失败
      </button>
      <button
        onClick={() => {
          const field = form.createField({ name: 'target', required: true })
          field.onInput('123')
        }}
      >
        触发成功
      </button>
    </ActionResponse>
  )
}
```
</file>

<file path="packages/core/docs/api/entry/FormChecker.md">
---
order: 4
---

# Form Checkers

> The type checker is mainly used to determine the specific type of an object

## isForm

#### Description

Determine whether an object is a [Form](/api/models/form) object

#### Signature

```ts
interface isForm {
  (target: any): target is Form
}
```

#### Example

```ts
import { createForm, isForm } from '@formily/core'

const form = createForm()

console.log(isForm(form)) //true
```

## isField

#### Description

Determine whether an object is a [Field](/api/models/field) object

#### Signature

```ts
interface isField {
  (target: any): target is Field
}
```

#### Example

```ts
import { createForm, isField } from '@formily/core'

const form = createForm()

const field = form.createField({ name: 'target' })

console.log(isField(field)) //true
```

## isArrayField

#### Description

Determine whether an object is [ArrayField](/api/models/array-field) object

#### Signature

```ts
interface isArrayField {
  (target: any): target is ArrayField
}
```

#### Example

```ts
import { createForm, isArrayField } from '@formily/core'

const form = createForm()

const field = form.createArrayField({ name: 'target' })

console.log(isArrayField(field)) //true
```

## isObjectField

#### Description

Determine whether an object is a [ObjectField](/api/models/object-field) object

#### Signature

```ts
interface isObjectField {
  (target: any): target is ObjectField
}
```

#### Example

```ts
import { createForm, isObjectField } from '@formily/core'

const form = createForm()

const field = form.createObjectField({ name: 'target' })

console.log(isObjectField(field)) //true
```

## isVoidField

#### Description

Determine whether an object is a [VoidField](/api/models/void-field) object

#### Signature

```ts
interface isVoidField {
  (target: any): target is VoidField
}
```

#### Example

```ts
import { createForm, isVoidField } from '@formily/core'

const form = createForm()

const field = form.createVoidField({ name: 'target' })

console.log(isVoidField(field)) //true
```

## isGeneralField

#### Description

Determine whether an object is a Field/ArrayField/ObjectField/VoidField object

#### Signature

```ts
interface isGeneralField {
  (target: any): target is Field | ArrayField | ObjectField | VoidField
}
```

#### Example

```ts
import { createForm, isGeneralField } from '@formily/core'

const form = createForm()

const field = form.createField({ name: 'target' })
const arr = form.createArrayField({ name: 'array' })
const obj = form.createObjectField({ name: 'object' })
const vod = form.createVoidField({ name: 'void' })

console.log(isGeneralField(field)) //true
console.log(isGeneralField(arr)) //true
console.log(isGeneralField(obj)) //true
console.log(isGeneralField(vod)) //true
console.log(isGeneralField({})) //false
```

## isDataField

#### Description

Determine whether an object is a Field/ArrayField/ObjectField object

#### Signature

```ts
interface isDataField {
  (target: any): target is Field | ArrayField | ObjectField
}
```

#### Example

```ts
import { createForm, isDataField } from '@formily/core'

const form = createForm()

const field = form.createField({ name: 'target' })
const arr = form.createArrayField({ name: 'array' })
const obj = form.createObjectField({ name: 'object' })
const vod = form.createVoidField({ name: 'void' })

console.log(isDataField(field)) //true
console.log(isDataField(arr)) //true
console.log(isDataField(obj)) //true
console.log(isDataField(vod)) //false
console.log(isDataField({})) //false
```

## isFormState

#### Description

Determine whether an object is [IFormState](/api/models/form#iformstate) object

#### Signature

```ts
interface isFormState {
  (target: any): target is IFormState
}
```

#### Example

```ts
import { createForm, isFormState } from '@formily/core'

const form = createForm()

console.log(isFormState(form)) //false
console.log(isFormState(form.getState())) //true
```

## isFieldState

#### Description

Determine whether an object is [IFieldState](/api/models/field#ifieldstate) object

#### Signature

```ts
interface isFieldState {
  (target: any): target is IFieldState
}
```

#### Example

```ts
import { createForm, isFieldState } from '@formily/core'

const form = createForm()
const field = form.createField({
  name: 'target',
})

console.log(isFieldState(field)) //false
console.log(isFieldState(field.getState())) //true
```

## isArrayFieldState

#### Description

Determine whether an object is [IArrayFieldState](/api/models/array-field#iarrayfieldstate) object

#### Signature

```ts
interface isArrayFieldState {
  (target: any): target is IArrayFieldState
}
```

#### Example

```ts
import { createForm, isArrayFieldState } from '@formily/core'

const form = createForm()
const field = form.createArrayField({
  name: 'target',
})

console.log(isArrayFieldState(field)) //false
console.log(isArrayFieldState(field.getState())) //true
```

## isObjectFieldState

#### Description

Determine whether an object is [IObjectFieldState](/api/models/object-field#iobjectfieldstate) object

#### Signature

```ts
interface isObjectFieldState {
  (target: any): target is IObjectFieldState
}
```

#### Example

```ts
import { createForm, isObjectFieldState } from '@formily/core'

const form = createForm()
const field = form.createObjectField({
  name: 'target',
})

console.log(isObjectFieldState(field)) //false
console.log(isObjectFieldState(field.getState())) //true
```

## isVoidFieldState

#### Description

Determine whether an object is [IVoidFieldState](/api/models/void-field#ivoidfieldstate) object

#### Signature

```ts
interface isVoidFieldState {
  (target: any): target is IVoidFieldState
}
```

#### Example

```ts
import { createForm, isVoidFieldState } from '@formily/core'

const form = createForm()
const field = form.createVoidField({
  name: 'target',
})

console.log(isVoidFieldState(field)) //false
console.log(isVoidFieldState(field.getState())) //true
```

## isGeneralFieldState

#### Description

Determine whether an object is an IFieldState/IArrayFieldState/IObjectFieldState/IVoidFieldState object

#### Signature

```ts
interface isGeneralFieldState {
  (target: any): target is
    | IFieldState
    | IArrayFieldState
    | IObjectFieldState
    | IVoidFieldState
}
```

#### Example

```ts
import { createForm, isGeneralFieldState } from '@formily/core'

const form = createForm()

const field = form.createField({ name: 'target' })
const arr = form.createArrayField({ name: 'array' })
const obj = form.createObjectField({ name: 'object' })
const vod = form.createVoidField({ name: 'void' })

console.log(isGeneralFieldState(field)) //false
console.log(isGeneralFieldState(arr)) //false
console.log(isGeneralFieldState(obj)) //false
console.log(isGeneralFieldState(vod)) //false
console.log(isGeneralFieldState(field.getState())) //true
console.log(isGeneralFieldState(arr.getState())) //true
console.log(isGeneralFieldState(obj.getState())) //true
console.log(isGeneralFieldState(vod.getState())) //true
console.log(isGeneralFieldState({})) //false
```

## isDataFieldState

#### Description

Determine whether an object is an IFieldState/IArrayFieldState/IObjectFieldState object

#### Signature

```ts
interface isDataFieldState {
  (target: any): target is IFieldState | IArrayFieldState | IObjectFieldState
}
```

#### Example

```ts
import { createForm, isDataFieldState } from '@formily/core'

const form = createForm()

const field = form.createField({ name: 'target' })
const arr = form.createArrayField({ name: 'array' })
const obj = form.createObjectField({ name: 'object' })
const vod = form.createVoidField({ name: 'void' })

console.log(isDataFieldState(field)) //false
console.log(isDataFieldState(arr)) //false
console.log(isDataFieldState(obj)) //false
console.log(isDataFieldState(vod)) //false
console.log(isDataFieldState(field.getState())) //true
console.log(isDataFieldState(arr.getState())) //true
console.log(isDataFieldState(obj.getState())) //true
console.log(isDataFieldState(vod.getState())) //false
console.log(isDataFieldState({})) //false
```

## isQuery

#### Description

Determine whether an object is a Query object

#### Signature

```ts
interface isQuery {
  (target: any): target is Query
}
```

#### Example

```ts
import { createForm, isQuery } from '@formily/core'

const form = createForm()
console.log(isQuery(form.query('target'))) //true
```
</file>

<file path="packages/core/docs/api/entry/FormChecker.zh-CN.md">
---
order: 4
---

# Form Checkers

> 类型检查器主要用于判断某个对象具体是什么类型

## isForm

#### 描述

判断一个对象是否为 [Form](/api/models/form) 对象

#### 签名

```ts
interface isForm {
  (target: any): target is Form
}
```

#### 用例

```ts
import { createForm, isForm } from '@formily/core'

const form = createForm()

console.log(isForm(form)) //true
```

## isField

#### 描述

判断一个对象是否为 [Field](/api/models/field) 对象

#### 签名

```ts
interface isField {
  (target: any): target is Field
}
```

#### 用例

```ts
import { createForm, isField } from '@formily/core'

const form = createForm()

const field = form.createField({ name: 'target' })

console.log(isField(field)) //true
```

## isArrayField

#### 描述

判断一个对象是否为 [ArrayField](/api/models/array-field) 对象

#### 签名

```ts
interface isArrayField {
  (target: any): target is ArrayField
}
```

#### 用例

```ts
import { createForm, isArrayField } from '@formily/core'

const form = createForm()

const field = form.createArrayField({ name: 'target' })

console.log(isArrayField(field)) //true
```

## isObjectField

#### 描述

判断一个对象是否为 [ObjectField](/api/models/object-field) 对象

#### 签名

```ts
interface isObjectField {
  (target: any): target is ObjectField
}
```

#### 用例

```ts
import { createForm, isObjectField } from '@formily/core'

const form = createForm()

const field = form.createObjectField({ name: 'target' })

console.log(isObjectField(field)) //true
```

## isVoidField

#### 描述

判断一个对象是否为 [VoidField](/api/models/void-field) 对象

#### 签名

```ts
interface isVoidField {
  (target: any): target is VoidField
}
```

#### 用例

```ts
import { createForm, isVoidField } from '@formily/core'

const form = createForm()

const field = form.createVoidField({ name: 'target' })

console.log(isVoidField(field)) //true
```

## isGeneralField

#### 描述

判断一个对象是否为 Field/ArrayField/ObjectField/VoidField 对象

#### 签名

```ts
interface isGeneralField {
  (target: any): target is Field | ArrayField | ObjectField | VoidField
}
```

#### 用例

```ts
import { createForm, isGeneralField } from '@formily/core'

const form = createForm()

const field = form.createField({ name: 'target' })
const arr = form.createArrayField({ name: 'array' })
const obj = form.createObjectField({ name: 'object' })
const vod = form.createVoidField({ name: 'void' })

console.log(isGeneralField(field)) //true
console.log(isGeneralField(arr)) //true
console.log(isGeneralField(obj)) //true
console.log(isGeneralField(vod)) //true
console.log(isGeneralField({})) //false
```

## isDataField

#### 描述

判断一个对象是否为 Field/ArrayField/ObjectField 对象

#### 签名

```ts
interface isDataField {
  (target: any): target is Field | ArrayField | ObjectField
}
```

#### 用例

```ts
import { createForm, isDataField } from '@formily/core'

const form = createForm()

const field = form.createField({ name: 'target' })
const arr = form.createArrayField({ name: 'array' })
const obj = form.createObjectField({ name: 'object' })
const vod = form.createVoidField({ name: 'void' })

console.log(isDataField(field)) //true
console.log(isDataField(arr)) //true
console.log(isDataField(obj)) //true
console.log(isDataField(vod)) //false
console.log(isDataField({})) //false
```

## isFormState

#### 描述

判断一个对象是否为 [IFormState](/api/models/form#iformstate) 对象

#### 签名

```ts
interface isFormState {
  (target: any): target is IFormState
}
```

#### 用例

```ts
import { createForm, isFormState } from '@formily/core'

const form = createForm()

console.log(isFormState(form)) //false
console.log(isFormState(form.getState())) //true
```

## isFieldState

#### 描述

判断一个对象是否为 [IFieldState](/api/models/field#ifieldstate) 对象

#### 签名

```ts
interface isFieldState {
  (target: any): target is IFieldState
}
```

#### 用例

```ts
import { createForm, isFieldState } from '@formily/core'

const form = createForm()
const field = form.createField({
  name: 'target',
})

console.log(isFieldState(field)) //false
console.log(isFieldState(field.getState())) //true
```

## isArrayFieldState

#### 描述

判断一个对象是否为 [IArrayFieldState](/api/models/array-field#iarrayfieldstate) 对象

#### 签名

```ts
interface isArrayFieldState {
  (target: any): target is IArrayFieldState
}
```

#### 用例

```ts
import { createForm, isArrayFieldState } from '@formily/core'

const form = createForm()
const field = form.createArrayField({
  name: 'target',
})

console.log(isArrayFieldState(field)) //false
console.log(isArrayFieldState(field.getState())) //true
```

## isObjectFieldState

#### 描述

判断一个对象是否为 [IObjectFieldState](/api/models/object-field#iobjectfieldstate) 对象

#### 签名

```ts
interface isObjectFieldState {
  (target: any): target is IObjectFieldState
}
```

#### 用例

```ts
import { createForm, isObjectFieldState } from '@formily/core'

const form = createForm()
const field = form.createObjectField({
  name: 'target',
})

console.log(isObjectFieldState(field)) //false
console.log(isObjectFieldState(field.getState())) //true
```

## isVoidFieldState

#### 描述

判断一个对象是否为 [IVoidFieldState](/api/models/void-field#ivoidfieldstate) 对象

#### 签名

```ts
interface isVoidFieldState {
  (target: any): target is IVoidFieldState
}
```

#### 用例

```ts
import { createForm, isVoidFieldState } from '@formily/core'

const form = createForm()
const field = form.createVoidField({
  name: 'target',
})

console.log(isVoidFieldState(field)) //false
console.log(isVoidFieldState(field.getState())) //true
```

## isGeneralFieldState

#### 描述

判断一个对象是否为 IFieldState/IArrayFieldState/IObjectFieldState/IVoidFieldState 对象

#### 签名

```ts
interface isGeneralFieldState {
  (target: any): target is
    | IFieldState
    | IArrayFieldState
    | IObjectFieldState
    | IVoidFieldState
}
```

#### 用例

```ts
import { createForm, isGeneralFieldState } from '@formily/core'

const form = createForm()

const field = form.createField({ name: 'target' })
const arr = form.createArrayField({ name: 'array' })
const obj = form.createObjectField({ name: 'object' })
const vod = form.createVoidField({ name: 'void' })

console.log(isGeneralFieldState(field)) //false
console.log(isGeneralFieldState(arr)) //false
console.log(isGeneralFieldState(obj)) //false
console.log(isGeneralFieldState(vod)) //false
console.log(isGeneralFieldState(field.getState())) //true
console.log(isGeneralFieldState(arr.getState())) //true
console.log(isGeneralFieldState(obj.getState())) //true
console.log(isGeneralFieldState(vod.getState())) //true
console.log(isGeneralFieldState({})) //false
```

## isDataFieldState

#### 描述

判断一个对象是否为 IFieldState/IArrayFieldState/IObjectFieldState 对象

#### 签名

```ts
interface isDataFieldState {
  (target: any): target is IFieldState | IArrayFieldState | IObjectFieldState
}
```

#### 用例

```ts
import { createForm, isDataFieldState } from '@formily/core'

const form = createForm()

const field = form.createField({ name: 'target' })
const arr = form.createArrayField({ name: 'array' })
const obj = form.createObjectField({ name: 'object' })
const vod = form.createVoidField({ name: 'void' })

console.log(isDataFieldState(field)) //false
console.log(isDataFieldState(arr)) //false
console.log(isDataFieldState(obj)) //false
console.log(isDataFieldState(vod)) //false
console.log(isDataFieldState(field.getState())) //true
console.log(isDataFieldState(arr.getState())) //true
console.log(isDataFieldState(obj.getState())) //true
console.log(isDataFieldState(vod.getState())) //false
console.log(isDataFieldState({})) //false
```

## isQuery

#### 描述

判断一个对象是否为 Query 对象

#### 签名

```ts
interface isQuery {
  (target: any): target is Query
}
```

#### 用例

```ts
import { createForm, isQuery } from '@formily/core'

const form = createForm()
console.log(isQuery(form.query('target'))) //true
```
</file>

<file path="packages/core/docs/api/entry/FormEffectHooks.md">
---
order: 1
---

# Form Effect Hooks

## onFormInit

#### Description

Used to monitor the side effect hook of a form initialization, we will trigger the initialization event when we call createForm

#### Signature

```ts
interface onFormInit {
  (callback: (form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormInit } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  useMemo(
    () =>
      createForm({
        effects() {
          onFormInit(() => {
            setResponse('The form has been initialized')
          })
        },
      }),
    []
  )
  return <ActionResponse response={response} />
}
```

## onFormMount

#### Description

Used to monitor the side-effect hook that the form has been mounted, we will trigger the mount event when we call onMount

#### Signature

```ts
interface onFormMount {
  (callback: (form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormMount } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormMount(() => {
            setResponse('The form has been mounted')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.onMount()
        }}
      >
        Mount form
      </button>
    </ActionResponse>
  )
}
```

## onFormUnmount

#### Description

Used to monitor the side effect hook that the form has been unloaded, we will trigger the unmount event when we call onUnmount

#### Signature

```ts
interface onFormUnmount {
  (callback: (form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormUnmount } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormUnmount(() => {
            setResponse('Form has been uninstalled')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.onUnmount()
        }}
      >
        Uninstall form
      </button>
    </ActionResponse>
  )
}
```

## onFormReact

#### Description

The side effect hook used to implement form response logic. Its core principle is that the callback function will be executed when the form is initialized, and dependencies will be automatically tracked at the same time. The callback function will be executed repeatedly when the dependent data changes.

#### Signature

```ts
interface onFormReact {
  (callback: (form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormReact } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormReact((form) => {
            if (form.values.input == 'Hello') {
              setResponse('Response Hello')
            } else if (form.values.input == 'World') {
              setResponse('Response to World')
            }
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.setValuesIn('input', 'Hello')
        }}
      >
        Hello
      </button>
      <button
        onClick={() => {
          form.setValuesIn('input', 'World')
        }}
      >
        World
      </button>
    </ActionResponse>
  )
}
```

## onFormValuesChange

#### Description

Side effect hooks for monitoring form value changes

<Alert>
It should be noted that this hook is triggered synchronously. For some behaviors that trigger `set` operation of `Proxy` multiple times, the results may not be as expected. For example, when deleting elements from array by `splice`, the array length will be the same as before deletion. (<a href="https://github.com/alibaba/formily/issues/2128">#2128</a>)
</Alert>

#### Signature

```ts
interface onFormValuesChange {
  (callback: (form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormValuesChange } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormValuesChange((form) => {
            setResponse('Form value change: ' + form.values.input)
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.setValuesIn('input', 'Hello World')
        }}
      >
        Hello World
      </button>
    </ActionResponse>
  )
}
```

## onFormInitialValuesChange

#### Description

Side effect hooks used to monitor the changes of the default value of the form

#### Signature

```ts
interface onFormInitialValuesChange {
  (callback: (form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormInitialValuesChange } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormInitialValuesChange((form) => {
            setResponse('Form default value change: ' + form.values.input)
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.setInitialValuesIn('input', 'Hello World')
        }}
      >
        Hello World
      </button>
    </ActionResponse>
  )
}
```

## onFormInputChange

#### Description

Side effect hook for listening to field input

#### Signature

```ts
interface onFormInputChange {
  (callback: (form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormInputChange } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormInputChange((form) => {
            setResponse('Character input change: ' + form.values.input)
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form
            .createField({
              name: 'input',
            })
            .onInput('Hello World')
        }}
      >
        Hello World
      </button>
    </ActionResponse>
  )
}
```

## onFormSubmit

#### Description

Side effect hook for monitoring form submission

#### Signature

```ts
interface onFormSubmit {
  (callback: (form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormSubmit } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormSubmit(() => {
            setResponse('Form has been submitted')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.submit()
        }}
      >
        Submit
      </button>
    </ActionResponse>
  )
}
```

## onFormSubmitStart

#### Description

Side effect hook for monitoring the start of form submission

#### Signature

```ts
interface onFormSubmitStart {
  (callback: (form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormSubmitStart } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormSubmitStart(() => {
            setResponse('form submission start')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.submit()
        }}
      >
        Submit
      </button>
    </ActionResponse>
  )
}
```

## onFormSubmitEnd

#### Description

Side effect hook for monitoring the end of form submission

#### Signature

```ts
interface onFormSubmitEnd {
  (callback: (form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormSubmitEnd } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormSubmitEnd(() => {
            setResponse('End of form submission')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.submit()
        }}
      >
        Submit
      </button>
    </ActionResponse>
  )
}
```

## onFormSubmitFailed

#### Description

Side-effect hooks used to monitor form submission failures

#### Signature

```ts
interface onFormSubmitFailed {
  (callback: (form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormSubmitFailed } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormSubmitFailed(() => {
            setResponse('Form submission failed')
          })
        },
      }),
    []
  )
  const form2 = useMemo(
    () =>
      createForm({
        effects() {
          onFormSubmitFailed(() => {
            setResponse('Form verification failed')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.submit(() => {
            return Promise.reject('Runtime Error')
          })
        }}
      >
        Submit Runtime Error
      </button>
      <button
        onClick={() => {
          form2.createField({
            name: 'input',
            required: true,
          })
          form2.submit()
        }}
      >
        Submit Validate Error
      </button>
    </ActionResponse>
  )
}
```

## onFormSubmitSuccess

#### Description

Side effect hook used to monitor the success of form submission

#### Signature

```ts
interface onFormSubmitSuccess {
  (callback: (form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormSubmitSuccess } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormSubmitSuccess(() => {
            setResponse('Form submission is successful')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.submit()
        }}
      >
        Submit
      </button>
    </ActionResponse>
  )
}
```

## onFormSubmitValidateStart

#### Description

Side effect hook used to monitor the start of field validation of the form submission process

#### Signature

```ts
interface onFormSubmitValidateStart {
  (callback: (form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormSubmitValidateStart } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormSubmitValidateStart(() => {
            setResponse('Form submission verification starts')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.createField({
            name: 'input',
            required: true,
          })
          form.submit()
        }}
      >
        Submit
      </button>
    </ActionResponse>
  )
}
```

## onFormSubmitValidateEnd

#### Description

Side effect hook used to monitor the end of the field validation of the form submission process

#### Signature

```ts
interface onFormSubmitValidateEnd {
  (callback: (form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormSubmitValidateEnd } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormSubmitValidateEnd(() => {
            setResponse('Form submission verification is over')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.createField({
            name: 'input',
            required: true,
          })
          form.submit()
        }}
      >
        Submit
      </button>
    </ActionResponse>
  )
}
```

## onFormSubmitValidateFailed

#### Description

Side effect hook used to monitor the field validation failure of the form submission process

#### Signature

```ts
interface onFormSubmitValidateFailed {
  (callback: (form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormSubmitValidateFailed } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormSubmitValidateFailed(() => {
            setResponse('Form submission verification failed')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.createField({
            name: 'input',
            required: true,
          })
          form.submit()
        }}
      >
        Submit
      </button>
    </ActionResponse>
  )
}
```

## onFormSubmitValidateSuccess

#### Description

Side-effect hook used to monitor the successful field verification of the form submission process

#### Signature

```ts
interface onFormSubmitValidateSuccess {
  (callback: (form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormSubmitValidateSuccess } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormSubmitValidateSuccess(() => {
            setResponse('Form submission verification succeeded')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.createField({
            name: 'input',
          })
          form.submit()
        }}
      >
        Submit
      </button>
    </ActionResponse>
  )
}
```

## onFormValidateStart

#### Description

Side effect hook for monitoring the start of form validation

#### Signature

```ts
interface onFormValidateStart {
  (callback: (form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormValidateStart } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormValidateStart(() => {
            setResponse('Form verification starts')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.createField({
            name: 'input',
            required: true,
          })
          form.validate()
        }}
      >
        Submit
      </button>
    </ActionResponse>
  )
}
```

## onFormValidateEnd

#### Description

Side effect hook for monitoring the end of form validation

#### Signature

```ts
interface onFormValidateEnd {
  (callback: (form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormValidateEnd } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormValidateEnd(() => {
            setResponse('Form verification end')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.createField({
            name: 'input',
            required: true,
          })
          form.validate()
        }}
      >
        Submit
      </button>
    </ActionResponse>
  )
}
```

## onFormValidateFailed

#### Description

Side-effect hooks used to monitor form validation failures

#### Signature

```ts
interface onFormValidateFailed {
  (callback: (form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormValidateFailed } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormValidateFailed(() => {
            setResponse('Form verification failed')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.createField({
            name: 'input',
            required: true,
          })
          form.validate()
        }}
      >
        Submit
      </button>
    </ActionResponse>
  )
}
```

## onFormValidateSuccess

#### Description

Side effect hook for monitoring the start of form validation

#### Signature

```ts
interface onFormValidateSuccess {
  (callback: (form: Form) => void)
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormValidateSuccess } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormValidateSuccess(() => {
            setResponse('Form verification succeeded')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.createField({
            name: 'input',
          })
          form.validate()
        }}
      >
        Submit
      </button>
    </ActionResponse>
  )
}
```
</file>

<file path="packages/core/docs/api/entry/FormEffectHooks.zh-CN.md">
---
order: 1
---

# Form Effect Hooks

## onFormInit

#### 描述

用于监听某个表单初始化的副作用钩子，我们在调用 createForm 的时候就会触发初始化事件

#### 签名

```ts
interface onFormInit {
  (callback: (form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormInit } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  useMemo(
    () =>
      createForm({
        effects() {
          onFormInit(() => {
            setResponse('表单已初始化')
          })
        },
      }),
    []
  )
  return <ActionResponse response={response} />
}
```

## onFormMount

#### 描述

用于监听表单已挂载的副作用钩子，我们在调用 onMount 的时候就会触发挂载事件

#### 签名

```ts
interface onFormMount {
  (callback: (form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormMount } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormMount(() => {
            setResponse('表单已挂载')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.onMount()
        }}
      >
        挂载表单
      </button>
    </ActionResponse>
  )
}
```

## onFormUnmount

#### 描述

用于监听表单已卸载的副作用钩子，我们在调用 onUnmount 的时候就会触发卸载事件

#### 签名

```ts
interface onFormUnmount {
  (callback: (form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormUnmount } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormUnmount(() => {
            setResponse('表单已卸载')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.onUnmount()
        }}
      >
        卸载表单
      </button>
    </ActionResponse>
  )
}
```

## onFormReact

#### 描述

用于实现表单响应式逻辑的副作用钩子，它的核心原理就是表单初始化的时候会执行回调函数，同时自动追踪依赖，依赖数据发生变化时回调函数会重复执行

#### 签名

```ts
interface onFormReact {
  (callback: (form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormReact } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormReact((form) => {
            if (form.values.input == 'Hello') {
              setResponse('响应Hello')
            } else if (form.values.input == 'World') {
              setResponse('响应World')
            }
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.setValuesIn('input', 'Hello')
        }}
      >
        Hello
      </button>
      <button
        onClick={() => {
          form.setValuesIn('input', 'World')
        }}
      >
        World
      </button>
    </ActionResponse>
  )
}
```

## onFormValuesChange

#### 描述

用于监听表单值变化的副作用钩子

<Alert>
需要注意此钩子是同步触发的，对于某些会多次触发 Proxy set 操作的行为，得到的结果可能会与预期不符。例如: 数组 splice 删除元素时，数组长度会和删除之前相同，只是被删除元素被置为了 undefined。此时需要使用方按需添加 debounce 或 setTimeout。(<a href="https://github.com/alibaba/formily/issues/2128">#2128</a>)
</Alert>

#### 签名

```ts
interface onFormValuesChange {
  (callback: (form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormValuesChange } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormValuesChange((form) => {
            setResponse('表单值变化: ' + form.values.input)
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.setValuesIn('input', 'Hello World')
        }}
      >
        Hello World
      </button>
    </ActionResponse>
  )
}
```

## onFormInitialValuesChange

#### 描述

用于监听表单默认值变化的副作用钩子

#### 签名

```ts
interface onFormInitialValuesChange {
  (callback: (form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormInitialValuesChange } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormInitialValuesChange((form) => {
            setResponse('表单默认值变化: ' + form.values.input)
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.setInitialValuesIn('input', 'Hello World')
        }}
      >
        Hello World
      </button>
    </ActionResponse>
  )
}
```

## onFormInputChange

#### 描述

用于监听字段输入的副作用钩子

#### 签名

```ts
interface onFormInputChange {
  (callback: (form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormInputChange } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormInputChange((form) => {
            setResponse('字符输入变化: ' + form.values.input)
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form
            .createField({
              name: 'input',
            })
            .onInput('Hello World')
        }}
      >
        Hello World
      </button>
    </ActionResponse>
  )
}
```

## onFormSubmit

#### 描述

用于监听表单提交的副作用钩子

#### 签名

```ts
interface onFormSubmit {
  (callback: (form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormSubmit } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormSubmit(() => {
            setResponse('表单已提交')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.submit()
        }}
      >
        Submit
      </button>
    </ActionResponse>
  )
}
```

## onFormSubmitStart

#### 描述

用于监听表单提交开始的副作用钩子

#### 签名

```ts
interface onFormSubmitStart {
  (callback: (form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormSubmitStart } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormSubmitStart(() => {
            setResponse('表单提交开始')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.submit()
        }}
      >
        Submit
      </button>
    </ActionResponse>
  )
}
```

## onFormSubmitEnd

#### 描述

用于监听表单提交结束的副作用钩子

#### 签名

```ts
interface onFormSubmitEnd {
  (callback: (form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormSubmitEnd } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormSubmitEnd(() => {
            setResponse('表单提交结束')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.submit()
        }}
      >
        Submit
      </button>
    </ActionResponse>
  )
}
```

## onFormSubmitFailed

#### 描述

用于监听表单提交失败的副作用钩子

#### 签名

```ts
interface onFormSubmitFailed {
  (callback: (form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormSubmitFailed } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormSubmitFailed(() => {
            setResponse('表单提交失败')
          })
        },
      }),
    []
  )
  const form2 = useMemo(
    () =>
      createForm({
        effects() {
          onFormSubmitFailed(() => {
            setResponse('表单校验失败')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.submit(() => {
            return Promise.reject('Runtime Error')
          })
        }}
      >
        Submit Runtime Error
      </button>
      <button
        onClick={() => {
          form2.createField({
            name: 'input',
            required: true,
          })
          form2.submit()
        }}
      >
        Submit Validate Error
      </button>
    </ActionResponse>
  )
}
```

## onFormSubmitSuccess

#### 描述

用于监听表单提交成功的副作用钩子

#### 签名

```ts
interface onFormSubmitSuccess {
  (callback: (form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormSubmitSuccess } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormSubmitSuccess(() => {
            setResponse('表单提交成功')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.submit()
        }}
      >
        Submit
      </button>
    </ActionResponse>
  )
}
```

## onFormSubmitValidateStart

#### 描述

用于监听表单提交过程的字段校验开始的副作用钩子

#### 签名

```ts
interface onFormSubmitValidateStart {
  (callback: (form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormSubmitValidateStart } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormSubmitValidateStart(() => {
            setResponse('表单提交校验开始')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.createField({
            name: 'input',
            required: true,
          })
          form.submit()
        }}
      >
        Submit
      </button>
    </ActionResponse>
  )
}
```

## onFormSubmitValidateEnd

#### 描述

用于监听表单提交过程的字段校验结束的副作用钩子

#### 签名

```ts
interface onFormSubmitValidateEnd {
  (callback: (form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormSubmitValidateEnd } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormSubmitValidateEnd(() => {
            setResponse('表单提交校验结束')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.createField({
            name: 'input',
            required: true,
          })
          form.submit()
        }}
      >
        Submit
      </button>
    </ActionResponse>
  )
}
```

## onFormSubmitValidateFailed

#### 描述

用于监听表单提交过程的字段校验失败的副作用钩子

#### 签名

```ts
interface onFormSubmitValidateFailed {
  (callback: (form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormSubmitValidateFailed } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormSubmitValidateFailed(() => {
            setResponse('表单提交校验失败')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.createField({
            name: 'input',
            required: true,
          })
          form.submit()
        }}
      >
        Submit
      </button>
    </ActionResponse>
  )
}
```

## onFormSubmitValidateSuccess

#### 描述

用于监听表单提交过程的字段校验成功的副作用钩子

#### 签名

```ts
interface onFormSubmitValidateSuccess {
  (callback: (form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormSubmitValidateSuccess } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormSubmitValidateSuccess(() => {
            setResponse('表单提交校验成功')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.createField({
            name: 'input',
          })
          form.submit()
        }}
      >
        Submit
      </button>
    </ActionResponse>
  )
}
```

## onFormValidateStart

#### 描述

用于监听表单校验开始的副作用钩子

#### 签名

```ts
interface onFormValidateStart {
  (callback: (form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormValidateStart } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormValidateStart(() => {
            setResponse('表单校验开始')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.createField({
            name: 'input',
            required: true,
          })
          form.validate()
        }}
      >
        Submit
      </button>
    </ActionResponse>
  )
}
```

## onFormValidateEnd

#### 描述

用于监听表单校验结束的副作用钩子

#### 签名

```ts
interface onFormValidateEnd {
  (callback: (form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormValidateEnd } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormValidateEnd(() => {
            setResponse('表单校验结束')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.createField({
            name: 'input',
            required: true,
          })
          form.validate()
        }}
      >
        Submit
      </button>
    </ActionResponse>
  )
}
```

## onFormValidateFailed

#### 描述

用于监听表单校验失败的副作用钩子

#### 签名

```ts
interface onFormValidateFailed {
  (callback: (form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormValidateFailed } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormValidateFailed(() => {
            setResponse('表单校验失败')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.createField({
            name: 'input',
            required: true,
          })
          form.validate()
        }}
      >
        Submit
      </button>
    </ActionResponse>
  )
}
```

## onFormValidateSuccess

#### 描述

用于监听表单校验开始的副作用钩子

#### 签名

```ts
interface onFormValidateSuccess {
  (callback: (form: Form) => void)
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormValidateSuccess } from '@formily/core'
import { ActionResponse } from './ActionResponse'

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onFormValidateSuccess(() => {
            setResponse('表单校验成功')
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.createField({
            name: 'input',
          })
          form.validate()
        }}
      >
        Submit
      </button>
    </ActionResponse>
  )
}
```
</file>

<file path="packages/core/docs/api/entry/FormHooksAPI.md">
---
order: 3
---

# Form Hooks API

## createEffectHook

#### Description

Create a custom hook listener

#### Signature

```ts
interface createEffectHook {
  (
    type: string,
    callback?: (
      payload: any,
      form: Form,
      ...ctx: any[] //user-injected context
    ) => (...args: any[]) => void //High-level callbacks are used to process the encapsulation of the listener and help users achieve parameter customization capabilities
  )
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, createEffectHook } from '@formily/core'
import { ActionResponse } from './ActionResponse'

const onCustomEvent = createEffectHook(
  'custom-event',
  (payload, form) => (listener) => {
    listener(payload, form)
  }
)

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onCustomEvent((payload, form) => {
            setResponse(payload + 'Form:' + form.id)
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.notify('custom-event', 'This is Custom Event')
        }}
      >
        Notify
      </button>
    </ActionResponse>
  )
}
```

## createEffectContext

#### Description

In the effects function, if we abstract a lot of fine-grained hooks, we need to pass it layer by layer if we want to read the top-level context data in hooks, which is obviously very inefficient, so formily provides createEffectContext to help users quickly obtain context data

#### Signature

```ts
interface createEffectContext<T> {
  (defaultValue: T): {
    provide(value: T): void
    consume(): T
  }
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormSubmit, createEffectContext } from '@formily/core'
import { ActionResponse } from './ActionResponse'

const { provide, consume } = createEffectContext()

const useMyHook = () => {
  const setResponse = consume()
  onFormSubmit(() => {
    setResponse('Context communication succeeded')
  })
}

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          provide(setResponse)
          useMyHook()
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.submit()
        }}
      >
        submit
      </button>
    </ActionResponse>
  )
}
```

## useEffectForm

#### Description

useEffectForm is actually a convenient usage of EffectContext, because most scene users will read Form instances, so there is no need to manually define an EffectFormContext

#### Signature

```ts
interface useEffectForm {
  (): Form
}
```

#### Example

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, useEffectForm, createEffectContext } from '@formily/core'
import { ActionResponse } from './ActionResponse'

const { provide, consume } = createEffectContext()

const useMyHook = () => {
  const form = useEffectForm()
  const setResponse = consume()
  setResponse('Communication successful:' + form.id)
}

export default () => {
  const [response, setResponse] = useState('')
  useMemo(
    () =>
      createForm({
        effects() {
          provide(setResponse)
          useMyHook()
        },
      }),
    []
  )
  return <ActionResponse response={response} />
}
```
</file>

<file path="packages/core/docs/api/entry/FormHooksAPI.zh-CN.md">
---
order: 3
---

# Form Hooks API

## createEffectHook

#### 描述

创建自定义钩子监听器

#### 签名

```ts
interface createEffectHook {
  (
    type: string,
    callback?: (
      payload: any,
      form: Form,
      ...ctx: any[] //用户注入的上下文
    ) => (...args: any[]) => void //高阶回调用于处理监听器的封装，帮助用户实现参数定制能力
  )
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, createEffectHook } from '@formily/core'
import { ActionResponse } from './ActionResponse'

const onCustomEvent = createEffectHook(
  'custom-event',
  (payload, form) => (listener) => {
    listener(payload, form)
  }
)

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          onCustomEvent((payload, form) => {
            setResponse(payload + ' Form: ' + form.id)
          })
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.notify('custom-event', 'This is Custom Event')
        }}
      >
        Notify
      </button>
    </ActionResponse>
  )
}
```

## createEffectContext

#### 描述

在 effects 函数中如果我们抽象了很多细粒度的 hooks，想要在 hooks 里读到顶层上下文数据就需要层层传递，这样明显是很低效的事情，所以 formily 提供了 createEffectContext 帮助用户快速获取上下文数据

#### 签名

```ts
interface createEffectContext<T> {
  (defaultValue: T): {
    provide(value: T): void
    consume(): T
  }
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, onFormSubmit, createEffectContext } from '@formily/core'
import { ActionResponse } from './ActionResponse'

const { provide, consume } = createEffectContext()

const useMyHook = () => {
  const setResponse = consume()
  onFormSubmit(() => {
    setResponse('上下文通讯成功')
  })
}

export default () => {
  const [response, setResponse] = useState('')
  const form = useMemo(
    () =>
      createForm({
        effects() {
          provide(setResponse)
          useMyHook()
        },
      }),
    []
  )
  return (
    <ActionResponse response={response}>
      <button
        onClick={() => {
          form.submit()
        }}
      >
        提交
      </button>
    </ActionResponse>
  )
}
```

## useEffectForm

#### 描述

useEffectForm 其实是 EffectContext 的便利用法，因为大多数场景用户都会读取 Form 实例，所以就不需要手动定义一个 EffectFormContext

#### 签名

```ts
interface useEffectForm {
  (): Form
}
```

#### 用例

```tsx
import React, { useMemo, useState } from 'react'
import { createForm, useEffectForm, createEffectContext } from '@formily/core'
import { ActionResponse } from './ActionResponse'

const { provide, consume } = createEffectContext()

const useMyHook = () => {
  const form = useEffectForm()
  const setResponse = consume()
  setResponse('通讯成功：' + form.id)
}

export default () => {
  const [response, setResponse] = useState('')
  useMemo(
    () =>
      createForm({
        effects() {
          provide(setResponse)
          useMyHook()
        },
      }),
    []
  )
  return <ActionResponse response={response} />
}
```
</file>

<file path="packages/core/docs/api/entry/FormPath.md">
---
order: 5
---

# FormPath

The core of FormPath in Formily is to solve 2 types of problems:

- Path matching problem
- Data manipulation issues

Path matching requires that the given path must be a valid path matching syntax, such as `*(aa,bb,cc)`.

Data operation requires that the given path must be a legal data operation path, that is, it must be in the form of `a.b.c` and cannot carry `*`

## Constructor

```ts
class FormPath {
  constructor(pattern: FormPathPattern, base?: FormPathPattern)
}
```

## Attributes

| Property           | Description                                                                     | Type                      | Default Value |
| ------------------ | ------------------------------------------------------------------------------- | ------------------------- | ------------- |
| length             | If the path is a non-matching path, the length of the path can be read          | Number                    | `0`           |
| entire             | Path complete string, consistent with the input parameter data                  | String                    |               |
| segments           | If the path is a non-matching path, you can read the complete path segmentation | `Array<String \| Number>` | `[]`          |
| isMatchPattern     | Is the path a matching path                                                     | Boolean                   |               |
| isWildMatchPattern | Is the path a fully wildcarded path, such as `a.b.*`                            | Boolean                   |               |
| haveExcludePattern | Does the path have reverse matching, such as `*(!a.b.c)`                        | Boolean                   |               |
| tree               | Parsed AST tree                                                                 | Node                      |               |

## FormPathPattern

### Signature

```ts
type FormPathPattern = string | number | Array<string | number> | RegExp
```

### Data path syntax

#### Point path

**description**

It is our most commonly used `a.b.c` format, which uses dot notation to divide each path node, mainly used to read and write data

**Example**

```ts
import { FormPath } from '@formily/core'

const target = {}

FormPath.setIn(target, 'a.b.c', 'value')
console.log(FormPath.getIn(target, 'a.b.c')) //'value'
console.log(target) //{a:{b:{c:'value'}}}
```

#### Subscript path

For array paths, there will be subscripts. Our subscripts can use dot syntax or square brackets.

```ts
import { FormPath } from '@formily/core'

const target = {
  array: [],
}

FormPath.setIn(target, 'array.0.aa', '000')
console.log(FormPath.getIn(target, 'array.0.aa')) //000
console.log(target) //{array:[{aa:'000'}]}
FormPath.setIn(target, 'array[1].aa', '111')
console.log(FormPath.getIn(target, 'array.1.aa')) //111
console.log(target) //{array:[{aa:'000'},{aa:'111'}]}
```

#### Deconstruction expression

The deconstruction expression is similar to the ES6 deconstruction grammar, except that it does not support `...` deconstruction. It is very suitable for scenarios where the front and back data is inconsistent. It has several characteristics:

- The deconstruction expression will be regarded as a node of the point path, we can regard it as a normal string node, but it will take effect during data manipulation, so only the deconstruction expression needs to be matched as a normal node node in the matching grammar Can
- Use the deconstruction path in setIn, the data will be deconstructed
- Use the deconstruction path in getIn, the data will be reorganized

```ts
import { FormPath } from '@formily/core'

const target = {}

FormPath.setIn(target, 'parent.[aa,bb]', [11, 22])
console.log(target) //{parent:{aa:11,bb:22}}
console.log(FormPath.getIn(target, 'parent.[aa,bb]')) //[11,22]
console.log(FormPath.parse('parent.[aa,bb]').toString()) //parent.[aa,bb]
```

#### relative path

The relative path syntax is mainly expressed in dot syntax at the head of the data type path. It is very useful for calculating adjacent elements of the array. It has several characteristics:

- A dot represents the current path
- n dots represent n-1 steps forward
  - Subscripts can be used to calculate expressions in square brackets: `[+]` represents the current subscript +1, `[-]` represents the current subscript - 1, `[+n]` represents the current subscript +n, ` [-n]` represents the current subscript - n
- When path matching, group matching and range matching cannot be used, such as `*(..[+1].aa,..[+2].bb)`

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('.dd', 'aa.bb.cc').toString()) //aa.bb.dd
console.log(FormPath.parse('..[].dd', 'aa.1.cc').toString()) //aa.1.dd
console.log(FormPath.parse('..[+].dd', 'aa.1.cc').toString()) //aa.2.dd
console.log(FormPath.parse('..[+10].dd', 'aa.1.cc').toString()) //aa.11.dd
```

### Match path syntax

#### Full match

Full match is equivalent to matching all paths, only a `*` identification is required

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('*').match('aa')) //true
console.log(FormPath.parse('*').match('aa.bb')) //true
console.log(FormPath.parse('*').match('cc')) //true
```

#### Partial match

Local matching is equivalent to matching all paths of a node position, and also only needs to use a `*` mark

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.*.cc').match('aa.bb.cc')) //true
console.log(FormPath.parse('aa.*.cc').match('aa.kk.cc')) //true
console.log(FormPath.parse('aa.*.cc').match('aa.dd.cc')) //true
```

#### Group Match

Grouped matching can match multiple paths, and also supports nesting, syntax: `*(pattern1,pattern2,pattern3...)`

```ts
import { FormPath } from '@formily/core'

console.log(
  FormPath.parse('aa.*(bb,kk,dd,ee.*(oo,gg).gg).cc').match('aa.bb.cc')
) //true
console.log(
  FormPath.parse('aa.*(bb,kk,dd,ee.*(oo,gg).gg).cc').match('aa.kk.cc')
) //true
console.log(
  FormPath.parse('aa.*(bb,kk,dd,ee.*(oo,gg).gg).cc').match('aa.dd.cc')
) //true
console.log(
  FormPath.parse('aa.*(bb,kk,dd,ee.*(oo,gg).gg).cc').match('aa.ee.oo.gg.cc')
) //true
console.log(
  FormPath.parse('aa.*(bb,kk,dd,ee.*(oo,gg).gg).cc').match('aa.ee.gg.gg.cc')
) //true
```

#### Reverse match

Reverse matching is mainly used to exclude the specified path, syntax: `*(!pattern1,pattern2,pattern3)`

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('*(!aa,bb,cc)').match('aa')) //false
console.log(FormPath.parse('*(!aa,bb,cc)').match('kk')) //true
```

#### Extended matching

Extended matching is mainly used to match the starting substring of the path, syntax: `pattern~`

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('test~').match('test_111')) //true
console.log(FormPath.parse('test~').match('test_222')) //true
```

#### Range match

Range matching is mainly used to match the array index range, syntax: `*[x:y]`, x and y can be empty, representing open range matching

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.*[1:2].bb').match('aa.1.bb')) //true
console.log(FormPath.parse('aa.*[1:2].bb').match('aa.2.bb')) //true
console.log(FormPath.parse('aa.*[1:2].bb').match('aa.3.bb')) //false
console.log(FormPath.parse('aa.*[1:].bb').match('aa.3.bb')) //true
console.log(FormPath.parse('aa.*[:100].bb').match('aa.3.bb')) //true
console.log(FormPath.parse('aa.*[:100].bb').match('aa.1000.bb')) //false
```

#### Escape match

For path nodes that contain keywords, we can use escape syntax matching, the syntax is `\\` or `[[]]`

```ts
import { FormPath } from '@formily/core'

console.log(
  FormPath.parse('aa.\\,\\*\\{\\}\\.\\(\\).bb').match(
    'aa.\\,\\*\\{\\}\\.\\(\\).bb'
  )
) //true
console.log(FormPath.parse('aa.[[,*{}.()]].bb').match('aa.[[,*{}.()]].bb')) // true
```

#### Destructuring matching

For the path with deconstruction expression, if we match, we can directly match without escaping

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('target.[aa,bb]').match('target.[aa,bb]')) //true
```

## Method

### toString

#### Description

The complete string of the output path, supporting matching paths and data manipulation paths

#### Signature

```ts
interface toString {
  (): string
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.bb.cc').toString()) //aa.bb.cc
console.log(FormPath.parse('aa.bb.*').toString()) //aa.bb.*
console.log(FormPath.parse('*(aa,bb,cc)').toString()) //*(aa,bb,cc)
```

### toArray

#### Description

Array fragment of output path, only supports data manipulation path

#### Signature

```ts
interface toArray {
  (): Array<string | number>
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.bb.cc').toArray().join('--')) //aa-bb-cc
console.log(FormPath.parse('aa.bb.*').toArray()) //[]
console.log(FormPath.parse('*(aa,bb,cc)').toArray()) //[]
```

### concat

#### Description

Connection data operation path

#### Signature

```ts
interface concat {
  (...args: FormPathPattern[]): FormPath
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.bb.cc').concat('dd.ee.mm').toString()) //aa.bb.cc.dd.ee.mm
console.log(
  FormPath.parse('aa.bb.cc').concat(['dd', 'ee', 'mm'], 'kk.oo').toString()
) //aa.bb.cc.dd.ee.mm.kk.oo
```

### slice

#### Description

Select a segment of the data operation path

#### Signature

```ts
interface slice {
  (start?: number, end?: number): FormPath
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.bb.cc').slice(1).toString()) //bb.cc
```

### push

#### Description

Push a fragment path to the data operation path

#### Signature

```ts
interface push {
  (...args: FormPathPattern[]): FormPath
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.bb.cc').push('dd.kk').toString()) //aa.bb.cc.dd.kk
```

### pop

#### Description

Pop the last key from the data operation path

#### Signature

```ts
interface pop {
  (): FormPath
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.bb.cc').pop().toString()) //aa.bb
```

### splice

#### Description

Splice the data operation path

#### Signature

```ts
interface splice {
  (
    startIndex: number,
    deleteCount?: number,
    ...inertItems: Array<string | number>
  ): FormPath
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.bb.cc').splice(2, 1).toString()) //aa.bb
console.log(FormPath.parse('aa.bb.cc').splice(2, 0, 'ee.gg').toString()) //aa.bb.ee.gg.cc
console.log(FormPath.parse('aa.bb.cc').splice(2, 0, ['kk', 'mm']).toString()) //aa.bb.kk.mm.cc
```

### forEach

#### Description

Traverse the data operation path

#### Signature

```ts
interface forEach {
  (eacher: (key: string | number, index: number) => void): void
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

const keys = []

FormPath.parse('aa.bb.cc').forEach((key) => {
  keys.push(key)
})

console.log(keys) //['aa','bb','cc']
```

### map

#### Description

Loop mapping data operation path

#### Signature

```ts
interface map {
  (mapper: (key: string | number, index: number) => void): void
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

console.log(
  FormPath.parse('aa.bb.cc').map((key) => {
    return key + '~'
  }) //['aa~','bb~','cc~']
)
```

### reduce

#### Description

The reduce method executes a reducer function (executed in ascending order) provided by you on each element in the path, and aggregates the results into a single return value.

#### Signature

```ts
interface reduce<T> {
  (reducer: (value: T, key: string | number, index: number) => void): void
  accumulator: T
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

console.log(
  FormPath.parse('aa.bb.cc').reduce((count) => {
    return count + 1
  }, 0)
) //3
```

### parent

#### Description

Get the parent path of the current data operation path

#### Signature

```ts
interface parent {
  (): FormPath
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.bb.cc').parent().toString()) //aa.bb
```

### includes

#### Description

Used to determine whether a given data operation path is a subpath of the current data operation path

#### Signature

```ts
interface includes {
  (pattern: FormPathPattern): boolean
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.bb.cc').includes('aa.bb')) //true

console.log(FormPath.parse('aa.bb.cc').includes('cc.bb')) //false
```

### transform

#### Description

Based on regular extraction data to do path assembly

#### Signature

```ts
interface transform<T> {
  (regExp: RegExp, callback: (...matches: string[]) => T): T
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

console.log(
  FormPath.parse('aa.1.cc').transform(
    /\d+/,
    (index) => `aa.${parseInt(index) + 1}.cc`
  )
) //aa.2.cc
```

### match

#### Description

Use path matching syntax to match the current path

#### Signature

```ts
interface match {
  (pattern: FormPathPattern): boolean
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.1.cc').match('aa.*.cc')) //true
```

### matchAliasGroup

#### Description

Alias group matching, mainly used to match address and path in formily

#### Signature

```ts
interface matchAliasGroup {
  (pattern: FormPathPattern, alias: FormPathPattern): boolean
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.bb.cc').matchAliasGroup('aa.bb.cc', 'aa.cc')) //true
```

### existIn

#### Description

Determine whether the specified data exists based on the current path

#### Signature

```ts
interface existIn {
  (pattern: FormPathPattern): boolean
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.bb.cc').existIn({})) //false
```

### getIn

#### Description

Obtain the specified data based on the current path

#### Signature

```ts
interface getIn {
  (pattern: FormPathPattern): any
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.bb.cc').getIn({ aa: { bb: { cc: 'value' } } })) //value
```

### setIn

#### Description

Update the specified data based on the current path

#### Signature

```ts
interface setIn {
  (pattern: FormPathPattern, value: any): void
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

const target = {}

FormPath.parse('aa.bb.cc').setIn(target, 'value')

console.log(FormPath.parse('aa.bb.cc').getIn(target)) //value
```

### deleteIn

#### Description

Delete the specified data based on the current path

#### Signature

```ts
interface deleteIn {
  (pattern: FormPathPattern): boolean
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

const target = {
  aa: {
    bb: {
      cc: 'value',
    },
  },
}

FormPath.parse('aa.bb.cc').deleteIn(target)
console.log(FormPath.parse('aa.bb.cc').getIn(target)) //undefined
```

### ensureIn

#### Description

Ensure that there must be data under a certain path, if not, create data

#### Signature

```ts
interface ensureIn {
  (pattern: FormPathPattern, value: any): any
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

const target = {}

FormPath.parse('aa.bb.cc').ensureIn(target, 'value')

console.log(FormPath.parse('aa.bb.cc').getIn(target)) //value
```

## Static method

### match

#### Description

Generate a path matcher based on matching paths

#### Signature

```ts
interface match {
  (pattern: FormPathPattern): (pattern: FormPathPattern) => boolean
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.match('aa.*.cc')('aa.bb.cc')) // true
```

### transform

#### Description

Regular conversion path

#### Signature

```ts
interface transform<T> {
  (
    pattern: FormPathPattern,
    regexp: RegExp,
    callback: (...matches: string[]) => T
  ): T
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

console.log(
  FormPath.transform(
    'aa.0.bb',
    /\d+/,
    (index) => `aa.${parseInt(index) + 1}.bb`
  )
) // `aa.1.bb`
```

### parse

#### Description

Resolve path

#### Signature

```ts
interface parse {
  (pattern: FormPathPattern): FormPath
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.0.bb'))
```

### getIn

Get data based on path

#### Signature

```ts
interface getIn {
  (target: any, pattern: FormPathPattern): any
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.getIn({ aa: [{ bb: 'value' }] }, 'aa.0.bb'))
```

### setIn

Update data based on path

#### Signature

```ts
interface setIn {
  (target: any, pattern: FormPathPattern, value: any): void
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

const target = {}

FormPath.setIn(target, 'aa.bb.cc', 'value')

console.log(target) //{aa:{bb:{cc:'value'}}}
```

### deleteIn

Delete data based on path

#### Signature

```ts
interface deleteIn {
  (target: any, pattern: FormPathPattern): void
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

const target = {
  aa: {
    bb: {
      cc: 'value',
    },
  },
}

FormPath.deleteIn(target, 'aa.bb.cc')

console.log(target) //{aa:{bb:{}}}
```

### existIn

#### Description

Determine whether there is data in the specified path

#### Signature

```ts
interface existIn {
  (target: any, pattern: FormPathPattern): void
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

const target = {
  aa: {
    bb: {
      cc: 'value',
    },
  },
}

console.log(FormPath.existIn(target, 'aa.bb.cc')) //true
console.log(FormPath.existIn(target, 'aa.bb.kk')) //false
```

### ensureIn

#### Description

Ensure that there must be data under a certain path, if not, create data

#### Signature

```ts
interface ensureIn {
  (target: any, pattern: FormPathPattern, defaultValue: any): any
}
```

#### Example

```ts
import { FormPath } from '@formily/core'

const target = {}

FormPath.ensureIn(target, 'aa.bb.cc', 'value')

console.log(FormPath.getIn(target, 'aa.bb.cc')) //value
```
</file>

<file path="packages/core/docs/api/entry/FormPath.zh-CN.md">
---
order: 5
---

# FormPath

FormPath 在 Formily 中核心是解决 2 类问题：

- 路径匹配问题
- 数据操作问题

路径匹配是要求给定的路径必须是合法的路径匹配语法，比如`*(aa,bb,cc)`。

数据操作则要求给定的路径必须是合法的数据操作路径，也就是必须为`a.b.c`这样的形式，不能带`*`

## 构造函数

```ts
class FormPath {
  constructor(pattern: FormPathPattern, base?: FormPathPattern)
}
```

## 属性

| 属性               | 描述                                                   | 类型                      | 默认值 |
| ------------------ | ------------------------------------------------------ | ------------------------- | ------ |
| length             | 如果路径为非匹配型路径，则可以读取路径的长度           | Number                    | `0`    |
| entire             | 路径完整字符串，与入参数据一致                         | String                    |        |
| segments           | 如果路径为非匹配型路径，则可以读取到完整的路径分割片段 | `Array<String \| Number>` | `[]`   |
| isMatchPattern     | 该路径是否是匹配型路径                                 | Boolean                   |        |
| isWildMatchPattern | 该路径是否是全通配路径，比如`a.b.*`                    | Boolean                   |        |
| haveExcludePattern | 该路径是否存在反向匹配，比如`*(!a.b.c)`                | Boolean                   |        |
| tree               | 解析后的 AST 树                                        | Node                      |        |

## FormPathPattern

### 签名

```ts
type FormPathPattern = string | number | Array<string | number> | RegExp
```

### 数据路径语法

#### 点路径

**描述**

就是我们最常用的`a.b.c`格式，用点符号来分割每个路径节点，主要用来读写数据

**用例**

```ts
import { FormPath } from '@formily/core'

const target = {}

FormPath.setIn(target, 'a.b.c', 'value')
console.log(FormPath.getIn(target, 'a.b.c')) //'value'
console.log(target) //{a:{b:{c:'value'}}}
```

#### 下标路径

对于数组路径，都会有下标，我们的下标可以用点语法，也可以用中括号

```ts
import { FormPath } from '@formily/core'

const target = {
  array: [],
}

FormPath.setIn(target, 'array.0.aa', '000')
console.log(FormPath.getIn(target, 'array.0.aa')) //000
console.log(target) //{array:[{aa:'000'}]}
FormPath.setIn(target, 'array[1].aa', '111')
console.log(FormPath.getIn(target, 'array.1.aa')) //111
console.log(target) //{array:[{aa:'000'},{aa:'111'}]}
```

#### 解构表达式

解构表达式类似于 ES6 的解构语法，只是它不支持`...`解构，在前后端数据不一致的场景非常适用，它主要有几个特点：

- 解构表达式会作为点路径的某个节点，我们可以把它看做一个普通字符串节点，只是在数据操作时会生效，所以在匹配语法中只需要把解构表达式作为普通节点节点来匹配即可
- 在 setIn 中使用解构路径，数据会被解构
- 在 getIn 中使用解构路径，数据会被重组

```ts
import { FormPath } from '@formily/core'

const target = {}

FormPath.setIn(target, 'parent.[aa,bb]', [11, 22])
console.log(target) //{parent:{aa:11,bb:22}}
console.log(FormPath.getIn(target, 'parent.[aa,bb]')) //[11,22]
console.log(FormPath.parse('parent.[aa,bb]').toString()) //parent.[aa,bb]
```

#### 相对路径

相对路径语法主要是在数据型路径头部用点语法表示，对于计算数组的相邻元素非常好用，它主要有几个特点：

- 一个点代表当前路径
- n 个点代表往前 n-1 步
  - 中括号中可以用下标计算表达式：`[+]`代表当前下标+1，`[-]`代表当前下标-1，`[+n]`代表当前下标+n，`[-n]`代表当前下标-n
- 路径匹配的时候不能使用分组匹配和范围匹配，比如`*(..[+1].aa,..[+2].bb)`这样的形式

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('.dd', 'aa.bb.cc').toString()) //aa.bb.dd
console.log(FormPath.parse('..[].dd', 'aa.1.cc').toString()) //aa.1.dd
console.log(FormPath.parse('..[+].dd', 'aa.1.cc').toString()) //aa.2.dd
console.log(FormPath.parse('..[+10].dd', 'aa.1.cc').toString()) //aa.11.dd
```

### 匹配路径语法

#### 全匹配

全匹配相当于是匹配所有路径，只需要用一个`*`标识即可

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('*').match('aa')) //true
console.log(FormPath.parse('*').match('aa.bb')) //true
console.log(FormPath.parse('*').match('cc')) //true
```

#### 局部匹配

局部匹配相当于是匹配一个节点位置的所有路径，同样只需要用一个`*`标识即可

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.*.cc').match('aa.bb.cc')) //true
console.log(FormPath.parse('aa.*.cc').match('aa.kk.cc')) //true
console.log(FormPath.parse('aa.*.cc').match('aa.dd.cc')) //true
```

#### 分组匹配

分组匹配可以匹配多个路径，同时还支持嵌套，语法：`*(pattern1,pattern2,pattern3...)`

```ts
import { FormPath } from '@formily/core'

console.log(
  FormPath.parse('aa.*(bb,kk,dd,ee.*(oo,gg).gg).cc').match('aa.bb.cc')
) //true
console.log(
  FormPath.parse('aa.*(bb,kk,dd,ee.*(oo,gg).gg).cc').match('aa.kk.cc')
) //true
console.log(
  FormPath.parse('aa.*(bb,kk,dd,ee.*(oo,gg).gg).cc').match('aa.dd.cc')
) //true
console.log(
  FormPath.parse('aa.*(bb,kk,dd,ee.*(oo,gg).gg).cc').match('aa.ee.oo.gg.cc')
) //true
console.log(
  FormPath.parse('aa.*(bb,kk,dd,ee.*(oo,gg).gg).cc').match('aa.ee.gg.gg.cc')
) //true
```

#### 反向匹配

反向匹配主要用于排除指定路径，语法：`*(!pattern1,pattern2,pattern3)`

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('*(!aa,bb,cc)').match('aa')) //false
console.log(FormPath.parse('*(!aa,bb,cc)').match('kk')) //true
```

#### 扩展匹配

扩展匹配主要用于匹配路径起始子串，语法：`pattern~`

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('test~').match('test_111')) //true
console.log(FormPath.parse('test~').match('test_222')) //true
```

#### 范围匹配

范围匹配主要用于匹配数组索引范围，语法：`*[x:y]`，x 和 y 可以为空，代表开区间匹配

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.*[1:2].bb').match('aa.1.bb')) //true
console.log(FormPath.parse('aa.*[1:2].bb').match('aa.2.bb')) //true
console.log(FormPath.parse('aa.*[1:2].bb').match('aa.3.bb')) //false
console.log(FormPath.parse('aa.*[1:].bb').match('aa.3.bb')) //true
console.log(FormPath.parse('aa.*[:100].bb').match('aa.3.bb')) //true
console.log(FormPath.parse('aa.*[:100].bb').match('aa.1000.bb')) //false
```

#### 转义匹配

对于路径节点中包含关键字的，我们可以使用转义语法匹配，语法`\\`或者`[[]]`

```ts
import { FormPath } from '@formily/core'

console.log(
  FormPath.parse('aa.\\,\\*\\{\\}\\.\\(\\).bb').match(
    'aa.\\,\\*\\{\\}\\.\\(\\).bb'
  )
) //true
console.log(FormPath.parse('aa.[[,*{}.()]].bb').match('aa.[[,*{}.()]].bb')) //true
```

#### 解构匹配

对于携带解构表达式的路径，我们匹配的话，直接匹配即可，无需转义

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('target.[aa,bb]').match('target.[aa,bb]')) //true
```

## 方法

### toString

#### 描述

输出路径的完整字符串，支持匹配型路径与数据操作型路径

#### 签名

```ts
interface toString {
  (): string
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.bb.cc').toString()) //aa.bb.cc
console.log(FormPath.parse('aa.bb.*').toString()) //aa.bb.*
console.log(FormPath.parse('*(aa,bb,cc)').toString()) //*(aa,bb,cc)
```

### toArray

#### 描述

输出路径的数组片段，仅支持数据操作型路径

#### 签名

```ts
interface toArray {
  (): Array<string | number>
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.bb.cc').toArray().join('--')) //aa-bb-cc
console.log(FormPath.parse('aa.bb.*').toArray()) //[]
console.log(FormPath.parse('*(aa,bb,cc)').toArray()) //[]
```

### concat

#### 描述

连接数据操作型路径

#### 签名

```ts
interface concat {
  (...args: FormPathPattern[]): FormPath
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.bb.cc').concat('dd.ee.mm').toString()) //aa.bb.cc.dd.ee.mm
console.log(
  FormPath.parse('aa.bb.cc').concat(['dd', 'ee', 'mm'], 'kk.oo').toString()
) //aa.bb.cc.dd.ee.mm.kk.oo
```

### slice

#### 描述

选取数据操作路径的某个片段

#### 签名

```ts
interface slice {
  (start?: number, end?: number): FormPath
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.bb.cc').slice(1).toString()) //bb.cc
```

### push

#### 描述

往数据操作路径推入某个片段路径

#### 签名

```ts
interface push {
  (...args: FormPathPattern[]): FormPath
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.bb.cc').push('dd.kk').toString()) //aa.bb.cc.dd.kk
```

### pop

#### 描述

从数据操作路径中弹出最后一个 key

#### 签名

```ts
interface pop {
  (): FormPath
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.bb.cc').pop().toString()) //aa.bb
```

### splice

#### 描述

对数据操作路径做 splice 操作

#### 签名

```ts
interface splice {
  (
    startIndex: number,
    deleteCount?: number,
    ...inertItems: Array<string | number>
  ): FormPath
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.bb.cc').splice(2, 1).toString()) //aa.bb
console.log(FormPath.parse('aa.bb.cc').splice(2, 0, 'ee.gg').toString()) //aa.bb.ee.gg.cc
console.log(FormPath.parse('aa.bb.cc').splice(2, 0, ['kk', 'mm']).toString()) //aa.bb.kk.mm.cc
```

### forEach

#### 描述

遍历数据操作路径

#### 签名

```ts
interface forEach {
  (eacher: (key: string | number, index: number) => void): void
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

const keys = []

FormPath.parse('aa.bb.cc').forEach((key) => {
  keys.push(key)
})

console.log(keys) //['aa','bb','cc']
```

### map

#### 描述

循环映射数据操作路径

#### 签名

```ts
interface map {
  (mapper: (key: string | number, index: number) => void): void
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

console.log(
  FormPath.parse('aa.bb.cc').map((key) => {
    return key + '~'
  }) //['aa~','bb~','cc~']
)
```

### reduce

#### 描述

reduce 方法法对路径中的每个元素执行一个由您提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值。

#### 签名

```ts
interface reduce<T> {
  (reducer: (value: T, key: string | number, index: number) => void): void
  accumulator: T
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

console.log(
  FormPath.parse('aa.bb.cc').reduce((count) => {
    return count + 1
  }, 0)
) //3
```

### parent

#### 描述

获取当前数据操作路径的父级路径

#### 签名

```ts
interface parent {
  (): FormPath
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.bb.cc').parent().toString()) //aa.bb
```

### includes

#### 描述

用于判断给定数据操作路径是否为当前数据操作路径的子路径

#### 签名

```ts
interface includes {
  (pattern: FormPathPattern): boolean
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.bb.cc').includes('aa.bb')) //true

console.log(FormPath.parse('aa.bb.cc').includes('cc.bb')) //false
```

### transform

#### 描述

基于正则提取数据做路径拼装

#### 签名

```ts
interface transform<T> {
  (regExp: RegExp, callback: (...matches: string[]) => T): T
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

console.log(
  FormPath.parse('aa.1.cc').transform(
    /\d+/,
    (index) => `aa.${parseInt(index) + 1}.cc`
  )
) //aa.2.cc
```

### match

#### 描述

使用路径匹配语法匹配当前路径

#### 签名

```ts
interface match {
  (pattern: FormPathPattern): boolean
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.1.cc').match('aa.*.cc')) //true
```

### matchAliasGroup

#### 描述

别名组匹配，在 formily 中主要用来匹配 address 和 path

#### 签名

```ts
interface matchAliasGroup {
  (pattern: FormPathPattern, alias: FormPathPattern): boolean
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.bb.cc').matchAliasGroup('aa.bb.cc', 'aa.cc')) //true
```

### existIn

#### 描述

基于当前路径判断指定数据是否存在

#### 签名

```ts
interface existIn {
  (pattern: FormPathPattern): boolean
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.bb.cc').existIn({})) //false
```

### getIn

#### 描述

基于当前路径获取指定数据

#### 签名

```ts
interface getIn {
  (pattern: FormPathPattern): any
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.bb.cc').getIn({ aa: { bb: { cc: 'value' } } })) //value
```

### setIn

#### 描述

基于当前路径更新指定数据

#### 签名

```ts
interface setIn {
  (pattern: FormPathPattern, value: any): void
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

const target = {}

FormPath.parse('aa.bb.cc').setIn(target, 'value')

console.log(FormPath.parse('aa.bb.cc').getIn(target)) //value
```

### deleteIn

#### 描述

基于当前路径删除指定数据

#### 签名

```ts
interface deleteIn {
  (pattern: FormPathPattern): boolean
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

const target = {
  aa: {
    bb: {
      cc: 'value',
    },
  },
}

FormPath.parse('aa.bb.cc').deleteIn(target)
console.log(FormPath.parse('aa.bb.cc').getIn(target)) //undefined
```

### ensureIn

#### 描述

确保某个路径下必须有数据，如果没有则创建数据

#### 签名

```ts
interface ensureIn {
  (pattern: FormPathPattern, value: any): any
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

const target = {}

FormPath.parse('aa.bb.cc').ensureIn(target, 'value')

console.log(FormPath.parse('aa.bb.cc').getIn(target)) //value
```

## 静态方法

### match

#### 描述

基于匹配型路径生成一个路径匹配器

#### 签名

```ts
interface match {
  (pattern: FormPathPattern): (pattern: FormPathPattern) => boolean
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.match('aa.*.cc')('aa.bb.cc')) // true
```

### transform

#### 描述

正则转换路径

#### 签名

```ts
interface transform<T> {
  (
    pattern: FormPathPattern,
    regexp: RegExp,
    callback: (...matches: string[]) => T
  ): T
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

console.log(
  FormPath.transform(
    'aa.0.bb',
    /\d+/,
    (index) => `aa.${parseInt(index) + 1}.bb`
  )
) // `aa.1.bb`
```

### parse

#### 描述

解析路径

#### 签名

```ts
interface parse {
  (pattern: FormPathPattern): FormPath
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.parse('aa.0.bb'))
```

### getIn

基于路径获取数据

#### 签名

```ts
interface getIn {
  (target: any, pattern: FormPathPattern): any
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

console.log(FormPath.getIn({ aa: [{ bb: 'value' }] }, 'aa.0.bb'))
```

### setIn

基于路径更新数据

#### 签名

```ts
interface setIn {
  (target: any, pattern: FormPathPattern, value: any): void
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

const target = {}

FormPath.setIn(target, 'aa.bb.cc', 'value')

console.log(target) //{aa:{bb:{cc:'value'}}}
```

### deleteIn

基于路径删除数据

#### 签名

```ts
interface deleteIn {
  (target: any, pattern: FormPathPattern): void
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

const target = {
  aa: {
    bb: {
      cc: 'value',
    },
  },
}

FormPath.deleteIn(target, 'aa.bb.cc')

console.log(target) //{aa:{bb:{}}}
```

### existIn

#### 描述

判断指定路径是否存在数据

#### 签名

```ts
interface existIn {
  (target: any, pattern: FormPathPattern): void
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

const target = {
  aa: {
    bb: {
      cc: 'value',
    },
  },
}

console.log(FormPath.existIn(target, 'aa.bb.cc')) //true
console.log(FormPath.existIn(target, 'aa.bb.kk')) //false
```

### ensureIn

#### 描述

确保某个路径下必须有数据，如果没有则创建数据

#### 签名

```ts
interface ensureIn {
  (target: any, pattern: FormPathPattern, defaultValue: any): any
}
```

#### 用例

```ts
import { FormPath } from '@formily/core'

const target = {}

FormPath.ensureIn(target, 'aa.bb.cc', 'value')

console.log(FormPath.getIn(target, 'aa.bb.cc')) //value
```
</file>

<file path="packages/core/docs/api/entry/FormValidatorRegistry.md">
---
order: 6
---

# Form Validator Registry

## setValidateLanguage

#### Description

Set the built-in verification rule language

#### Signature

```ts
interface setValidateLanguage {
  (language: string): void
}
```

#### Example

```ts
import { setValidateLanguage } from '@formily/core'

setValidateLanguage('en-US')

setValidateLanguage('zh-CN')
```

## registerValidateFormats

#### Description

Register general regular rules, the current built-in regular library reference: [formats.ts](https://github.com/alibaba/formily/blob/master/packages/validator/src/formats.ts)

#### Signature

```ts
interface registerValidateFormats {
  (rules: { [key: string]: RegExp }): void
}
```

#### Example

```ts
import { registerValidateFormats } from '@formily/core'

registerValidateFormats({
  integer: /^[+-]?\d+$/,
})
```

## registerValidateLocale

#### Description

Global registration verification language package, the current built-in language package reference: [locale.ts](https://github.com/alibaba/formily/blob/master/packages/validator/src/locale.ts)

#### Signature

```ts
interface registerValidateLocale {
  (locales: {
    [key: string]: {
      key: string
    }
  }): void
}
```

#### Example

```ts
import { registerValidateLocale } from '@formily/core'

registerValidateLocale({
  ja: {
    required: 'このProjectは mustです',
  },
})
```

## registerValidateMessageTemplateEngine

#### Description

Globally register the verification message template engine. When we return the verification message in the validator, we can perform conversion based on the template engine syntax

#### Signature

```ts
interface registerValidateMessageTemplateEngine {
  (template: (message: ValidatorFunctionResponse, context: any) => any): void
}
```

#### Example

```ts
import { registerValidateMessageTemplateEngine } from '@formily/core'

registerValidateMessageTemplateEngine((message, context) => {
  return message.replace(/\<\%\s*([\w.]+)\s*\%\>/g, (_, $0) => {
    return FormPath.getIn(context, $0)
  })
})
```

## registerValidateRules

#### Description

Register general verification rules, the current built-in rule library reference: [rules.ts](https://github.com/alibaba/formily/blob/master/packages/validator/src/rules.ts)

#### Signature

```ts
interface registerValidateRules {
  (rules: {
    [key: string]: (
      value: any,
      rule: ValidatorRules,
      ctx: Context
    ) => ValidateResult | Promise<ValidateResult>
  }): void
}
```

#### Example

```ts
import { registerValidateRules } from '@formily/core'

registerValidateRules({
  custom(value) {
    return value > 100 ? 'error' : ''
  },
})
```

## getValidateLocaleIOSCode

#### Description

Get the built-in ISO Code

#### Signature

```ts
interface getValidateLocaleIOSCode {
  (language: string): string | undefined
}
```

#### Example

```ts
import { getValidateLocaleIOSCode } from '@formily/core'

getValidateLocaleIOSCode('en')

// ==> en_US
```
</file>

<file path="packages/core/docs/api/entry/FormValidatorRegistry.zh-CN.md">
---
order: 6
---

# Form Validator Registry

## setValidateLanguage

#### 描述

设置内置校验规则语言

#### 签名

```ts
interface setValidateLanguage {
  (language: string): void
}
```

#### 用例

```ts
import { setValidateLanguage } from '@formily/core'

setValidateLanguage('en-US')

setValidateLanguage('zh-CN')
```

## registerValidateFormats

#### 描述

注册通用正则规则，目前内置正则库参考：[formats.ts](https://github.com/alibaba/formily/blob/master/packages/validator/src/formats.ts)

#### 签名

```ts
interface registerValidateFormats {
  (rules: { [key: string]: RegExp }): void
}
```

#### 用例

```ts
import { registerValidateFormats } from '@formily/core'

registerValidateFormats({
  integer: /^[+-]?\d+$/,
})
```

## registerValidateLocale

#### 描述

全局注册校验语言包，目前内置语言包参考：[locale.ts](https://github.com/alibaba/formily/blob/master/packages/validator/src/locale.ts)

#### 签名

```ts
interface registerValidateLocale {
  (locales: {
    [key: string]: {
      key: string
    }
  }): void
}
```

#### 用例

```ts
import { registerValidateLocale } from '@formily/core'

registerValidateLocale({
  ja: {
    required: 'この項目は必須です',
  },
})
```

## registerValidateMessageTemplateEngine

#### 描述

全局注册校验消息模板引擎，我们在校验器中返回校验消息的时候，可以基于模板引擎语法做转换

#### 签名

```ts
interface registerValidateMessageTemplateEngine {
  (template: (message: ValidatorFunctionResponse, context: any) => any): void
}
```

#### 用例

```ts
import { registerValidateMessageTemplateEngine } from '@formily/core'

registerValidateMessageTemplateEngine((message, context) => {
  return message.replace(/\<\%\s*([\w.]+)\s*\%\>/g, (_, $0) => {
    return FormPath.getIn(context, $0)
  })
})
```

## registerValidateRules

#### 描述

注册通用校验规则，目前内置规则库参考：[rules.ts](https://github.com/alibaba/formily/blob/master/packages/validator/src/rules.ts)

#### 签名

```ts
interface registerValidateRules {
  (rules: {
    [key: string]: (
      value: any,
      rule: ValidatorRules,
      ctx: Context
    ) => ValidateResult | Promise<ValidateResult>
  }): void
}
```

#### 用例

```ts
import { registerValidateRules } from '@formily/core'

registerValidateRules({
  custom(value) {
    return value > 100 ? 'error' : ''
  },
})
```

## getValidateLocaleIOSCode

#### 描述

获取内置存在的 ISO Code

#### 签名

```ts
interface getValidateLocaleIOSCode {
  (language: string): string | undefined
}
```

#### 用例

```ts
import { getValidateLocaleIOSCode } from '@formily/core'

getValidateLocaleIOSCode('en')

// ==>  en_US
```
</file>

<file path="packages/core/docs/api/models/ArrayField.md">
---
order: 2
---

# ArrayField

Call the ArrayField model returned by [createArrayField](/api/models/form#createarrayfield).

Because ArrayField is inherited from the [Field](/api/models/field) model, most APIs can refer to the Field model. This document only explains the extension method

## Method

<Alert>

Note: The following method not only updates the array data, but also transposes the state of the child nodes. If you don't want to automatically transpose the state, you can directly call the `setValue` method to overwrite the update value.

</Alert>

### push

#### Description

Append an element to the end of the array and trigger onInput

#### Signature

```ts
interface push {
  (...items: any[]): Promise<void>
}
```

### pop

#### Description

Pop the last element of the array and trigger onInput

#### Signature

```ts
interface pop {
  (): Promise<void>
}
```

### insert

#### Description

Insert an element into the array and trigger onInput

#### Signature

```ts
interface insert {
  (index: number, ...items: any[]): Promise<void>
}
```

### remove

#### Description

Delete the array element and trigger onInput

#### Signature

```ts
interface remove {
  (index: number): Promise<void>
}
```

### shift

#### Description

Pop the first element of the array and trigger onInput

#### Signature

```ts
interface shift {
  (): Promise<void>
}
```

### unshift

#### Description

Append an element to the head of the array and trigger onInput

#### Signature

```ts
interface unshift {
  (...items: any[]): Promise<void>
}
```

### move

#### Description

Move the array element and trigger onInput

#### Signature

```ts
interface move {
  (fromIndex: number, toIndex: number): Promise<void>
}
```

### moveUp

#### Description

Move the array element up and trigger onInput

#### Signature

```ts
interface moveUp {
  (index: number): Promise<void>
}
```

### moveDown

#### Description

Move the array element down and trigger onInput

#### Signature

```ts
interface moveDown {
  (index: number): Promise<void>
}
```

## Types of

### IArrayFieldState

The main attributes refer to [IFieldState](/api/models/field#ifieldstate), but the data type of value is required to be an array
</file>

<file path="packages/core/docs/api/models/ArrayField.zh-CN.md">
---
order: 2
---

# ArrayField

调用[createArrayField](/api/models/form#createarrayfield)所返回的 ArrayField 模型。

因为 ArrayField 是继承至 [Field](/api/models/field) 模型的，所以大部分 API 参考 Field 模型即可，该文档只讲解扩展方法

## 方法

<Alert>

注意：以下方法不仅会对数组数据做更新，同时还会对子节点做状态转置，如果不希望自动转置状态，可以直接调用`setValue`方法覆盖式更新值即可。

</Alert>

### push

#### 描述

往数组尾部追加元素，并触发 onInput

#### 签名

```ts
interface push {
  (...items: any[]): Promise<void>
}
```

### pop

#### 描述

弹出数组最后一个元素，并触发 onInput

#### 签名

```ts
interface pop {
  (): Promise<void>
}
```

### insert

#### 描述

往数组中插入元素，并触发 onInput

#### 签名

```ts
interface insert {
  (index: number, ...items: any[]): Promise<void>
}
```

### remove

#### 描述

删除数组元素，并触发 onInput

#### 签名

```ts
interface remove {
  (index: number): Promise<void>
}
```

### shift

#### 描述

弹出数组第一个元素，并触发 onInput

#### 签名

```ts
interface shift {
  (): Promise<void>
}
```

### unshift

#### 描述

往数组头部追加元素，并触发 onInput

#### 签名

```ts
interface unshift {
  (...items: any[]): Promise<void>
}
```

### move

#### 描述

移动数组元素，并触发 onInput

#### 签名

```ts
interface move {
  (fromIndex: number, toIndex: number): Promise<void>
}
```

### moveUp

#### 描述

上移数组元素，并触发 onInput

#### 签名

```ts
interface moveUp {
  (index: number): Promise<void>
}
```

### moveDown

#### 描述

下移数组元素，并触发 onInput

#### 签名

```ts
interface moveDown {
  (index: number): Promise<void>
}
```

## 类型

### IArrayFieldState

主要属性参考[IFieldState](/api/models/field#ifieldstate)，只是 value 的数据类型要求是数组
</file>

<file path="packages/core/docs/api/models/Field.md">
---
order: 1
---

# Field

Call the Field model returned by [createField](/api/models/form#createfield).

All model attributes are listed below. If the attribute is writable, then we can directly refer to it to modify the attribute, and @formily/reactive will respond to trigger the UI update.

## Attributes

| Property       | Description                                         | Type                                               | Read-only or not | Default value |
| -------------- | --------------------------------------------------- | -------------------------------------------------- | ---------------- | ------------- |
| initialized    | Has the field been initialized                      | Boolean                                            | No               | `false`       |
| mounted        | Is the field mounted                                | Boolean                                            | No               | `false`       |
| unmounted      | Is the field unmounted                              | Boolean                                            | No               | `false`       |
| address        | Field node path                                     | [FormPath](/api/entry/form-path)                   | Yes              |               |
| path           | Field data path                                     | [FormPath](/api/entry/form-path)                   | Yes              |               |
| title          | Field Title                                         | [FieldMessage](#fieldmessage)                      | No               | `""`          |
| description    | Field description                                   | [FieldMessage](#fieldmessage)                      | No               | `""`          |
| loading        | Field loading status                                | Boolean                                            | No               | `false`       |
| validating     | Is the field being validated                        | Boolean                                            | No               | `false`       |
| modified       | Whether the field tree has been manually modified   | Boolean                                            | No               | `false`       |
| selfModified   | Whether the field has been manually modified        | Boolean                                            | No               | `false`       |
| active         | Is the field active                                 | Boolean                                            | No               | `false`       |
| visited        | Whether the field has been visited                  | Boolean                                            | No               | `false`       |
| inputValue     | Field input value                                   | Any                                                | No               | `null`        |
| inputValues    | Field input value collection                        | Array                                              | No               | `[]`          |
| dataSource     | Field data source                                   | Array                                              | No               | `[]`          |
| validator      | Field validator                                     | [FieldValidator](#fieldvalidator)                  | No               | `null`        |
| decorator      | field decorator                                     | Any[]                                              | No               | `null`        |
| component      | Field component                                     | Any[]                                              | No               | `null`        |
| feedbacks      | Field feedback information                          | [IFieldFeedback](#ifieldfeedback)[]                | No               | `[]`          |
| parent         | Parent field                                        | [GeneralField](#generalfield)                      | yes              | `null`        |
| errors         | Field all error message(include children)           | [IFormFeedback](/api/models/form/#iformfeedback)[] | Yes              | `[]`          |
| warnings       | Field all warning message(include children)         | [IFormFeedback](/api/models/form/#iformfeedback)[] | Yes              | `[]`          |
| successes      | Field all success message(include children)         | [IFormFeedback](/api/models/form/#iformfeedback)[] | Yes              | `[]`          |
| valid          | Is the all field valid(include children)            | Boolean                                            | Yes              | `true`        |
| invalid        | Is the all field illegal(include children)          | Boolean                                            | Yes              | `false`       |
| value          | Field value                                         | Any                                                | No               |               |
| initialValue   | Field default value                                 | Any                                                | No               |               |
| display        | Field display status                                | [FieldDisplayTypes](#fielddisplaytypes)            | No               | `"visible"`   |
| pattern        | Field interaction mode                              | [FieldPatternTypes](#fieldpatterntypes)            | No               | `"editable"`  |
| required       | Is the field required                               | Boolean                                            | No               | `false`       |
| hidden         | Whether the field is hidden                         | Boolean                                            | No               | `false`       |
| visible        | Whether the field is displayed                      | Boolean                                            | No               | `true`        |
| disabled       | Whether the field is disabled                       | Boolean                                            | No               | `false`       |
| readOnly       | Is the field read-only                              | Boolean                                            | No               | `false`       |
| readPretty     | Whether the field is in the reading state           | Boolean                                            | No               | `false`       |
| editable       | Field is editable                                   | Boolean                                            | No               | `true`        |
| validateStatus | Field validation status                             | [FieldValidateStatus](#fieldvalidatestatus)        | yes              | `null`        |
| content        | Field content, usually as a child node              | any                                                | No               | `null`        |
| data           | Field extends properties                            | Object                                             | No               | `null`        |
| selfErrors     | Field own error message                             | [FieldMessage](#fieldmessage)[]                    | No               | `[]`          |
| selfWarnings   | Field own warning message                           | [FieldMessage](#fieldmessage)[]                    | No               | `[]`          |
| selfSuccesses  | Success message of the field itself                 | [FieldMessage](#fieldmessage)[]                    | No               | `[]`          |
| selfValid      | Is the field valid                                  | Boolean                                            | Yes              | `true`        |
| selfInvalid    | Is the field itself illegal                         | Boolean                                            | Yes              | `false`       |
| indexes        | collection of field numeric indexes                 | Number                                             | yes              | `-`           |
| index          | field numeric index, take the last index of indexes | Number                                             | Yes              | `-`           |

#### explain in detail

**active**

Trigger onFocus is true, trigger onBlur is false

**visited**

Triggered onFocus will always be true

**inputValue**

Trigger the value collected by onInput

**inputValues**

Trigger the multi-parameter values collected by onInput

**hidden**

When true, display is hidden, when false, display is visible

**visible**

When true, display is visible, when false, display is none

## Method

### setTitle

#### Description

Set field title

#### Signature

```ts
interface setTitle {
  (title?: FieldMessage): void
}
```

FieldMessage Reference [FieldMessage](#fieldmessage)

### setDescription

#### Description

Set field description information

#### Signature

```ts
interface setDescription {
  (title?: FieldMessage): void
}
```

FieldMessage Reference [FieldMessage](#fieldmessage)

### setDataSource

#### Description

Set field data source

#### Signature

```ts
interface setDataSource {
  (dataSource?: FieldDataSource): void
}
```

FieldDataSource Reference [FieldDataSource](#fielddatasource)

### setFeedback

#### Description

Set field message feedback

#### Signature

```ts
interface setFeedback {
  (feedback?: IFieldFeedback): void
}
```

IFieldFeedback Reference [IFieldFeedback](#ifieldfeedback)

### setSelfErrors

#### Description

Set the field error message, here is a feedback update with EffectError as the code, mainly to prevent pollution of the checker result, if you want to force overwrite, you can use setFeedback

#### Signature

```ts
interface setSelfErrors {
  (messages?: FieldMessage[]): void
}
```

### setSelfWarnings

#### Description

Set the field warning information, here is a feedback update with EffectWarning as the code, mainly to prevent pollution of the checker result, if you want to force overwrite, you can use setFeedback

#### Signature

```ts
interface setSelfWarning {
  (messages?: FieldMessage[]): void
}
```

### setSelfSuccesses

#### Description

Set the field success information, here is a feedback update with EffectSuccess as the code, mainly to prevent pollution of the checker result, if you want to force overwrite, you can use setFeedback

#### Signature

```ts
interface setSelfSuccesses {
  (messages?: FieldMessage[]): void
}
```

### setValidator

#### Description

Set field validator

#### Signature

```ts
interface setValidator {
  (validator?: FieldValidator): void
}
```

FieldValidator Reference [FieldValidator](#fieldvalidator)

### setRequired

#### Description

Whether the setting field is required

#### Signature

```ts
interface setRequired {
  (required?: boolean): void
}
```

### setValidatorRule

#### 描述

Set the field validator according to the rules, similar to setRequired

#### 签名

```ts
interface setValidatorRule {
  (ruleName?: string, ruleValue: any): void
}
```

### setValue

#### Description

Set field value

#### Signature

```ts
interface setValue {
  (value?: FieldValue): void
}
```

FieldValue Reference [FieldValue](#fieldvalue)

### setInitialValue

#### Description

Set field default value

#### Signature

```ts
interface setInitialValue {
  (initialValue?: FieldValue): void
}
```

FieldValue Reference [FieldValue](#fieldvalue)

### setDisplay

#### Description

Set field display status

#### Signature

```ts
interface setDisplay {
  (display?: FieldDisplayTypes): void
}
```

FieldDisplayTypes Reference [FieldDisplayTypes](#fielddisplaytypes)

### setPattern

#### Description

Set field interaction mode

#### Signature

```ts
interface setPattern {
  (pattern?: FieldPatternTypes): void
}
```

FieldPatternTypes Reference [FieldPatternTypes](#fieldpatterntypes)

### setLoading

#### Description

Set field loading status

#### Signature

```ts
interface setLoading {
  (loading?: boolean): void
}
```

### setValidating

#### Description

Set field verification status

#### Signature

```ts
interface setValidating {
  (validating?: boolean): void
}
```

### setComponent

#### Description

Set field component

#### Signature

```ts
interface setComponent {
  (component?: FieldComponent, props?: any): void
}
```

FieldComponent Reference [FieldComponent](#fieldcomponent)

### setComponentProps

#### Description

Set field component properties

#### Signature

```ts
interface setComponentProps {
  (props?: any): void
}
```

### setDecorator

#### Description

Set field decorator

#### Signature

```ts
interface setDecorator {
  (decorator?: FieldDecorator, props?: any): void
}
```

FieldDecorator Reference [FieldDecorator](#fielddecorator)

### setDecoratorProps

#### Description

Set field decorator properties

#### Signature

```ts
interface setDecoratorProps {
  (props?: any): void
}
```

### setState

#### Description

Set field status

#### Signature

```ts
interface setState {
  (state: IFieldState): void
  (callback: (state: IFieldState) => void): void
}
```

IFieldState Reference [IFieldState](#ifieldstate)

### getState

#### Description

Get field status

#### Signature

```ts
interface getState<T> {
  (): IFieldState
  (callback: (state: IFieldState) => T): T
}
```

IFieldState Reference [IFieldState](#ifieldstate)

### setData

#### Description

set field data

#### Signature

```ts
interface setData {
  (data: any): void
}
```

### setContent

#### Description

set field content

#### Signature

```ts
interface setContent {
  (content: any): void
}
```

### onInit

#### Description

Trigger field initialization, no need to call manually

#### Signature

```ts
interface onInit {
  (): void
}
```

### onMount

#### Description

Trigger field mount

#### Signature

```ts
interface onMount {
  (): void
}
```

### onUnmount

#### Description

Trigger field unloading

#### Signature

```ts
interface onUnmount {
  (): void
}
```

### onInput

#### Description

Trigger field entry

#### Signature

```ts
interface onInput {
  (...args: any[]): Promise<void>
}
```

### onFocus

#### Description

Trigger field focus

#### Signature

```ts
interface onFocus {
  (...args: any[]): Promise<void>
}
```

### onBlur

#### Description

Trigger field out of focus

#### Signature

```ts
interface onBlur {
  (...args: any[]): Promise<void>
}
```

### submit

#### describe

Trigger field submission (including all sub-nodes, this API is mainly used in sub-form scenarios)

#### sign

```ts
interface submit<T> {
  (): Promise<Field['value']>
  (onSubmit?: (values: Field['value']) => Promise<T> | void): Promise<T>
}
```

### validate

#### Description

Trigger field verification(Contains all sub-nodes, this API is mainly used in sub-form scenarios)

#### Signature

```ts
interface validate {
  (triggerType?: 'onInput' | 'onFocus' | 'onBlur'): Promise<IValidateResults>
}
```

IValidateResults Reference [IValidateResults](#ivalidateresults)

### reset

#### Description

Trigger field reset(Contains all sub-nodes, this API is mainly used in sub-form scenarios), if verification is set, then the returned result is the verification result

#### Signature

```ts
interface reset {
  (options?: IFieldResetOptions): Promise<IValidateResults>
}
```

IFieldResetOptions Reference [IFieldResetOptions](#ifieldresetoptions)

IValidateResults Reference [IValidateResults](#ivalidateresults)

### query

#### Description

Query field, you can query adjacent fields based on the current field

#### Signature

```ts
interface query {
  (pattern: FormPathPattern): Query
}
```

FormPathPattern API Reference [FormPath](/api/entry/form-path#formpathpattern)

Query object API reference [Query](/api/models/query)

### queryFeedbacks

#### Description

Query the feedback information of the current field

#### Signature

```ts
interface queryFeedbacks {
  (search: ISearchFeedback): IFieldFeedback[]
}
```

ISearchFeedback Reference [ISearchFeedback](/api/models/field#isearchfeedback)

IFieldFeedback Reference [IFieldFeedback](#ifieldfeedback)

### dispose

#### Description

Release observer, no need to release manually by default

#### Signature

```ts
interface dispose {
  (): void
}
```

### destroy

#### Description

Release observer, and remove current field model

#### Signature

```ts
interface destroy {
  (): void
}
```

### match

#### Description

Match fields based on path

#### Signature

```ts
interface match {
  (pattern: FormPathPattern): boolean
}
```

FormPathPattern API Reference [FormPath](/api/entry/form-path#formpathpattern)

### inject

#### Description

Inject executable methods into field models

#### Signature

```ts
interface inject {
  (actions: Record<string, (...args: any[]) => any>): void
}
```

### invoke

#### Description

Invoke an executable method injected by the field model via inject

#### Signature

```ts
interface invoke {
  (name: string, ...args: any[]): any
}
```

## Types of

<Alert>
Note: If you want to manually consume the type, just export it directly from the package module
</Alert>

### FieldValidator

Field validator, the type is more complicated and needs to be digested carefully by the user

```ts
//String format validator
type ValidatorFormats =
  | 'url'
  | 'email'
  | 'ipv6'
  | 'ipv4'
  | 'number'
  | 'integer'
  | 'idcard'
  | 'qq'
  | 'phone'
  | 'money'
  | 'zh'
  | 'date'
  | 'zip'
  | (string & {}) //Other format validators need to be registered through registerValidateFormats

//Object type verification result
interface IValidateResult {
  type: 'error' | 'warning' | 'success' | (string & {})
  message: string
}
//Object validator
interface IValidatorRules<Context = any> {
  triggerType?: 'onInput' | 'onFocus' | 'onBlur'
  format?: ValidatorFormats
  validator?: ValidatorFunction<Context>
  required?: boolean
  pattern?: RegExp | string
  max?: number
  maximum?: number
  exclusiveMaximum?: number
  exclusiveMinimum?: number
  minimum?: number
  min?: number
  len?: number
  whitespace?: boolean
  enum?: any[]
  const?: any
  multipleOf?: number
  uniqueItems?: boolean
  maxProperties?: number
  minProperties?: number
  maxItems?: number
  maxLength?: number
  minItems?: number
  minLength?: number
  message?: string
  [key: string]: any //Other attributes need to be registered through registerValidateRules
}
//Function type validator check result type
type ValidatorFunctionResponse = null | string | boolean | IValidateResult

//Functional validator
type ValidatorFunction<Context = any> = (
  value: any,
  rule: IValidatorRules<Context>,
  ctx: Context
) => ValidatorFunctionResponse | Promise<ValidatorFunctionResponse> | null

//Non-array validator
type ValidatorDescription =
  | ValidatorFormats
  | ValidatorFunction<Context>
  | IValidatorRules<Context>

//Array type validator
type MultiValidator<Context = any> = ValidatorDescription<Context>[]

type FieldValidator<Context = any> =
  | ValidatorDescription<Context>
  | MultiValidator<Context>
```

### FieldMessage

```ts
type FieldMessage = string | JSXElement
```

If under the UI framework that supports JSX, we can directly pass the Node of JSX, otherwise, we can only pass the string

### FieldDataSource

```ts
type FieldDataSource<ValueType> = Array<{
  label: string | JSXElement
  value: ValueType
  [key: string]: any
}>
```

The field data source is actually an array. The form of the content is determined by the user, but we recommend that users express the data source in the form of label/value. It should be noted here that if it is to be used in the UI framework, it is not set directly. To be effective, the dataSource property must be bound to a specific UI component to be effective. For example, using @formily/react, if you want to bind the state, you can use the connect function, or you can directly get the field instance through useField in the component. consumption.

### FieldValue

The field value type is actually the `Any` type, but it is important to mention that if it is a mandatory array type in ArrayField, it is a mandatory object type in ObjectField.

### FieldComponent

```ts
type FieldComponent = string | JSXComponentConstructor
```

Field component, if we use it in a framework that supports JSX, FieldComponent recommends to store the JSX component reference directly, otherwise it can store a component identification string and distribute it during actual rendering.

### FieldDecorator

```ts
type FieldDecorator = string | JSXComponentConstructor
```

Field decorator, if we use it in a framework that supports JSX, FieldDecorator recommends to store the JSX component reference directly, otherwise it can store a component identification string and distribute it during actual rendering.

### FieldReaction

```ts
type FieldReaction = (field: GeneralField) => void
```

### FieldDisplayTypes

```ts
type FieldDisplayTypes = 'none' | 'hidden' | 'visible'
```

### FieldPatternTypes

```ts
type FieldPatternTypes = 'editable' | 'disabled' | 'readOnly' | 'readPretty'
```

### FieldValidateStatus

```ts
type FieldValidateStatus = 'error' | 'warning' | 'success' | 'validating'
```

### GeneralField

```ts
type GeneralField = Field | VoidField | ArrayField | ObjectField
```

VoidField Reference [VoidField](/api/models/void-field)

ArrayField Reference [ArrayField](/api/models/array-field)

ObjectField Reference [ObjectField](/api/models/object-field)

### IFieldFeedback

```ts
interface IFieldFeedback {
  triggerType?: 'onInput' | 'onFocus' | 'onBlur' //Verify the trigger type
  type?: 'error' | 'success' | 'warning' //feedback type
  code?: //Feedback code
  | 'ValidateError'
    | 'ValidateSuccess'
    | 'ValidateWarning'
    | 'EffectError'
    | 'EffectSuccess'
    | 'EffectWarning'
  messages?: string[] //Feedback message
}
```

### ISearchFeedback

```ts
interface ISearchFeedback {
  triggerType?: 'onInput' | 'onFocus' | 'onBlur' //Verify the trigger type
  type?: 'error' | 'success' | 'warning' //feedback type
  code?: //Feedback code
  | 'ValidateError'
    | 'ValidateSuccess'
    | 'ValidateWarning'
    | 'EffectError'
    | 'EffectSuccess'
    | 'EffectWarning'
  address?: FormPathPattern
  path?: FormPathPattern
  messages?: string[]
}
```

### IFieldState

```ts
interface IFieldState {
  hidden?: boolean
  visible?: boolean
  editable?: boolean
  readOnly?: boolean
  disabled?: boolean
  readPretty?: boolean
  title?: any
  description?: any
  loading?: boolean
  validating?: boolean
  modified?: boolean
  active?: boolean
  visited?: boolean
  inputValue?: FieldValue
  inputValues?: any[]
  initialized?: boolean
  dataSource?: FieldDataSource
  mounted?: boolean
  unmounted?: boolean
  validator?: FieldValidator
  decorator?: FieldDecorator
  component?: FieldComponent
  readonly parent?: GeneralField
  errors?: FieldMessage[]
  warnings?: FieldMessage[]
  successes?: FieldMessage[]
  readonly valid?: boolean
  readonly invalid?: boolean
  value?: FieldValue
  initialValue?: FieldValue
  display?: FieldDisplayTypes
  pattern?: FieldPatternTypes
  required?: boolean
  readonly validateStatus?: 'error' | 'success' | 'warning' | 'validating'
}
```

### IGeneralFieldState

```ts
type IGeneralFieldState = IFieldState & IVoidFieldState
```

IVoidFieldState Reference [IVoidFieldState](/api/models/void-field#ivoidfieldstate)

### IFieldResetOptions

```ts
interface IFieldResetOptions {
  forceClear?: boolean //Whether to force clear
  validate?: boolean //Whether to verify
}
```

### IValidateResults

```ts
interface IValidateResults {
  error?: string[]
  warning?: string[]
  success?: string[]
}
```

> Formily Typescript type convention
>
> - Simple non-object data types or Union data types use type to define the type, and cannot start with an uppercase `I` character
> - Simple object types use interface to define the type uniformly, and start with an uppercase `I` character. If there are combinations of different interfaces (Intersection or Extends), use type to define the type, and also start with an uppercase `I` character
</file>

<file path="packages/core/docs/api/models/Field.zh-CN.md">
---
order: 1
---

# Field

调用[createField](/api/models/form#createfield)所返回的 Field 模型。

以下会列出所有模型属性，如果该属性是可写的，那么我们可以直接引用是修改该属性，@formily/reactive 便会响应从而触发 UI 更新。

## 属性

| 属性           | 描述                              | 类型                                               | 是否只读 | 默认值       |
| -------------- | --------------------------------- | -------------------------------------------------- | -------- | ------------ |
| initialized    | 字段是否已被初始化                | Boolean                                            | 否       | `false`      |
| mounted        | 字段是否已挂载                    | Boolean                                            | 否       | `false`      |
| unmounted      | 字段是否已卸载                    | Boolean                                            | 否       | `false`      |
| address        | 字段节点路径                      | [FormPath](/api/entry/form-path)                   | 是       |              |
| path           | 字段数据路径                      | [FormPath](/api/entry/form-path)                   | 是       |              |
| title          | 字段标题                          | [FieldMessage](#fieldmessage)                      | 否       | `""`         |
| description    | 字段描述                          | [FieldMessage](#fieldmessage)                      | 否       | `""`         |
| loading        | 字段加载状态                      | Boolean                                            | 否       | `false`      |
| validating     | 字段是否正在校验                  | Boolean                                            | 否       | `false`      |
| modified       | 字段子树是否被手动修改过          | Boolean                                            | 否       | `false`      |
| selfModified   | 字段自身是否被手动修改过          | Boolean                                            | 否       | `false`      |
| active         | 字段是否处于激活态                | Boolean                                            | 否       | `false`      |
| visited        | 字段是否被浏览过                  | Boolean                                            | 否       | `false`      |
| inputValue     | 字段输入值                        | Any                                                | 否       | `null`       |
| inputValues    | 字段输入值集合                    | Array                                              | 否       | `[]`         |
| dataSource     | 字段数据源                        | Array                                              | 否       | `[]`         |
| validator      | 字段校验器                        | [FieldValidator](#fieldvalidator)                  | 否       | `null`       |
| decorator      | 字段装饰器                        | Any[]                                              | 否       | `null`       |
| component      | 字段组件                          | Any[]                                              | 否       | `null`       |
| feedbacks      | 字段反馈信息                      | [IFieldFeedback](#ifieldfeedback)[]                | 否       | `[]`         |
| parent         | 父级字段                          | [GeneralField](#generalfield)                      | 是       | `null`       |
| errors         | 字段汇总(包含子节点)错误消息      | [IFormFeedback](/api/models/form/#iformfeedback)[] | 是       | `[]`         |
| warnings       | 字段汇总(包含子节点)警告消息      | [IFormFeedback](/api/models/form/#iformfeedback)[] | 是       | `[]`         |
| successes      | 字段汇总(包含子节点)成功消息      | [IFormFeedback](/api/models/form/#iformfeedback)[] | 是       | `[]`         |
| valid          | 字段是否合法(包含子节点)          | Boolean                                            | 否       | `true`       |
| invalid        | 字段是否非法(包含子节点)          | Boolean                                            | 否       | `false`      |
| value          | 字段值                            | Any                                                | 否       |              |
| initialValue   | 字段默认值                        | Any                                                | 否       |              |
| display        | 字段展示状态                      | [FieldDisplayTypes](#fielddisplaytypes)            | 否       | `"visible"`  |
| pattern        | 字段交互模式                      | [FieldPatternTypes](#fieldpatterntypes)            | 否       | `"editable"` |
| required       | 字段是否必填                      | Boolean                                            | 否       | `false`      |
| hidden         | 字段是否隐藏                      | Boolean                                            | 否       | `false`      |
| visible        | 字段是否显示                      | Boolean                                            | 否       | `true`       |
| disabled       | 字段是否禁用                      | Boolean                                            | 否       | `false`      |
| readOnly       | 字段是否只读                      | Boolean                                            | 否       | `false`      |
| readPretty     | 字段是否为阅读态                  | Boolean                                            | 否       | `false`      |
| editable       | 字段是可编辑                      | Boolean                                            | 否       | `true`       |
| validateStatus | 字段校验状态                      | [FieldValidateStatus](#fieldvalidatestatus)        | 是       | `null`       |
| content        | 字段内容，一般作为子节点          | any                                                | 否       | `null`       |
| data           | 字段扩展属性                      | Object                                             | 否       | `null`       |
| selfErrors     | 字段自身错误消息                  | [FieldMessage](#fieldmessage)[]                    | 否       | `[]`         |
| selfWarnings   | 字段自身警告消息                  | [FieldMessage](#fieldmessage)[]                    | 否       | `[]`         |
| selfSuccesses  | 字段自身成功消息                  | [FieldMessage](#fieldmessage)[]                    | 否       | `[]`         |
| selfValid      | 字段自身是否合法                  | Boolean                                            | 否       | `true`       |
| selfInvalid    | 字段自身是否非法                  | Boolean                                            | 否       | `false`      |
| indexes        | 字段数字索引集合                  | Number                                             | 是       | `-`          |
| index          | 字段数字索引，取 indexes 最后一个 | Number                                             | 是       | `-`          |

#### 详细解释

**active**

触发 onFocus 为 true，触发 onBlur 为 false

**visited**

触发过 onFocus 则永远为 true

**inputValue**

触发 onInput 收集到的值

**inputValues**

触发 onInput 收集到的多参值

**hidden**

为 true 时， display 为 hidden；为 false 时 display 为 visible

**visible**

为 true 时， display 为 visible；为 false 时 display 为 none

## 方法

### setTitle

#### 描述

设置字段标题

#### 签名

```ts
interface setTitle {
  (title?: FieldMessage): void
}
```

FieldMessage 参考 [FieldMessage](#fieldmessage)

### setDescription

#### 描述

设置字段描述信息

#### 签名

```ts
interface setDescription {
  (title?: FieldMessage): void
}
```

FieldMessage 参考 [FieldMessage](#fieldmessage)

### setDataSource

#### 描述

设置字段数据源

#### 签名

```ts
interface setDataSource {
  (dataSource?: FieldDataSource): void
}
```

FieldDataSource 参考 [FieldDataSource](#fielddatasource)

### setFeedback

#### 描述

设置字段消息反馈

#### 签名

```ts
interface setFeedback {
  (feedback?: IFieldFeedback): void
}
```

IFieldFeedback 参考 [IFieldFeedback](#ifieldfeedback)

### setSelfErrors

#### 描述

设置字段自身错误消息，这里是以 EffectError 为 code 的 feedback 更新，主要是防止污染校验器结果，如果希望强制覆盖，则可以使用 setFeedback

#### 签名

```ts
interface setSelfErrors {
  (messages?: FieldMessage[]): void
}
```

### setSelfWarnings

#### 描述

设置字段自身警告信息，这里是以 EffectWarning 为 code 的 feedback 更新，主要是防止污染校验器结果，如果希望强制覆盖，则可以使用 setFeedback

#### 签名

```ts
interface setSelfWarning {
  (messages?: FieldMessage[]): void
}
```

### setSelfSuccesses

#### 描述

设置字段自身成功信息，这里是以 EffectSuccess 为 code 的 feedback 更新，主要是防止污染校验器结果，如果希望强制覆盖，则可以使用 setFeedback

#### 签名

```ts
interface setSelfSuccesses {
  (messages?: FieldMessage[]): void
}
```

### setValidator

#### 描述

设置字段校验器

#### 签名

```ts
interface setValidator {
  (validator?: FieldValidator): void
}
```

FieldValidator 参考 [FieldValidator](#fieldvalidator)

### setRequired

#### 描述

设置字段是否必填

#### 签名

```ts
interface setRequired {
  (required?: boolean): void
}
```

### setValidatorRule

#### 描述

按照规则设置字段 validator，类似于 setRequired

#### 签名

```ts
interface setValidatorRule {
  (ruleName?: string, ruleValue: any): void
}
```

### setValue

#### 描述

设置字段值

#### 签名

```ts
interface setValue {
  (value?: FieldValue): void
}
```

FieldValue 参考 [FieldValue](#fieldvalue)

### setInitialValue

#### 描述

设置字段默认值

#### 签名

```ts
interface setInitialValue {
  (initialValue?: FieldValue): void
}
```

FieldValue 参考 [FieldValue](#fieldvalue)

### setDisplay

#### 描述

设置字段展示状态

#### 签名

```ts
interface setDisplay {
  (display?: FieldDisplayTypes): void
}
```

FieldDisplayTypes 参考 [FieldDisplayTypes](#fielddisplaytypes)

### setPattern

#### 描述

设置字段交互模式

#### 签名

```ts
interface setPattern {
  (pattern?: FieldPatternTypes): void
}
```

FieldPatternTypes 参考 [FieldPatternTypes](#fieldpatterntypes)

### setLoading

#### 描述

设置字段加载状态

#### 签名

```ts
interface setLoading {
  (loading?: boolean): void
}
```

### setValidating

#### 描述

设置字段校验中状态

#### 签名

```ts
interface setValidating {
  (validating?: boolean): void
}
```

### setComponent

#### 描述

设置字段组件

#### 签名

```ts
interface setComponent {
  (component?: FieldComponent, props?: any): void
}
```

FieldComponent 参考 [FieldComponent](#fieldcomponent)

### setComponentProps

#### 描述

设置字段组件属性

#### 签名

```ts
interface setComponentProps {
  (props?: any): void
}
```

### setDecorator

#### 描述

设置字段装饰器

#### 签名

```ts
interface setDecorator {
  (decorator?: FieldDecorator, props?: any): void
}
```

FieldDecorator 参考 [FieldDecorator](#fielddecorator)

### setDecoratorProps

#### 描述

设置字段装饰器属性

#### 签名

```ts
interface setDecoratorProps {
  (props?: any): void
}
```

### setState

#### 描述

设置字段状态

#### 签名

```ts
interface setState {
  (state: IFieldState): void
  (callback: (state: IFieldState) => void): void
}
```

IFieldState 参考 [IFieldState](#ifieldstate)

### getState

#### 描述

获取字段状态

#### 签名

```ts
interface getState<T> {
  (): IFieldState
  (callback: (state: IFieldState) => T): T
}
```

IFieldState 参考 [IFieldState](#ifieldstate)

### setData

#### 描述

设置 Data 值

#### 签名

```ts
interface setData {
  (data: any): void
}
```

### setContent

#### 描述

设置 Content 值

#### 签名

```ts
interface setContent {
  (content: any): void
}
```

### onInit

#### 描述

触发字段初始化，默认不需要手动调用

#### 签名

```ts
interface onInit {
  (): void
}
```

### onMount

#### 描述

触发字段挂载

#### 签名

```ts
interface onMount {
  (): void
}
```

### onUnmount

#### 描述

触发字段卸载

#### 签名

```ts
interface onUnmount {
  (): void
}
```

### onInput

#### 描述

触发字段输入

#### 签名

```ts
interface onInput {
  (...args: any[]): Promise<void>
}
```

### onFocus

#### 描述

触发字段聚焦

#### 签名

```ts
interface onFocus {
  (...args: any[]): Promise<void>
}
```

### onBlur

#### 描述

触发字段失焦

#### 签名

```ts
interface onBlur {
  (...args: any[]): Promise<void>
}
```

### submit

#### 描述

触发字段提交(包含所有子节点，该 API 主要用于子表单场景)

#### 签名

```ts
interface submit<T> {
  (): Promise<Field['value']>
  (onSubmit?: (values: Field['value']) => Promise<T> | void): Promise<T>
}
```

### validate

#### 描述

触发字段校验(包含所有子节点，该 API 主要用于子表单场景)

#### 签名

```ts
interface validate {
  (triggerType?: 'onInput' | 'onFocus' | 'onBlur'): Promise<IValidateResults>
}
```

IValidateResults 参考 [IValidateResults](#ivalidateresults)

### reset

#### 描述

触发字段重置(包含所有子节点，该 API 主要用于子表单场景)，如果设置了校验，那么返回结果就是校验结果

#### 签名

```ts
interface reset {
  (options?: IFieldResetOptions): Promise<IValidateResults>
}
```

IFieldResetOptions 参考 [IFieldResetOptions](#ifieldresetoptions)

IValidateResults 参考 [IValidateResults](#ivalidateresults)

### query

#### 描述

查询字段，可以基于当前字段查询相邻字段

#### 签名

```ts
interface query {
  (pattern: FormPathPattern): Query
}
```

FormPathPattern API 参考 [FormPath](/api/entry/form-path#formpathpattern)

Query 对象 API 参考 [Query](/api/models/query)

### queryFeedbacks

#### 描述

查询当前字段的反馈信息

#### 签名

```ts
interface queryFeedbacks {
  (search: ISearchFeedback): IFieldFeedback[]
}
```

ISearchFeedback 参考 [ISearchFeedback](/api/models/field#isearchfeedback)

IFieldFeedback 参考[IFieldFeedback](#ifieldfeedback)

### dispose

#### 描述

释放 observer，默认不需要手动释放

#### 签名

```ts
interface dispose {
  (): void
}
```

### destroy

#### 描述

释放 observer，并删除字段模型

#### 签名

```ts
interface destroy {
  (): void
}
```

### match

#### 描述

基于路径匹配字段

#### 签名

```ts
interface match {
  (pattern: FormPathPattern): boolean
}
```

FormPathPattern API 参考 [FormPath](/api/entry/form-path#formpathpattern)

### inject

#### 描述

给字段模型注入可执行方法

#### 签名

```ts
interface inject {
  (actions: Record<string, (...args: any[]) => any>): void
}
```

### invoke

#### 描述

调用字段模型通过 inject 注入的可执行方法

#### 签名

```ts
interface invoke {
  (name: string, ...args: any[]): any
}
```

## 类型

<Alert>
注意：如果要手动消费类型，直接从包模块中导出即可
</Alert>

### FieldValidator

字段校验器，类型较为复杂，需要用户仔细消化

```ts
//字符串型格式校验器
type ValidatorFormats =
  | 'url'
  | 'email'
  | 'ipv6'
  | 'ipv4'
  | 'number'
  | 'integer'
  | 'idcard'
  | 'qq'
  | 'phone'
  | 'money'
  | 'zh'
  | 'date'
  | 'zip'
  | (string & {}) //其他格式校验器需要通过registerValidateFormats进行注册

//对象型校验结果
interface IValidateResult {
  type: 'error' | 'warning' | 'success' | (string & {})
  message: string
}
//对象型校验器
interface IValidatorRules<Context = any> {
  triggerType?: 'onInput' | 'onFocus' | 'onBlur'
  format?: ValidatorFormats
  validator?: ValidatorFunction<Context>
  required?: boolean
  pattern?: RegExp | string
  max?: number
  maximum?: number
  exclusiveMaximum?: number
  exclusiveMinimum?: number
  minimum?: number
  min?: number
  len?: number
  whitespace?: boolean
  enum?: any[]
  const?: any
  multipleOf?: number
  uniqueItems?: boolean
  maxProperties?: number
  minProperties?: number
  maxItems?: number
  maxLength?: number
  minItems?: number
  minLength?: number
  message?: string
  [key: string]: any //其他属性需要通过registerValidateRules进行注册
}
//函数型校验器校验结果类型
type ValidatorFunctionResponse = null | string | boolean | IValidateResult

//函数型校验器
type ValidatorFunction<Context = any> = (
  value: any,
  rule: IValidatorRules<Context>,
  ctx: Context
) => ValidatorFunctionResponse | Promise<ValidatorFunctionResponse> | null

//非数组型校验器
type ValidatorDescription =
  | ValidatorFormats
  | ValidatorFunction<Context>
  | IValidatorRules<Context>

//数组型校验器
type MultiValidator<Context = any> = ValidatorDescription<Context>[]

type FieldValidator<Context = any> =
  | ValidatorDescription<Context>
  | MultiValidator<Context>
```

### FieldMessage

```ts
type FieldMessage = string | JSXElement
```

如果在支持 JSX 的 UI 框架下，我们可以直接传 JSX 的 Node，否则，我们只能传字符串

### FieldDataSource

```ts
type FieldDataSource<ValueType> = Array<{
  label: string | JSXElement
  value: ValueType
  [key: string]: any
}>
```

字段数据源其实就是一个数组，内容是啥形式由用户定，只是我们推荐用户都以 label/value 形式来表达数据源，这里需要注意的是，如果要在 UI 框架中使用，不是设置了就直接能生效，dataSource 属性必须是与具体 UI 组件产生了绑定才能生效，比如使用@formily/react，想要绑定状态，可以使用 connect 函数，也可以直接在组件内通过 useField 拿到字段实例，直接消费。

### FieldValue

字段值类型其实是`Any`类型，只是需要着重提一下，如果在 ArrayField 中是强制数组类型，ObjectField 中是强制对象类型

### FieldComponent

```ts
type FieldComponent = string | JSXComponentConstructor
```

字段组件，如果我们在支持 JSX 的框架中使用，FieldComponent 推荐直接存储 JSX 组件引用，否则可以存储一个组件标识字符串，在实际渲染的时候做一次分发。

### FieldDecorator

```ts
type FieldDecorator = string | JSXComponentConstructor
```

字段装饰器，如果我们在支持 JSX 的框架中使用，FieldDecorator 推荐直接存储 JSX 组件引用，否则可以存储一个组件标识字符串，在实际渲染的时候做一次分发。

### FieldReaction

```ts
type FieldReaction = (field: GeneralField) => void
```

### FieldDisplayTypes

```ts
type FieldDisplayTypes = 'none' | 'hidden' | 'visible'
```

### FieldPatternTypes

```ts
type FieldPatternTypes = 'editable' | 'disabled' | 'readOnly' | 'readPretty'
```

### FieldValidateStatus

```ts
type FieldValidateStatus = 'error' | 'warning' | 'success' | 'validating'
```

### GeneralField

```ts
type GeneralField = Field | VoidField | ArrayField | ObjectField
```

VoidField 参考 [VoidField](/api/models/void-field)

ArrayField 参考 [ArrayField](/api/models/array-field)

ObjectField 参考 [ObjectField](/api/models/object-field)

### IFieldFeedback

```ts
interface IFieldFeedback {
  triggerType?: 'onInput' | 'onFocus' | 'onBlur' //校验触发类型
  type?: 'error' | 'success' | 'warning' //反馈类型
  code?: //反馈编码
  | 'ValidateError'
    | 'ValidateSuccess'
    | 'ValidateWarning'
    | 'EffectError'
    | 'EffectSuccess'
    | 'EffectWarning'
  messages?: string[] //反馈消息
}
```

### ISearchFeedback

```ts
interface ISearchFeedback {
  triggerType?: 'onInput' | 'onFocus' | 'onBlur' //校验触发类型
  type?: 'error' | 'success' | 'warning' //反馈类型
  code?: //反馈编码
  | 'ValidateError'
    | 'ValidateSuccess'
    | 'ValidateWarning'
    | 'EffectError'
    | 'EffectSuccess'
    | 'EffectWarning'
  address?: FormPathPattern
  path?: FormPathPattern
  messages?: string[]
}
```

### IFieldState

```ts
interface IFieldState {
  hidden?: boolean
  visible?: boolean
  editable?: boolean
  readOnly?: boolean
  disabled?: boolean
  readPretty?: boolean
  title?: any
  description?: any
  loading?: boolean
  validating?: boolean
  modified?: boolean
  active?: boolean
  visited?: boolean
  inputValue?: FieldValue
  inputValues?: any[]
  initialized?: boolean
  dataSource?: FieldDataSource
  mounted?: boolean
  unmounted?: boolean
  validator?: FieldValidator
  decorator?: FieldDecorator
  component?: FieldComponent
  readonly parent?: GeneralField
  errors?: FieldMessage[]
  warnings?: FieldMessage[]
  successes?: FieldMessage[]
  readonly valid?: boolean
  readonly invalid?: boolean
  value?: FieldValue
  initialValue?: FieldValue
  display?: FieldDisplayTypes
  pattern?: FieldPatternTypes
  required?: boolean
  readonly validateStatus?: 'error' | 'success' | 'warning' | 'validating'
}
```

### IGeneralFieldState

```ts
type IGeneralFieldState = IFieldState & IVoidFieldState
```

IVoidFieldState 参考 [IVoidFieldState](/api/models/void-field#ivoidfieldstate)

### IFieldResetOptions

```ts
interface IFieldResetOptions {
  forceClear?: boolean //是否强制清除
  validate?: boolean //是否校验
}
```

### IValidateResults

```ts
interface IValidateResults {
  error?: string[]
  warning?: string[]
  success?: string[]
}
```

> Formily Typescript 类型约定
>
> - 简单非对象数据类型或 Union 数据类型用 type 定义类型，不能以大写`I`字符开头
> - 简单对象类型统一用 interface 定义类型，且以大写`I`字符开头，如果存在不同 interface 的组合(Intersection or Extends)使用 type 定义类型，同样以大写`I`字符开头
</file>

<file path="packages/core/docs/api/models/Form.md">
---
order: 0
---

# Form

Call the core [Form Model](/guide/form) API returned by [createForm](/api/entry/create-form), the following will list all model attributes, if the attribute is writable, then we can directly The reference is to modify the attribute, and @formily/reactive will respond to trigger the UI update.

## Attributes

| Property      | Description                                       | Type                                  | Read-only or not | Default value     |
| ------------- | ------------------------------------------------- | ------------------------------------- | ---------------- | ----------------- |
| initialized   | Whether the form is initialized                   | Boolean                               | No               | `false`           |
| validating    | Is the form being validated                       | Boolean                               | No               | `false`           |
| submitting    | Is the form being submitted                       | Boolean                               | No               | `false`           |
| modified      | Whether the form value has been manually modified | Boolean                               | No               | `false`           |
| pattern       | Form interaction mode                             | [FormPatternTypes](#formpatterntypes) | No               | `"editable"`      |
| display       | Form display form                                 | [FormDisplayTypes](#formdisplaytypes) | No               | `"visible"`       |
| mounted       | Is the form mounted                               | Boolean                               | No               | `false`           |
| unmounted     | Is the form unmounted                             | Boolean                               | No               | `false`           |
| values        | form values                                       | Object                                | No               | `{}`              |
| initialValues | Form default values                               | Object                                | No               | `{}`              |
| valid         | Is the form valid                                 | Boolean                               | Yes              | `true`            |
| invalid       | Is the form illegal                               | Boolean                               | Yes              | `false`           |
| errors        | Form validation error message                     | [IFormFeedback](#iformfeedback)[]     | Yes              | `[]`              |
| warnings      | Form verification warning message                 | [IFormFeedback](#iformfeedback)[]     | Yes              | `[]`              |
| successes     | Form verification success message                 | [IFormFeedback](#iformfeedback)[]     | Yes              | `[]`              |
| hidden        | Whether the form is hidden                        | Boolean                               | No               | `false`           |
| visible       | Whether the form is displayed                     | Boolean                               | No               | `true`            |
| editable      | Is the form editable                              | Boolean                               | No               | `true`            |
| readOnly      | Is the form read-only                             | Boolean                               | No               | `false`           |
| disabled      | Whether the form is disabled                      | Boolean                               | No               | `false`           |
| readPretty    | Is the form in a read state                       | Boolean                               | No               | `false`           |
| id            | Form ID                                           | String                                | No               | `{RANDOM_STRING}` |
| displayName   | Model label                                       | String                                | No               | `"Form"`          |

## Method

### createField

#### Description

Create a factory function for a Field instance. If the path is the same and called multiple times, the instance object will be reused

#### Signature

```ts
interface createField {
  (props: IFieldFactoryProps): Field
}
```

For function entry, please refer to [IFieldFactoryProps](#ifieldfactoryprops)

### createArrayField

#### Description

A factory function for creating an ArrayField instance. If the path is the same and called multiple times, the instance object will be reused

#### Signature

```ts
interface createArrayField {
  (props: IFieldFactoryProps): ArrayField
}
```

For function entry, please refer to [IFieldFactoryProps](#ifieldfactoryprops)

### createObjectField

#### Description

A factory function to create an ObjectField instance. If the path is the same and called multiple times, it will reuse the instance object

#### Signature

```ts
interface createObjectField {
  (props: IFieldFactoryProps): ArrayField
}
```

For function entry, please refer to [IFieldFactoryProps](#ifieldfactoryprops)

### createVoidField

#### Description

A factory function to create a VoidField instance. If the path is the same and called multiple times, the instance object will be reused

#### Signature

```ts
interface createVoidField {
  (props: IVoidFieldFactoryProps): ArrayField
}
```

For function entry, please refer to [IVoidFieldFactoryProps](#ivoidfieldfactoryprops)

### setValues

#### Description

Set the form value, you can set the merge strategy [IFormMergeStrategy](#iformmergestrategy)

#### Signature

```ts
interface setValues {
  (values: object, strategy: IFormMergeStrategy = 'merge'): void
}
```

### setInitialValues

#### Description

Set the default value of the form, you can set the merge strategy

#### Signature

```ts
interface setInitialValues {
  (initialValues: object, strategy: IFormMergeStrategy = 'merge'): void
}
```

### setValuesIn

#### Description

Precisely set form values

#### Signature

```ts
interface setValuesIn {
  (path: FormPathPattern, value: any): void
}
```

FormPathPattern API Reference [FormPath](/api/entry/form-path#formpathpattern)

### setInitialValuesIn

#### Description

Precisely set the form default value

#### Signature

```ts
interface setInitialValuesIn {
  (path: FormPathPattern, initialValue: any): void
}
```

FormPathPattern API Reference [FormPath](/api/entry/form-path#formpathpattern)

### existValuesIn

#### Description

Determine whether the value exists according to the specified path

#### Signature

```ts
interface existValuesIn {
  (path: FormPathPattern): boolean
}
```

FormPathPattern API Reference [FormPath](/api/entry/form-path#formpathpattern)

### existInitialValuesIn

#### Description

Determine whether the default value exists according to the specified path

#### Signature

```ts
interface existInitialValuesIn {
  (path: FormPathPattern): boolean
}
```

FormPathPattern API Reference [FormPath](/api/entry/form-path#formpathpattern)

### getValuesIn

#### Description

Get the form value according to the specified path

#### Signature

```ts
interface getValuesIn {
  (path: FormPathPattern): any
}
```

FormPathPattern API Reference [FormPath](/api/entry/form-path#formpathpattern)

### getInitialValuesIn

#### Description

Get the default value of the form according to the specified path

#### Signature

```ts
interface getInitialValuesIn {
  (path: FormPathPattern): any
}
```

FormPathPattern API Reference [FormPath](/api/entry/form-path#formpathpattern)

### deleteValuesIn

#### Description

Delete the form value according to the specified path

#### Signature

```ts
interface deleteValuesIn {
  (path: FormPathPattern): void
}
```

FormPathPattern API Reference [FormPath](/api/entry/form-path#formpathpattern)

### deleteInitialValuesIn

#### Description

Delete the default value of the form according to the specified path

#### Signature

```ts
interface deleteInitialValuesIn {
  (path: FormPathPattern): void
}
```

FormPathPattern API Reference [FormPath](/api/entry/form-path#formpathpattern)

### setSubmitting

#### Description

Set whether the form is being submitted

#### Signature

```ts
interface setSubmitting {
  (submitting: boolean): void
}
```

### setValidating

#### Description

Set whether the form is verifying status

#### Signature

```ts
interface setValidating {
  (validating: boolean): void
}
```

### setDisplay

#### Description

Set form display status

#### Signature

```ts
interface setDisplay {
  (display: FormDisplayTypes): void
}
```

For function entry, please refer to [FormDisplayTypes](#formdisplaytypes)

### setPattern

#### Description

Set the form interaction mode

#### Signature

```ts
interface setPattern {
  (pattern: FormPatternTypes): void
}
```

For function entry, please refer to [FormPatternTypes](#formpatterntypes)

### addEffects

#### Description

Add side effects

#### Signature

```ts
interface addEffects {
  (id: string, effects: (form: Form) => void): void
}
```

### removeEffects

#### Description

Remove side effects, the id is consistent with the id of addEffects

#### Signature

```ts
interface removeEffects {
  (id: string): void
}
```

### setEffects

#### Description

Overwrite update side effects

#### Signature

```ts
interface setEffects {
  (effects: (form: Form) => void): void
}
```

### clearErrors

#### Description

Clear error message

#### Signature

```ts
interface clearErrors {
  (pattern?: FormPathPattern): void
}
```

FormPathPattern API Reference [FormPath](/api/entry/form-path#formpathpattern)

### clearWarnings

#### Description

Clear warning message

#### Signature

```ts
interface clearWarnings {
  (pattern?: FormPathPattern): void
}
```

FormPathPattern API Reference [FormPath](/api/entry/form-path#formpathpattern)

### clearSuccesses

#### Description

Clear success message

#### Signature

```ts
interface clearSuccesses {
  (pattern?: FormPathPattern): void
}
```

FormPathPattern API Reference [FormPath](/api/entry/form-path#formpathpattern)

### query

#### Description

Query field node

#### Signature

```ts
interface query {
  (pattern: FormPathPattern): Query
}
```

FormPathPattern API Reference [FormPath](/api/entry/form-path#formpathpattern)

Query object API reference [Query](/api/models/query)

### queryFeedbacks

#### Description

Query message feedback

#### Signature

```ts
interface queryFeedbacks {
  (search: ISearchFeedback): IFormFeedback[]
}
```

ISearchFeedback Reference [ISearchFeedback](/api/models/field#isearchfeedback)

IFormFeedback Reference [IFormFeedback](#iformfeedback)

### notify

#### Description

Broadcast message

#### Signature

```ts
interface notify<T> {
  (type?: string, payload: T): void
}
```

### subscribe

#### Description

Subscribe to news

#### Signature

```ts
interface subscribe<T> {
  (callback: (payload: T) => void): number
}
```

### unsubscribe

#### Description

unsubscribe

#### Signature

```ts
interface unsubscribe {
  (id: number): void
}
```

### onInit

#### Description

Trigger form initialization, no need to manually call by default

#### Signature

```ts
interface onInit {
  (): void
}
```

### onMount

#### Description

Trigger mount

#### Signature

```ts
interface onMount {
  (): void
}
```

### onUnmount

#### Description

Trigger offload

#### Signature

```ts
interface onUnmount {
  (): void
}
```

### setState

#### Description

Set form status

#### Signature

```ts
interface setState {
  (callback: (state: IFormState) => void): void
  (state: IFormState): void
}
```

IFormState Reference [IFormState](#iformstate)

### getState

#### Description

Get form status

#### Signature

```ts
interface getState<T> {
  (): IFormState
  (callback: (state: IFormState) => T): T
}
```

IFormState Reference [IFormState](#iformstate)

### setFormState

Consistent with setState API

### getFormState

Consistent with getState API

### setFieldState

#### Description

Set field status

#### Signature

```ts
interface setFieldState {
  (pattern: FormPathPattern, setter: (state: IGeneralFieldState) => void): void
  (pattern: FormPathPattern, setter: IGeneralFieldState): void
}
```

FormPathPattern API Reference [FormPath](/api/entry/form-path#formpathpattern)

IGeneralFieldState Reference [IGeneralFieldState](/api/models/field/#igeneralfieldstate)

### getFieldState

#### Description

Get field status

#### Signature

```ts
interface getFieldState<T> {
  (pattern: FormPathPattern): IGeneralFieldState
  (pattern: FormPathPattern, callback: (state: IGeneralFieldState) => T): T
}
```

FormPathPattern API Reference [FormPath](/api/entry/form-path#formpathpattern)

IGeneralFieldState Reference [IGeneralFieldState](/api/models/field/#igeneralfieldstate)

### getFormGraph

#### Description

Get form field set

#### Signature

```ts
interface getFormGraph {
  (): {
    [key: string]: GeneralFieldState | FormState
  }
}
```

### setFormGraph

#### Description

Set the form field set

#### Signature

```ts
interface setFormGraph {
  (graph: { [key: string]: GeneralFieldState | FormState }): void
}
```

### clearFormGraph

#### Description

Clear the field set

#### Signature

```ts
interface clearFormGraph {
  (pattern: FormPathPattern): void
}
```

### validate

#### Description

The form verification trigger can be verified according to the specified path. If the verification is successful, there will be no return, and the verification failure will be returned in the promise reject [IFormFeedback](#iformfeedback)[]

#### Signature

```ts
interface validate {
  (pattern: FormPathPattern): Promise<void>
}
```

### submit

#### Description

In the form submission method, if the Promise is returned in the onSubmit callback function, the form will set the submitting status to true at the beginning of the submission, and then set it to false when the Promise resolves. The view layer can consume the submitting status to prevent repeated submissions.

#### Signature

```ts
interface submit<T> {
  (): Promise<Form['values']>
  (onSubmit?: (values: Form['values']) => Promise<T> | void): Promise<T>
}
```

### reset

#### Description

Form reset method, you can specify the specific field to be reset, or you can specify automatic verification when reset

#### Description

```ts
interface reset {
  (pattern: FormPathPattern, options?: IFieldResetOptions): Promise<void>
}
```

FormPathPattern API Reference [FormPath](/api/entry/form-path#formpathpattern)

IFieldResetOptions Reference [IFieldResetOptions](/api/models/field/#ifieldresetoptions)

## Types of

<Alert>
Note: If you want to manually consume the type, just export it directly from the package module
</Alert>

### FormPatternTypes

```ts
type FormPatternTypes = 'editable' | 'disabled' | 'readOnly' | 'readPretty'
```

### FormDisplayTypes

```ts
type FormDisplayTypes = 'none' | 'hidden' | 'visible'
```

### IFormFeedback

```ts
interface IFormFeedback {
  path?: string //Check field data path
  address?: string //The absolute path of the verification field
  triggerType?: 'onInput' | 'onFocus' | 'onBlur' //Verify the trigger type
  type?: 'error' | 'success' | 'warning' //feedback type
  code?: //Feedback code
  | 'ValidateError'
    | 'ValidateSuccess'
    | 'ValidateWarning'
    | 'EffectError'
    | 'EffectSuccess'
    | 'EffectWarning'
  messages?: string[] //Feedback message
}
```

### IFormState

```ts
interface IFormState {
  editable?: boolean
  readOnly?: boolean
  disabled?: boolean
  readPretty?: boolean
  hidden?: boolean
  visible?: boolean
  initialized?: boolean
  validating?: boolean
  submitting?: boolean
  modified?: boolean
  pattern?: FormPatternTypes
  display?: FormDisplayTypes
  values?: any
  initialValues?: any
  mounted?: boolean
  unmounted?: boolean
  readonly valid?: boolean
  readonly invalid?: boolean
  readonly errors?: IFormFeedback[]
  readonly warnings?: IFormFeedback[]
  readonly successes?: IFormFeedback[]
}
```

### IFormMergeStrategy

```ts
type IFormMergeStrategy = 'overwrite' | 'merge' | 'deepMerge' | 'shallowMerge'
```

### IFieldFactoryProps

```ts
interface IFieldFactoryProps {
  name: FormPathPattern //Field name, the path name of the current node
  basePath?: FormPathPattern //base path
  title?: string | JSXElement //Field title
  description?: string | JSXElement //Field description
  value?: any //Field value
  initialValue?: any //Field default value
  required?: boolean //Is the field required
  display?: 'none' | 'hidden' | 'visible' //Field display form
  pattern?: 'editable' | 'disabled' | 'readOnly' | 'readPretty' //Field interaction mode
  hidden?: boolean //whether the field is hidden
  visible?: boolean //Whether the field is displayed
  editable?: boolean //Is the field editable
  disabled?: boolean //Whether the field is disabled
  readOnly?: boolean //Is the field read-only
  readPretty?: boolean //Whether the field is in the read state
  dataSource?: any[] //Field data source
  validateFirst?: boolean //Does the field verification only verify the first illegal rule?
  validatePattern?: ('editable' | 'disabled' | 'readOnly' | 'readPretty')[] // Which patterns the validator can run in
  validateDisplay?: ('none' | 'hidden' | 'visible')[] // Which displays the validator can run in
  validator?: FieldValidator //Field validator
  decorator?: any[] //Field decorator, the first element represents the component reference, the second element represents the component attribute
  component?: any[] //Field component, the first element represents the component reference, the second element represents the component attribute
  reactions?: FieldReaction[] | FieldReaction //Field responder
}
```

FormPathPattern API Reference [FormPath](/api/entry/form-path#formpathpattern)

FieldValidator Reference [FieldValidator](/api/models/field#fieldvalidator)

FieldReaction Reference [FieldReaction](/api/models/field#fieldreaction)

### IVoidFieldFactoryProps

```ts
interface IFieldFactoryProps {
  name: FormPathPattern //Field name, the path name of the current node
  basePath?: FormPathPattern //base path
  title?: string | JSXElement //Field title
  description?: string | JSXElement //Field description
  required?: boolean //Is the field required
  display?: 'none' | 'hidden' | 'visible' //Field display form
  pattern?: 'editable' | 'disabled' | 'readOnly' | 'readPretty' //Field interaction mode
  hidden?: boolean //whether the field is hidden
  visible?: boolean //Whether the field is displayed
  editable?: boolean //Is the field editable
  disabled?: boolean //Whether the field is disabled
  readOnly?: boolean //Is the field read-only
  readPretty?: boolean //Whether the field is in the read state
  decorator?: any[] //Field decorator, the first element represents the component reference, the second element represents the component attribute
  component?: any[] //Field component, the first element represents the component reference, the second element represents the component attribute
  reactions?: FieldReaction[] | FieldReaction //Field responder
}
```

FormPathPattern API Reference [FormPath](/api/entry/form-path#formpathpattern)

FieldReaction Reference [FieldReaction](/api/models/field#fieldreaction)

> Formily Typescript type convention
>
> - Simple non-object data types or Union data types use type to define the type, and cannot start with an uppercase `I` character
> - Simple object types use interface to define the type uniformly, and start with an uppercase `I` character. If there are combinations of different interfaces (Intersection or Extends), use type to define the type, and also start with an uppercase `I` character
</file>

<file path="packages/core/docs/api/models/Form.zh-CN.md">
---
order: 0
---

# Form

调用[createForm](/zh-CN/api/entry/create-form)所返回的核心[表单模型](/zh-CN/guide/form) API，以下会列出所有模型属性，如果该属性是可写的，那么我们可以直接引用是修改该属性，@formily/reactive 便会响应从而触发 UI 更新。

## 属性

| 属性          | 描述                   | 类型                                  | 是否只读 | 默认值            |
| ------------- | ---------------------- | ------------------------------------- | -------- | ----------------- |
| initialized   | 表单是否初始化         | Boolean                               | 否       | `false`           |
| validating    | 表单是否正在校验       | Boolean                               | 否       | `false`           |
| submitting    | 表单是否正在提交       | Boolean                               | 否       | `false`           |
| modified      | 表单值是否已被手动修改 | Boolean                               | 否       | `false`           |
| pattern       | 表单交互模式           | [FormPatternTypes](#formpatterntypes) | 否       | `"editable"`      |
| display       | 表单展示形态           | [FormDisplayTypes](#formdisplaytypes) | 否       | `"visible"`       |
| mounted       | 表单是否已挂载         | Boolean                               | 否       | `false`           |
| unmounted     | 表单是否已卸载         | Boolean                               | 否       | `false`           |
| values        | 表单值                 | Object                                | 否       | `{}`              |
| initialValues | 表单默认值             | Object                                | 否       | `{}`              |
| valid         | 表单是否合法           | Boolean                               | 是       | `true`            |
| invalid       | 表单是否非法           | Boolean                               | 是       | `false`           |
| errors        | 表单校验错误消息       | [IFormFeedback](#iformfeedback)[]     | 是       | `[]`              |
| warnings      | 表单校验警告消息       | [IFormFeedback](#iformfeedback)[]     | 是       | `[]`              |
| successes     | 表单校验成功消息       | [IFormFeedback](#iformfeedback)[]     | 是       | `[]`              |
| hidden        | 表单是否隐藏           | Boolean                               | 否       | `false`           |
| visible       | 表单是否显示           | Boolean                               | 否       | `true`            |
| editable      | 表单是否可编辑         | Boolean                               | 否       | `true`            |
| readOnly      | 表单是否只读           | Boolean                               | 否       | `false`           |
| disabled      | 表单是否禁用           | Boolean                               | 否       | `false`           |
| readPretty    | 表单是否为阅读态       | Boolean                               | 否       | `false`           |
| id            | 表单 ID                | String                                | 否       | `{RANDOM_STRING}` |
| displayName   | 模型标签               | String                                | 否       | `"Form"`          |

## 方法

### createField

#### 描述

创建一个 Field 实例的工厂函数，如果路径相同，多次调用，会复用实例对象

#### 签名

```ts
interface createField {
  (props: IFieldFactoryProps): Field
}
```

函数入参请参考[IFieldFactoryProps](#ifieldfactoryprops)

### createArrayField

#### 描述

创建一个 ArrayField 实例的工厂函数，如果路径相同，多次调用，会复用实例对象

#### 签名

```ts
interface createArrayField {
  (props: IFieldFactoryProps): ArrayField
}
```

函数入参请参考[IFieldFactoryProps](#ifieldfactoryprops)

### createObjectField

#### 描述

创建一个 ObjectField 实例的工厂函数，如果路径相同，多次调用，会复用实例对象

#### 签名

```ts
interface createObjectField {
  (props: IFieldFactoryProps): ArrayField
}
```

函数入参请参考[IFieldFactoryProps](#ifieldfactoryprops)

### createVoidField

#### 描述

创建一个 VoidField 实例的工厂函数，如果路径相同，多次调用，会复用实例对象

#### 签名

```ts
interface createVoidField {
  (props: IVoidFieldFactoryProps): ArrayField
}
```

函数入参请参考[IVoidFieldFactoryProps](#ivoidfieldfactoryprops)

### setValues

#### 描述

设置表单值，可以设置合并策略 [IFormMergeStrategy](#iformmergestrategy)

#### 签名

```ts
interface setValues {
  (values: object, strategy: IFormMergeStrategy = 'merge'): void
}
```

### setInitialValues

#### 描述

设置表单默认值，可以设置合并策略

#### 签名

```ts
interface setInitialValues {
  (initialValues: object, strategy: IFormMergeStrategy = 'merge'): void
}
```

### setValuesIn

#### 描述

精确设置表单值

#### 签名

```ts
interface setValuesIn {
  (path: FormPathPattern, value: any): void
}
```

FormPathPattern API 参考 [FormPath](/zh-CN/api/entry/form-path#formpathpattern)

### setInitialValuesIn

#### 描述

精确设置表单默认值

#### 签名

```ts
interface setInitialValuesIn {
  (path: FormPathPattern, initialValue: any): void
}
```

FormPathPattern API 参考 [FormPath](/zh-CN/api/entry/form-path#formpathpattern)

### existValuesIn

#### 描述

根据指定路径判断值是否存在

#### 签名

```ts
interface existValuesIn {
  (path: FormPathPattern): boolean
}
```

FormPathPattern API 参考 [FormPath](/zh-CN/api/entry/form-path#formpathpattern)

### existInitialValuesIn

#### 描述

根据指定路径判断默认值是否存在

#### 签名

```ts
interface existInitialValuesIn {
  (path: FormPathPattern): boolean
}
```

FormPathPattern API 参考 [FormPath](/zh-CN/api/entry/form-path#formpathpattern)

### getValuesIn

#### 描述

根据指定路径获取表单值

#### 签名

```ts
interface getValuesIn {
  (path: FormPathPattern): any
}
```

FormPathPattern API 参考 [FormPath](/zh-CN/api/entry/form-path#formpathpattern)

### getInitialValuesIn

#### 描述

根据指定路径获取表单默认值

#### 签名

```ts
interface getInitialValuesIn {
  (path: FormPathPattern): any
}
```

FormPathPattern API 参考 [FormPath](/zh-CN/api/entry/form-path#formpathpattern)

### deleteValuesIn

#### 描述

根据指定路径删除表单值

#### 签名

```ts
interface deleteValuesIn {
  (path: FormPathPattern): void
}
```

FormPathPattern API 参考 [FormPath](/zh-CN/api/entry/form-path#formpathpattern)

### deleteInitialValuesIn

#### 描述

根据指定路径删除表单默认值

#### 签名

```ts
interface deleteInitialValuesIn {
  (path: FormPathPattern): void
}
```

FormPathPattern API 参考 [FormPath](/zh-CN/api/entry/form-path#formpathpattern)

### setSubmitting

#### 描述

设置表单是否正在提交状态

#### 签名

```ts
interface setSubmitting {
  (submitting: boolean): void
}
```

### setValidating

#### 描述

设置表单是否正在校验状态

#### 签名

```ts
interface setValidating {
  (validating: boolean): void
}
```

### setDisplay

#### 描述

设置表单展示状态

#### 签名

```ts
interface setDisplay {
  (display: FormDisplayTypes): void
}
```

函数入参请参考[FormDisplayTypes](#formdisplaytypes)

### setPattern

#### 描述

设置表单交互模式

#### 签名

```ts
interface setPattern {
  (pattern: FormPatternTypes): void
}
```

函数入参请参考[FormPatternTypes](#formpatterntypes)

### addEffects

#### 描述

添加副作用

#### 签名

```ts
interface addEffects {
  (id: string, effects: (form: Form) => void): void
}
```

### removeEffects

#### 描述

移除副作用，id 与 addEffects 的 id 保持一致

#### 签名

```ts
interface removeEffects {
  (id: string): void
}
```

### setEffects

#### 描述

覆盖式更新副作用

#### 签名

```ts
interface setEffects {
  (effects: (form: Form) => void): void
}
```

### clearErrors

#### 描述

清空错误消息

#### 签名

```ts
interface clearErrors {
  (pattern?: FormPathPattern): void
}
```

FormPathPattern API 参考 [FormPath](/zh-CN/api/entry/form-path#formpathpattern)

### clearWarnings

#### 描述

清空警告消息

#### 签名

```ts
interface clearWarnings {
  (pattern?: FormPathPattern): void
}
```

FormPathPattern API 参考 [FormPath](/zh-CN/api/entry/form-path#formpathpattern)

### clearSuccesses

#### 描述

清空成功消息

#### 签名

```ts
interface clearSuccesses {
  (pattern?: FormPathPattern): void
}
```

FormPathPattern API 参考 [FormPath](/zh-CN/api/entry/form-path#formpathpattern)

### query

#### 描述

查询字段节点

#### 签名

```ts
interface query {
  (pattern: FormPathPattern): Query
}
```

FormPathPattern API 参考 [FormPath](/zh-CN/api/entry/form-path#formpathpattern)

Query 对象 API 参考 [Query](/zh-CN/api/models/query)

### queryFeedbacks

#### 描述

查询消息反馈

#### 签名

```ts
interface queryFeedbacks {
  (search: ISearchFeedback): IFormFeedback[]
}
```

ISearchFeedback 参考 [ISearchFeedback](/zh-CN/api/models/field#isearchfeedback)

IFormFeedback 参考[IFormFeedback](#iformfeedback)

### notify

#### 描述

广播消息

#### 签名

```ts
interface notify<T> {
  (type?: string, payload: T): void
}
```

### subscribe

#### 描述

订阅消息

#### 签名

```ts
interface subscribe<T> {
  (callback: (payload: T) => void): number
}
```

### unsubscribe

#### 描述

取消订阅

#### 签名

```ts
interface unsubscribe {
  (id: number): void
}
```

### onInit

#### 描述

触发表单初始化，默认不需要手动调用

#### 签名

```ts
interface onInit {
  (): void
}
```

### onMount

#### 描述

触发挂载

#### 签名

```ts
interface onMount {
  (): void
}
```

### onUnmount

#### 描述

触发卸载

#### 签名

```ts
interface onUnmount {
  (): void
}
```

### setState

#### 描述

设置表单状态

#### 签名

```ts
interface setState {
  (callback: (state: IFormState) => void): void
  (state: IFormState): void
}
```

IFormState 参考 [IFormState](#iformstate)

### getState

#### 描述

获取表单状态

#### 签名

```ts
interface getState<T> {
  (): IFormState
  (callback: (state: IFormState) => T): T
}
```

IFormState 参考 [IFormState](#iformstate)

### setFormState

与 setState API 一致

### getFormState

与 getState API 一致

### setFieldState

#### 描述

设置字段状态

#### 签名

```ts
interface setFieldState {
  (pattern: FormPathPattern, setter: (state: IGeneralFieldState) => void): void
  (pattern: FormPathPattern, setter: IGeneralFieldState): void
}
```

FormPathPattern API 参考 [FormPath](/zh-CN/api/entry/form-path#formpathpattern)

IGeneralFieldState 参考 [IGeneralFieldState](/zh-CN/api/models/field/#igeneralfieldstate)

### getFieldState

#### 描述

获取字段状态

#### 签名

```ts
interface getFieldState<T> {
  (pattern: FormPathPattern): IGeneralFieldState
  (pattern: FormPathPattern, callback: (state: IGeneralFieldState) => T): T
}
```

FormPathPattern API 参考 [FormPath](/zh-CN/api/entry/form-path#formpathpattern)

IGeneralFieldState 参考 [IGeneralFieldState](/zh-CN/api/models/field/#igeneralfieldstate)

### getFormGraph

#### 描述

获取表单字段集

#### 签名

```ts
interface getFormGraph {
  (): {
    [key: string]: GeneralFieldState | FormState
  }
}
```

### setFormGraph

#### 描述

设置表单字段集

#### 签名

```ts
interface setFormGraph {
  (graph: { [key: string]: GeneralFieldState | FormState }): void
}
```

### clearFormGraph

#### 描述

清空字段集

#### 签名

```ts
interface clearFormGraph {
  (pattern: FormPathPattern): void
}
```

### validate

#### 描述

表单校验触发器，可以按照指定路径校验，如果校验成功是不会有任何返回，校验失败会在 promise reject 中返回[IFormFeedback](#iformfeedback)[]

#### 签名

```ts
interface validate {
  (pattern: FormPathPattern): Promise<void>
}
```

### submit

#### 描述

表单提交方法，如果在 onSubmit 回调函数中返回 Promise，表单会在提交开始的时候设置 submitting 状态为 true，Promise resolve 的时候再设置为 false，视图层可以消费 submitting 状态来实现防重复提交

#### 签名

```ts
interface submit<T> {
  (): Promise<Form['values']>
  (onSubmit?: (values: Form['values']) => Promise<T> | void): Promise<T>
}
```

### reset

#### 描述

表单重置方法，可以指定重置具体字段，也可以指定重置时自动校验

#### 描述

```ts
interface reset {
  (pattern: FormPathPattern, options?: IFieldResetOptions): Promise<void>
}
```

FormPathPattern API 参考 [FormPath](/zh-CN/api/entry/form-path#formpathpattern)

IFieldResetOptions 参考 [IFieldResetOptions](/zh-CN/api/models/field/#ifieldresetoptions)

## 类型

<Alert>
注意：如果要手动消费类型，直接从包模块中导出即可
</Alert>

### FormPatternTypes

```ts
type FormPatternTypes = 'editable' | 'disabled' | 'readOnly' | 'readPretty'
```

### FormDisplayTypes

```ts
type FormDisplayTypes = 'none' | 'hidden' | 'visible'
```

### IFormFeedback

```ts
interface IFormFeedback {
  path?: string //校验字段数据路径
  address?: string //校验字段绝对路径
  triggerType?: 'onInput' | 'onFocus' | 'onBlur' //校验触发类型
  type?: 'error' | 'success' | 'warning' //反馈类型
  code?: //反馈编码
  | 'ValidateError'
    | 'ValidateSuccess'
    | 'ValidateWarning'
    | 'EffectError'
    | 'EffectSuccess'
    | 'EffectWarning'
  messages?: string[] //反馈消息
}
```

### IFormState

```ts
interface IFormState {
  editable?: boolean
  readOnly?: boolean
  disabled?: boolean
  readPretty?: boolean
  hidden?: boolean
  visible?: boolean
  initialized?: boolean
  validating?: boolean
  submitting?: boolean
  modified?: boolean
  pattern?: FormPatternTypes
  display?: FormDisplayTypes
  values?: any
  initialValues?: any
  mounted?: boolean
  unmounted?: boolean
  readonly valid?: boolean
  readonly invalid?: boolean
  readonly errors?: IFormFeedback[]
  readonly warnings?: IFormFeedback[]
  readonly successes?: IFormFeedback[]
}
```

### IFormMergeStrategy

```ts
type IFormMergeStrategy = 'overwrite' | 'merge' | 'deepMerge' | 'shallowMerge'
```

### IFieldFactoryProps

```ts
interface IFieldFactoryProps {
  name: FormPathPattern //字段名称，当前节点的路径名称
  basePath?: FormPathPattern //基础路径
  title?: string | JSXElement //字段标题
  description?: string | JSXElement //字段描述
  value?: any //字段值
  initialValue?: any //字段默认值
  required?: boolean //字段是否必填
  display?: 'none' | 'hidden' | 'visible' //字段展示形式
  pattern?: 'editable' | 'disabled' | 'readOnly' | 'readPretty' //字段交互模式
  hidden?: boolean //字段是否隐藏
  visible?: boolean //字段是否显示
  editable?: boolean //字段是否可编辑
  disabled?: boolean //字段是否禁用
  readOnly?: boolean //字段是否只读
  readPretty?: boolean //字段是否为阅读态
  dataSource?: any[] //字段数据源
  validateFirst?: boolean //字段校验是否只校验第一个非法规则
  validatePattern?: ('editable' | 'disabled' | 'readOnly' | 'readPretty')[] // validator 可以在哪些 pattern 下运行
  validateDisplay?: ('none' | 'hidden' | 'visible')[] // validator 可以在哪些 display 下运行
  validator?: FieldValidator //字段校验器
  decorator?: any[] //字段装饰器，第一个元素代表组件引用，第二个元素代表组件属性
  component?: any[] //字段组件，第一个元素代表组件引用，第二个元素代表组件属性
  reactions?: FieldReaction[] | FieldReaction //字段响应器
}
```

FormPathPattern API 参考 [FormPath](/zh-CN/api/entry/form-path#formpathpattern)

FieldValidator 参考 [FieldValidator](/zh-CN/api/models/field#fieldvalidator)

FieldReaction 参考 [FieldReaction](/zh-CN/api/models/field#fieldreaction)

### IVoidFieldFactoryProps

```ts
interface IFieldFactoryProps {
  name: FormPathPattern //字段名称，当前节点的路径名称
  basePath?: FormPathPattern //基础路径
  title?: string | JSXElement //字段标题
  description?: string | JSXElement //字段描述
  required?: boolean //字段是否必填
  display?: 'none' | 'hidden' | 'visible' //字段展示形式
  pattern?: 'editable' | 'disabled' | 'readOnly' | 'readPretty' //字段交互模式
  hidden?: boolean //字段是否隐藏
  visible?: boolean //字段是否显示
  editable?: boolean //字段是否可编辑
  disabled?: boolean //字段是否禁用
  readOnly?: boolean //字段是否只读
  readPretty?: boolean //字段是否为阅读态
  decorator?: any[] //字段装饰器，第一个元素代表组件引用，第二个元素代表组件属性
  component?: any[] //字段组件，第一个元素代表组件引用，第二个元素代表组件属性
  reactions?: FieldReaction[] | FieldReaction //字段响应器
}
```

FormPathPattern API 参考 [FormPath](/zh-CN/api/entry/form-path#formpathpattern)

FieldReaction 参考 [FieldReaction](/zh-CN/api/models/field#fieldreaction)

> Formily Typescript 类型约定
>
> - 简单非对象数据类型或 Union 数据类型用 type 定义类型，不能以大写`I`字符开头
> - 简单对象类型统一用 interface 定义类型，且以大写`I`字符开头，如果存在不同 interface 的组合(Intersection or Extends)使用 type 定义类型，同样以大写`I`字符开头
</file>

<file path="packages/core/docs/api/models/ObjectField.md">
---
order: 3
---

# ObjectField

Call the ObjectField model returned by [createObjectField](/api/models/form#createobjectfield).

Because ObjectField is inherited from the [Field](/api/models/field) model, most APIs can refer to the Field model. This document only explains the extension method

## Method

### addProperty

#### Description

Add attributes to the object and trigger onInput

#### Signature

```ts
interface addProperty {
  (key: FormPathPattern, value: any): Promise<void>
}
```

### removeProperty

#### Description

Remove object properties and trigger onInput

#### Signature

```ts
interface removeProperty {
  (key: FormPathPattern): Promise<void>
}
```

### existProperty

#### Description

Determine whether the attribute exists

#### Signature

```ts
interface existProperty {
  (key: FormPathPattern): boolean
}
```

## Types of

### IObjectFieldState

The main attributes refer to [IFieldState](/api/models/field#ifieldstate), but the data type of value is required to be an object
</file>

<file path="packages/core/docs/api/models/ObjectField.zh-CN.md">
---
order: 3
---

# ObjectField

调用[createObjectField](/api/models/form#createobjectfield)所返回的 ObjectField 模型。

因为 ObjectField 是继承至 [Field](/api/models/field) 模型的，所以大部分 API 参考 Field 模型即可，该文档只讲解扩展方法

## 方法

### addProperty

#### 描述

给对象添加属性，并触发 onInput

#### 签名

```ts
interface addProperty {
  (key: FormPathPattern, value: any): Promise<void>
}
```

### removeProperty

#### 描述

移除对象属性，并触发 onInput

#### 签名

```ts
interface removeProperty {
  (key: FormPathPattern): Promise<void>
}
```

### existProperty

#### 描述

判断属性是否存在

#### 签名

```ts
interface existProperty {
  (key: FormPathPattern): boolean
}
```

## 类型

### IObjectFieldState

主要属性参考[IFieldState](/api/models/field#ifieldstate)，只是 value 的数据类型要求是对象
</file>

<file path="packages/core/docs/api/models/Query.md">
---
order: 5
---

# Query

The Query object returned by calling the query method in the [Form](/api/models/form#query) or [Field](/api/models/field#query) instance

## Method

### take

#### Description

Extract the first result from the query result set

Note that there must be a corresponding node to be able to read

#### Signature

```ts
interface take {
  (): GeneralField
  <Result>(getter: (field: GeneralField, address: FormPath) => Result): Result
}
```

### map

#### Description

Traverse and map the query result set

Note that there must be a corresponding node to traverse

#### Signature

```ts
interface map {
  (): GeneralField[]
  <Result>(
    mapper?: (field: GeneralField, address: FormPath) => Result
  ): Result[]
}
```

### forEach

#### Description

Traverse the query result set

Note that there must be a corresponding node to traverse

#### Signature

```ts
interface forEach {
  <Result>(eacher: (field: GeneralField, address: FormPath) => Result): void
}
```

### reduce

#### Description

Perform a reduce operation on the query result set

Note that there must be a corresponding node to traverse

#### Signature

```ts
interface reduce {
  <Result>(
    reducer: (value: Result, field: GeneralField, address: FormPath) => Result,
    initial?: Result
  ): Result
}
```

### get

#### Description

Find the first result from the query result set and read its attributes

Note that there must be a corresponding node to be able to read

#### Signature

```ts
interface get {
  <K extends keyof IGeneralFieldState>(key: K): IGeneralFieldState[K]
}
```

### getIn

#### Description

Find the first result from the query result set and read its attributes, support [FormPathPattern](/api/entry/form-path#formpathpattern) path syntax

Note that there must be a corresponding node to be able to read

#### Signature

```ts
interface getIn {
  (pattern?: FormPathPattern): any
}
```

### value

#### Description

Query the specified path value, not limited to Field nodes

#### Signature

```ts
interface value {
  (): any
}
```

### initialValue

#### Description

Query the initial value of the specified path, not limited to the Field node

#### Signature

```ts
interface initialValue {
  (): any
}
```
</file>

<file path="packages/core/docs/api/models/Query.zh-CN.md">
---
order: 5
---

# Query

调用[Form](/api/models/form#query)或[Field](/api/models/field#query)实例中的 query 方法所返回的 Query 对象

## 方法

### take

#### 描述

从查询结果集中提取第一个结果

注意，必须要存在对应的节点才能读取

#### 签名

```ts
interface take {
  (): GeneralField
  <Result>(getter: (field: GeneralField, address: FormPath) => Result): Result
}
```

### map

#### 描述

遍历并映射查询结果集

注意，必须要存在对应的节点才能遍历

#### 签名

```ts
interface map {
  (): GeneralField[]
  <Result>(
    mapper?: (field: GeneralField, address: FormPath) => Result
  ): Result[]
}
```

### forEach

#### 描述

遍历查询结果集

注意，必须要存在对应的节点才能遍历

#### 签名

```ts
interface forEach {
  <Result>(eacher: (field: GeneralField, address: FormPath) => Result): void
}
```

### reduce

#### 描述

对查询结果集执行 reduce 操作

注意，必须要存在对应的节点才能遍历

#### 签名

```ts
interface reduce {
  <Result>(
    reducer: (value: Result, field: GeneralField, address: FormPath) => Result,
    initial?: Result
  ): Result
}
```

### get

#### 描述

从查询结果集中找到第一个结果，并读取其属性

注意，必须要存在对应的节点才能读取

#### 签名

```ts
interface get {
  <K extends keyof IGeneralFieldState>(key: K): IGeneralFieldState[K]
}
```

### getIn

#### 描述

从查询结果集中找到第一个结果，并读取其属性，支持 [FormPathPattern](/api/entry/form-path#formpathpattern) 路径语法

注意，必须要存在对应的节点才能读取

#### 签名

```ts
interface getIn {
  (pattern?: FormPathPattern): any
}
```

### value

#### 描述

查询指定路径值，不局限于 Field 节点

#### 签名

```ts
interface value {
  (): any
}
```

### initialValue

#### 描述

查询指定路径初始值，不局限于 Field 节点

#### 签名

```ts
interface initialValue {
  (): any
}
```
</file>

<file path="packages/core/docs/api/models/VoidField.md">
---
order: 4
---

# VoidField

Call the VoidField model returned by [createVoidField](/api/models/form#createvoidfield).

All model attributes are listed below. If the attribute is writable, then we can directly refer to it to modify the attribute, and @formily/reactive will respond to trigger the UI update.

## Attributes

| Property    | Description                               | Type                                    | Read-only or not | Default value |
| ----------- | ----------------------------------------- | --------------------------------------- | ---------------- | ------------- |
| initialized | Whether the field has been initialized    | Boolean                                 | No               | `false`       |
| mounted     | Is the field mounted                      | Boolean                                 | No               | `false`       |
| unmounted   | Is the field unmounted                    | Boolean                                 | No               | `false`       |
| address     | Field node path                           | [FormPath](/api/entry/form-path)        | Yes              |               |
| path        | Field data path                           | [FormPath](/api/entry/form-path)        | Yes              |               |
| title       | Field Title                               | [FieldMessage](#fieldmessage)           | No               | `""`          |
| description | Field description                         | [FieldMessage](#fieldmessage)           | No               | `""`          |
| decorator   | field decorator                           | Any[]                                   | No               | `null`        |
| component   | Field component                           | Any[]                                   | No               | `null`        |
| parent      | Parent field                              | [GeneralField](#generalfield)           | yes              | `null`        |
| display     | Field display status                      | [FieldDisplayTypes](#fielddisplaytypes) | No               | `"visible"`   |
| pattern     | Field interaction mode                    | [FieldPatternTypes](#fieldpatterntypes) | No               | `"editable"`  |
| hidden      | Whether the field is hidden               | Boolean                                 | No               | `false`       |
| visible     | Whether the field is displayed            | Boolean                                 | No               | `true`        |
| disabled    | Whether the field is disabled             | Boolean                                 | No               | `false`       |
| readOnly    | Is the field read-only                    | Boolean                                 | No               | `false`       |
| readPretty  | Whether the field is in the reading state | Boolean                                 | No               | `false`       |
| editable    | Field is editable                         | Boolean                                 | No               | `true`        |

#### explain in detail

**hidden**

When true, display is hidden, when false, display is visible

**visible**

When true, display is visible, when false, display is none

## Method

### setTitle

#### Description

Set field title

#### Signature

```ts
interface setTitle {
  (title?: FieldMessage): void
}
```

FieldMessage Reference [FieldMessage](#fieldmessage)

### setDescription

#### Description

Set field description information

#### Signature

```ts
interface setDescription {
  (title?: FieldMessage): void
}
```

FieldMessage Reference [FieldMessage](#fieldmessage)

### setDisplay

#### Description

Set field display status

#### Signature

```ts
interface setDisplay {
  (display?: FieldDisplayTypes): void
}
```

FieldDisplayTypes Reference [FieldDisplayTypes](#fielddisplaytypes)

### setPattern

#### Description

Set field interaction mode

#### Signature

```ts
interface setPattern {
  (pattern?: FieldPatternTypes): void
}
```

FieldPatternTypes Reference [FieldPatternTypes](#fieldpatterntypes)

### setComponent

#### Description

Set field component

#### Signature

```ts
interface setComponent {
  (component?: FieldComponent, props?: any): void
}
```

FieldComponent Reference [FieldComponent](#fieldcomponent)

### setComponentProps

#### Description

Set field component properties

#### Signature

```ts
interface setComponentProps {
  (props?: any): void
}
```

### setDecorator

#### Description

Set field decorator

#### Signature

```ts
interface setDecorator {
  (decorator?: FieldDecorator, props?: any): void
}
```

FieldDecorator Reference [FieldDecorator](#fielddecorator)

### setDecoratorProps

#### Description

Set field decorator properties

#### Signature

```ts
interface setDecoratorProps {
  (props?: any): void
}
```

### setState

#### Description

Set field status

#### Signature

```ts
interface setState {
  (state: IVoidFieldState): void
  (callback: (state: IVoidFieldState) => void): void
}
```

IVoidFieldState Reference [IVoidFieldState](#ifieldstate)

### getState

#### Description

Get field status

#### Signature

```ts
interface getState<T> {
  (): IVoidFieldState
  (callback: (state: IVoidFieldState) => T): T
}
```

IVoidFieldState Reference [IVoidFieldState](#ifieldstate)

### setData

#### Description

set field data

#### Signature

```ts
interface setData {
  (data: any): void
}
```

### setContent

#### Description

set field content

#### Signature

```ts
interface setContent {
  (content: any): void
}
```

### onInit

#### Description

Trigger field initialization, no need to call manually

#### Signature

```ts
interface onInit {
  (): void
}
```

### onMount

#### Description

Trigger field mount

#### Signature

```ts
interface onMount {
  (): void
}
```

### onUnmount

#### Description

Trigger field unloading

#### Signature

```ts
interface onUnmount {
  (): void
}
```

### query

#### Description

Query field, you can query adjacent fields based on the current field

#### Signature

```ts
interface query {
  (pattern: FormPathPattern): Query
}
```

FormPathPattern API Reference [FormPath](/api/entry/form-path#formpathpattern)

Query object API reference [Query](/api/models/query)

### dispose

#### Description

Release observer, no need to release manually by default

#### Signature

```ts
interface dispose {
  (): void
}
```

### destroy

#### Description

Release observer, and remove current field model

#### Signature

```ts
interface destroy {
  (): void
}
```

### match

#### Description

Match fields based on path

#### Signature

```ts
interface match {
  (pattern: FormPathPattern): boolean
}
```

FormPathPattern API Reference [FormPath](/api/entry/form-path#formpathpattern)

### inject

#### Description

Inject executable methods into field models

#### Signature

```ts
interface inject {
  (actions: Record<string, (...args: any[]) => any>): void
}
```

### invoke

#### Description

Invoke an executable method injected by the field model via inject

#### Signature

```ts
interface invoke {
  (name: string, ...args: any[]): any
}
```

## Types of

<Alert>
Note: If you want to manually consume the type, just export it directly from the package module
</Alert>

### FieldMessage

```ts
type FieldMessage = string | JSXElement
```

If under the UI framework that supports JSX, we can directly pass the Node of JSX, otherwise, we can only pass the string

### FieldComponent

```ts
type FieldComponent = string | JSXComponentConstructor
```

Field component, if we use it in a framework that supports JSX, FieldComponent recommends to store the JSX component reference directly, otherwise it can store a component identification string and distribute it during actual rendering.

### FieldDecorator

```ts
type FieldDecorator = string | JSXComponentConstructor
```

Field decorator, if we use it in a framework that supports JSX, FieldDecorator recommends to store the JSX component reference directly, otherwise it can store a component identification string and distribute it during actual rendering.

### FieldReaction

```ts
type FieldReaction = (field: GeneralField) => void
```

### FieldDisplayTypes

```ts
type FieldDisplayTypes = 'none' | 'hidden' | 'visible'
```

### FieldPatternTypes

```ts
type FieldPatternTypes = 'editable' | 'disabled' | 'readOnly' | 'readPretty'
```

### GeneralField

```ts
type GeneralField = Field | VoidField | ArrayField | ObjectField
```

Field Reference [Field](/api/models/field)

ArrayField Reference [ArrayField](/api/models/array-field)

ObjectField Reference [ObjectField](/api/models/object-field)

### IVoidFieldState

```ts
interface IVoidFieldState {
  hidden?: boolean
  visible?: boolean
  editable?: boolean
  readOnly?: boolean
  disabled?: boolean
  readPretty?: boolean
  title?: any
  description?: any
  modified?: boolean
  active?: boolean
  visited?: boolean
  initialized?: boolean
  mounted?: boolean
  unmounted?: boolean
  decorator?: FieldDecorator
  component?: FieldComponent
  readonly parent?: GeneralField
  display?: FieldDisplayTypes
  pattern?: FieldPatternTypes
}
```

### IGeneralFieldState

```ts
type IGeneralFieldState = IVoidFieldState & IFieldState
```

IFieldState Reference [IFieldState](/api/models/field#ifieldstate)
</file>

<file path="packages/core/docs/api/models/VoidField.zh-CN.md">
---
order: 4
---

# VoidField

调用[createVoidField](/api/models/form#createvoidfield)所返回的 VoidField 模型。

以下会列出所有模型属性，如果该属性是可写的，那么我们可以直接引用是修改该属性，@formily/reactive 便会响应从而触发 UI 更新。

## 属性

| 属性        | 描述               | 类型                                    | 是否只读 | 默认值       |
| ----------- | ------------------ | --------------------------------------- | -------- | ------------ |
| initialized | 字段是否已被初始化 | Boolean                                 | 否       | `false`      |
| mounted     | 字段是否已挂载     | Boolean                                 | 否       | `false`      |
| unmounted   | 字段是否已卸载     | Boolean                                 | 否       | `false`      |
| address     | 字段节点路径       | [FormPath](/api/entry/form-path)        | 是       |              |
| path        | 字段数据路径       | [FormPath](/api/entry/form-path)        | 是       |              |
| title       | 字段标题           | [FieldMessage](#fieldmessage)           | 否       | `""`         |
| description | 字段描述           | [FieldMessage](#fieldmessage)           | 否       | `""`         |
| decorator   | 字段装饰器         | Any[]                                   | 否       | `null`       |
| component   | 字段组件           | Any[]                                   | 否       | `null`       |
| parent      | 父级字段           | [GeneralField](#generalfield)           | 是       | `null`       |
| display     | 字段展示状态       | [FieldDisplayTypes](#fielddisplaytypes) | 否       | `"visible"`  |
| pattern     | 字段交互模式       | [FieldPatternTypes](#fieldpatterntypes) | 否       | `"editable"` |
| hidden      | 字段是否隐藏       | Boolean                                 | 否       | `false`      |
| visible     | 字段是否显示       | Boolean                                 | 否       | `true`       |
| disabled    | 字段是否禁用       | Boolean                                 | 否       | `false`      |
| readOnly    | 字段是否只读       | Boolean                                 | 否       | `false`      |
| readPretty  | 字段是否为阅读态   | Boolean                                 | 否       | `false`      |
| editable    | 字段是可编辑       | Boolean                                 | 否       | `true`       |

#### 详细解释

**hidden**

为 true 时是 display 为 hidden，为 false 时是 display 为 visible

**visible**

为 true 时是 display 为 visible，为 false 时是 display 为 none

## 方法

### setTitle

#### 描述

设置字段标题

#### 签名

```ts
interface setTitle {
  (title?: FieldMessage): void
}
```

FieldMessage 参考 [FieldMessage](#fieldmessage)

### setDescription

#### 描述

设置字段描述信息

#### 签名

```ts
interface setDescription {
  (title?: FieldMessage): void
}
```

FieldMessage 参考 [FieldMessage](#fieldmessage)

### setDisplay

#### 描述

设置字段展示状态

#### 签名

```ts
interface setDisplay {
  (display?: FieldDisplayTypes): void
}
```

FieldDisplayTypes 参考 [FieldDisplayTypes](#fielddisplaytypes)

### setPattern

#### 描述

设置字段交互模式

#### 签名

```ts
interface setPattern {
  (pattern?: FieldPatternTypes): void
}
```

FieldPatternTypes 参考 [FieldPatternTypes](#fieldpatterntypes)

### setComponent

#### 描述

设置字段组件

#### 签名

```ts
interface setComponent {
  (component?: FieldComponent, props?: any): void
}
```

FieldComponent 参考 [FieldComponent](#fieldcomponent)

### setComponentProps

#### 描述

设置字段组件属性

#### 签名

```ts
interface setComponentProps {
  (props?: any): void
}
```

### setDecorator

#### 描述

设置字段装饰器

#### 签名

```ts
interface setDecorator {
  (decorator?: FieldDecorator, props?: any): void
}
```

FieldDecorator 参考 [FieldDecorator](#fielddecorator)

### setDecoratorProps

#### 描述

设置字段装饰器属性

#### 签名

```ts
interface setDecoratorProps {
  (props?: any): void
}
```

### setState

#### 描述

设置字段状态

#### 签名

```ts
interface setState {
  (state: IVoidFieldState): void
  (callback: (state: IVoidFieldState) => void): void
}
```

IVoidFieldState 参考 [IVoidFieldState](#ifieldstate)

### getState

#### 描述

获取字段状态

#### 签名

```ts
interface getState<T> {
  (): IVoidFieldState
  (callback: (state: IVoidFieldState) => T): T
}
```

IVoidFieldState 参考 [IVoidFieldState](#ifieldstate)

### setData

#### 描述

设置 Data 值

#### 签名

```ts
interface setData {
  (data: any): void
}
```

### setContent

#### 描述

设置 Content 值

#### 签名

```ts
interface setContent {
  (content: any): void
}
```

### onInit

#### 描述

触发字段初始化，默认不需要手动调用

#### 签名

```ts
interface onInit {
  (): void
}
```

### onMount

#### 描述

触发字段挂载

#### 签名

```ts
interface onMount {
  (): void
}
```

### onUnmount

#### 描述

触发字段卸载

#### 签名

```ts
interface onUnmount {
  (): void
}
```

### query

#### 描述

查询字段，可以基于当前字段查询相邻字段

#### 签名

```ts
interface query {
  (pattern: FormPathPattern): Query
}
```

FormPathPattern API 参考 [FormPath](/api/entry/form-path#formpathpattern)

Query 对象 API 参考 [Query](/api/models/query)

### dispose

#### 描述

释放 observer，默认不需要手动释放

#### 签名

```ts
interface dispose {
  (): void
}
```

### destroy

#### 描述

释放 observer，并删除字段模型

#### 签名

```ts
interface destroy {
  (): void
}
```

### match

#### 描述

基于路径匹配字段

#### 签名

```ts
interface match {
  (pattern: FormPathPattern): boolean
}
```

FormPathPattern API 参考 [FormPath](/api/entry/form-path#formpathpattern)

### inject

#### 描述

给字段模型注入可执行方法

#### 签名

```ts
interface inject {
  (actions: Record<string, (...args: any[]) => any>): void
}
```

### invoke

#### 描述

调用字段模型通过 inject 注入的可执行方法

#### 签名

```ts
interface invoke {
  (name: string, ...args: any[]): any
}
```

## 类型

<Alert>
注意：如果要手动消费类型，直接从包模块中导出即可
</Alert>

### FieldMessage

```ts
type FieldMessage = string | JSXElement
```

如果在支持 JSX 的 UI 框架下，我们可以直接传 JSX 的 Node，否则，我们只能传字符串

### FieldComponent

```ts
type FieldComponent = string | JSXComponentConstructor
```

字段组件，如果我们在支持 JSX 的框架中使用，FieldComponent 推荐直接存储 JSX 组件引用，否则可以存储一个组件标识字符串，在实际渲染的时候做一次分发。

### FieldDecorator

```ts
type FieldDecorator = string | JSXComponentConstructor
```

字段装饰器，如果我们在支持 JSX 的框架中使用，FieldDecorator 推荐直接存储 JSX 组件引用，否则可以存储一个组件标识字符串，在实际渲染的时候做一次分发。

### FieldReaction

```ts
type FieldReaction = (field: GeneralField) => void
```

### FieldDisplayTypes

```ts
type FieldDisplayTypes = 'none' | 'hidden' | 'visible'
```

### FieldPatternTypes

```ts
type FieldPatternTypes = 'editable' | 'disabled' | 'readOnly' | 'readPretty'
```

### GeneralField

```ts
type GeneralField = Field | VoidField | ArrayField | ObjectField
```

Field 参考 [Field](/api/models/field)

ArrayField 参考 [ArrayField](/api/models/array-field)

ObjectField 参考 [ObjectField](/api/models/object-field)

### IVoidFieldState

```ts
interface IVoidFieldState {
  hidden?: boolean
  visible?: boolean
  editable?: boolean
  readOnly?: boolean
  disabled?: boolean
  readPretty?: boolean
  title?: any
  description?: any
  modified?: boolean
  active?: boolean
  visited?: boolean
  initialized?: boolean
  mounted?: boolean
  unmounted?: boolean
  decorator?: FieldDecorator
  component?: FieldComponent
  readonly parent?: GeneralField
  display?: FieldDisplayTypes
  pattern?: FieldPatternTypes
}
```

### IGeneralFieldState

```ts
type IGeneralFieldState = IVoidFieldState & IFieldState
```

IFieldState 参考 [IFieldState](/api/models/field#ifieldstate)
</file>

<file path="packages/core/docs/guide/architecture.md">
# Core Architecture

## Domain Model

Formily's kernel architecture is very complicated, because it is necessary to solve a domain-level problem, rather than a single point of specific problem, first go to the architecture diagram:

![](https://img.alicdn.com/imgextra/i4/O1CN01HlrsLS1hQAJnihhh1_!!6000000004271-55-tps-2431-2037.svg)

## Description

From the above figure, we can see that the Formily kernel is actually a @formily/reactive domain model.

The actual consumption domain model mainly relies on the @formily/reactive responder mechanism for dependency tracking to consume.

We can consume any attribute in the Form/Field/ArrayField/ObjectField/VoidField model in the responder (Reactions). When the dependent attribute changes, the responder will execute repeatedly.

So as to realize the Reactive programming model at the form level.
</file>

<file path="packages/core/docs/guide/architecture.zh-CN.md">
# 核心架构

## 领域模型

Formily 内核架构非常复杂，因为要解决一个领域级的问题，而不是单点具体的问题，先上架构图：

![](https://img.alicdn.com/imgextra/i4/O1CN01HlrsLS1hQAJnihhh1_!!6000000004271-55-tps-2431-2037.svg)

## 说明

从上图中我们可以看到 Formily 内核其实是一个 @formily/reactive 领域模型。

实际消费领域模型则主要是依赖 @formily/reactive 的 响应器 机制做依赖追踪来消费。

我们可以在响应器(Reactions)中消费 Form/Field/ArrayField/ObjectField/VoidField 模型中的任意属性，依赖的属性发生变化，响应器就会重复执行。

从而实现了表单层面的 Reactive 编程模型。
</file>

<file path="packages/core/docs/guide/field.md">
# Field model

Formily's field model core contains two types of field models:

- Data type field
- Dummy data type field

Data type field (Field), the core is responsible for maintaining the form data (the value when the form is submitted).

VoidField, you can understand that it is a Field that has castrated data maintenance capabilities, so it is more of a UI form that maintains a batch of fields as a container.

Let's analyze these two types of fields in detail.

## Data field

There are 3 data type fields in the field model:

- Field
- ArrayField
- ObjectField

ArrayField and ObjectField are both inherited from Field. The positioning of Field is to maintain non-incremental data fields. Compared with ArrayField/Object, it does not mean that Field cannot store data of array type or object type. Field can store data of any data type. However, if the user expects to realize the interaction of adding, deleting, and moving arrays, they need to use ArrayField, and for the interaction of adding and deleting object properties, they need to use ObjectField. If there is no such requirement, all data types can be unified with Field.

Then let's look at the specific Field rules:

- Path rules
- Explicit and implicit rules
- Data read and write rules
- Data source rules
- Field component rules
- Field decorator rules
- Validation rules

### Path Rules

Because the form structure of our actual business itself is a tree structure, in Formily, each field will have an absolute path in the form model. This absolute path roughly describes the position of the field in the form data (why use roughly, later I will talk about it), any field can be found through the absolute path, and at the same time the parent-child relationship between the fields can be expressed. Therefore, in the field model, we define the address attribute to express the absolute path of the field, which is mainly described by dot syntax, such as abc The path of represents that the father of field c is field b, and the father of field b is a.

Of course, things are not that simple, because we also have a VoidField, which is a dummy data field, and it also has its own absolute path, because it can be the father of the data field. If we only have an absolute path, we cannot make a data field correct. Write field data to the form data. Reading data will also read the wrong position.

Therefore, we actually need a data path as a dedicated data field for writing data and reading data. Here we use path to describe the data path of the field. You can look at this picture for general rules:

![](//img.alicdn.com/imgextra/i1/O1CN01cdzULJ1et4PBak8si_!!6000000003928-2-tps-3506-2042.png)

In summary, Address is always the absolute path representing the node, and Path is the node path that skips the VoidField, but if it is the Path of the VoidField, it will retain its own path position.

Therefore, whether it is a Field or a VoidField, it will have its Address and Path, so when we use the query method to query the field, we can either use the Address rule to query, or use the Path rule to query, such as `query("bc")` The c field can be queried, and the c field can also be queried with `query("abc")`.

### Explicit and Implicit Rules

The display and hiding of the fields are mainly expressed by the display attribute:

- If display is none, it means that the field UI is hidden and the field data is not retained
- display is hidden, which means that the field UI is hidden and the field data is preserved
- display is visible, which means the field UI is displayed, and the field data is restored at the same time

On top of the display property, we also provide two convenient properties

1. visible, if true, display is equal to visible, if false, display is equal to none
2. hidden, if true, display is equal to hidden, if false, display is equal to visible

The above is about the writing rules of explicit and implicit attributes. The reading rules will be more complicated. Here is a default inheritance logic:

If the parent node actively sets the display property, and the child node does not actively set the display property, then the child node will inherit the display of the parent node

So what is the active setting of display? mainly includes:

- Configure the initial attributes display/visible/hidden for the field
- If there is no configuration during initialization, but display/visible/hidden is set to the field later

So what if you want to change from no inheritance to inheritance? Just set display to null.

### Data read and write rules

Because Field is a data-type field, it is responsible for maintaining the data of a certain node of the form data. The reading here is actually the form data read directly, which is addressed through the path attribute, which also guarantees the form data and field data. Absolutely idempotent, just read value/initialValue directly.

The data writing rules are consistent with the reading rules. Field does not independently maintain a copy of data. It directly operates on the data of the specific form, which is addressed through the path attribute. The main writing methods are:

- Modify the value/initialValue attribute directly
- Calling onInput will write data, and at the same time, set the inputValue of the field as input parameter data, inputValues as multi-parameter data, and then set the modified attribute to true, which means that the field has been manually modified, and finally trigger the verification rule that triggerType is onInput
- Call the setValue method

### Data source rules

Considering that the value source of the field is not only input through the Input input box, but also selected from a data source, such as a drop-down box, the field model adds a data source attribute dataSource, which is dedicated to reading data source. Only a layer of mapping needs to be done on the component consumer side. The method of writing to the data source can directly modify the dataSource property, or call the setDataSource method

### Component Rules

Field model, if there is no proxy UI component information, then more refined linkage control cannot be achieved. For example, if the value of A field changes to control the placeholder of B field, then the field attributes must be proxyed, so formily provides The component property is used to proxy UI component information. The component is an array `[Component,ComponentProps]`. The first element represents which component it is, and the second represents the properties of the component. Why use an array? This is convenient for type prompting, and the writing method is relatively simple.

The way to read component information is to read the component property directly.

The main ways to write component information are:

- Modify the component property directly and pass in the array
- Call the setComponent method, the first parameter is the component, the second is the component property
- Call the setComponentProps method to directly set the component properties

### Decorator rules

Similar to the field component rules, the field decorator is mainly used to maintain the package container of the field, such as FormItem, which is more partial to the control of the UI layout. Here we use the decorator attribute to describe the field decorator.

The way to read the decorator information is to directly read the decorator attribute.

The main ways to write decorator information are:

- Modify the decorator property directly and pass in an array
- Call the setDecorator method, the first parameter is the component, and the second is the component property
- Call the setDecoratorProps method to directly set the component properties

### Validation rules

The verification rules mainly include:

- Verifier
- Timing of calibration
- Verification strategy
- Verification result

#### Validator

The validator in the field model is mainly described by the validator attribute. The validator can be passed to the field when the field is initialized, and the validator can be modified again after initialization.

A validator mainly has the following forms:

- Pure string format verification, such as `"phone" | validator = "url" | validator= "email"`. This format verification is a short form of regular rules. Formily provides some standard regular rules. Of course Users can also manually create rules through registerValidateFormats to facilitate reuse
- Custom function verification, there are 3 return value modes:
  - `(value)=>"message"`, a string returned means there is an error, and no string means no error
  - `(value)=>({type:"error",message:"message"})`, return object form, you can specify type as error or warning or success
  - `{validator:()=>false,message:"message"}`, returns a boolean form, the error message will reuse the message field of the object structure
- Object structure verification is a more complete expression, such as:
  - `{format:"url"}` This can specify the regular format
  - `{required:true}` This can specify required fields
  - There are more rule attributes can refer to the API documentation, and we can also register similar validation rules through registerValidateRules
- Object array structure verification is a combination of the previous three types. In fact, the first three types will all be converted into object array structures, such as:
  - `["url",{required:true},(value)=>"message"]` is actually equivalent to `[{format:"url"},{required:true},{validator:(value)=> "message"}]`

#### Check timing

Sometimes, we want certain verification rules to be triggered only when focusing or out of focus. We can add a triggerType to each verification rule object, such as `{validator:(value)=>"message",triggerType: "onBlur"}` In this way, you can precisely control a verification rule to perform verification only in a certain event. The triggerType here mainly includes `"onInput" | "onBlur" | "onFocus"`, if you call `form. validate` is a rule that verifies all triggerTypes at once. If you manually call `field.validate`, you can specify the triggerType in the input parameters, and all triggerTypes will be verified if you don’t pass them.

#### Verification Strategy

Sometimes, we hope that the verification strategy of a certain field is that when all the verification rules are executed, if a verification rule fails, the result will be returned immediately. We only need to pass the parameter validateFirst to true when the field is initialized. That is, the default is false, that is, the verification will continue if the verification fails, and the verification result obtained is an array.

#### Read the verification result

The verification results are mainly stored in the feedbacks property in the field model. Feedbacks is an array of Feedback objects. The structure of each Feedback is:

```ts
interface Feedback {
  path: string //Field data path
  address: string //field absolute path
  type: 'error' | 'success' | 'warning' //Verification result type
  code: //Check result code
  | 'ValidateError'
    | 'ValidateSuccess'
    | 'ValidateWarning'
    | 'EffectError'
    | 'EffectSuccess'
    | 'EffectWarning'
  messages: string[] //Check the message
}
```

There are four main ways to read:

- Read feedbacks properties directly
- Reading the errors attribute is equivalent to filtering out all verification results with type error from feedbacks
- Reading the warnings attribute is equivalent to filtering out all the verification results whose type is warning from feedbacks
- Reading the successes attribute is equivalent to filtering out all verification results with type success from feedbacks

#### Write verification result

There are 3 ways to write:

- Call the validate method to trigger the field validator to perform the validation action, and the code of the validation result is uniformly Validate\*`
  - Calling onInput will trigger validate
  - Calling onFocus will trigger validate
  - Calling onBlur will trigger validate
  - Call reset and specify validate as true to trigger validate
- Modify the feedbacks attribute directly
- Modify the errors property directly, it will be converted into an array of feedbacks objects, and the code of Feedback will be forcibly overwritten as EffectError
- Modify the warnings attribute directly, it will be converted into an array of feedbacks objects, and the code of Feedback will be forcibly overwritten as EffectWarning
- Modify the successes property directly, it will be converted into an array of feedbacks objects, and the code of Feedback will be forcibly overwritten as EffectSuccess

Such writing logic is mainly to prevent users from modifying the verification results from polluting the verification results of their own verifiers, strictly separating them, and easy to restore the scene.

#### Verification result query

The query of the verification result is mainly queried through queryFeedbacks. The query has the same participating Feedback objects, which can be filtered by type or code, or by path.

## ArrayField

Compared with Field, ArrayField only extends array-related methods on the basis of inheriting Field, such as push/pop/insert/move. Why should these methods be provided? Its ability is not only to process the field data, it It also provides internal state transposition processing for the sub-nodes of ArrayField mainly to ensure that the order of the fields is consistent with the order of the data. Can cite an example:

![](//img.alicdn.com/imgextra/i3/O1CN01mpGugu1QFlnfQ4qfo_!!6000000001947-2-tps-3506-1794.png)

This is a move call process, the value of the array element will move, and the state of the corresponding field will also move.

## ObjectField

Because the object type is disordered, there is no state transposition, so ObjectField provides addProperty/removeProperty/existProperty three APIs for users to use.

## VoidField

Compared with Field, VoidField mainly castrates data read and write rules, data source rules, and verification rules. When users use it, they mainly use explicit and implicit rules, components, and decorator rules.

<Alert>

The series of field rules mentioned above did not mention the detailed API usage details. It is more to help users sort out formily from the perspective of ideas. If you are not familiar with the API, it is best to read the API documentation first.

</Alert>
</file>

<file path="packages/core/docs/guide/field.zh-CN.md">
# 字段模型

Formily 的字段模型核心包含了两类字段模型：

- 数据型字段
- 虚数据型字段

数据型字段(Field)，核心是负责维护表单数据(表单提交时候的值)。

虚数据型字段(VoidField)，你可以理解为它就是一个阉割了数据维护能力的 Field，所以它更多的是作为容器维护一批字段的 UI 形式。

下面我们具体分析这两种类型字段。

## 数据型字段

在 字段模型 中有 3 种数据型字段：

- Field
- ArrayField
- ObjectField

ArrayField 和 ObjectField 都是继承自 Field，Field 的定位就是维护非自增型数据字段，对比 ArrayField/Object，并不是说 Field 就不能存数组类型或者对象类型的数据，Field 其实可以存任意数据类型的数据，只是，如果用户期望实现数组的添加删除移动这样的交互，则需要使用 ArrayField，对象属性的添加删除交互，则需要使用 ObjectField，如果没有这样的需求，所有数据类型统一用 Field 即可。

然后咱们再看具体 Field 领域规则：

- 路径规则
- 显隐规则
- 数据读写规则
- 数据源规则
- 字段组件规则
- 字段装饰器规则
- 校验规则

### 路径规则

因为我们实际业务的表单结构本身就是一个树结构，所以在 Formily 中，每个字段在表单模型中都会有一个绝对路径，这个绝对路径大致描述了字段在表单数据中的位置(为什么用大致，后面会讲)，通过绝对路径可以找到任意一个字段，同时还能表达字段间的父子关系，所以字段模型中，我们定义了 address 属性来表达字段的绝对路径，主要用点语法来描述，比如 a.b.c 这样的路径代表了字段 c 的父亲是字段 b，字段 b 的父亲是 a。

当然，事情并没有这么简单，因为我们还有 VoidField，VoidField 作为虚数据字段，它同样也有自己的绝对路径，因为它可以作为数据字段的父亲，如果我们只有绝对路径， 就无法让一个数据字段正确的往表单数据里写入字段数据。读取数据也会读错位置。

所以，我们其实还需要一个数据路径作为专门用于数据字段写入数据和读取数据的，这里我们用 path 来描述字段的数据路径，大概的规则可以看看这张图：

![](//img.alicdn.com/imgextra/i1/O1CN01cdzULJ1et4PBak8si_!!6000000003928-2-tps-3506-2042.png)

总结下来就是，Address 永远是代表节点的绝对路径，Path 是会跳过 VoidField 的节点路径，但是如果是 VoidField 的 Path，是会保留它自身的路径位置。

所以，不管是 Field 还是 VoidField，都会有它的 Address 和 Path，所以我们在用 query 方法查询字段的时候，既可以用 Address 规则查询，也可以用 Path 规则查询，比如`query("b.c")`可以查询到 c 字段，同样用`query("a.b.c")`也能查询到 c 字段。

### 显隐规则

字段的显示隐藏，主要用 display 属性来表达：

- display 为 none 代表字段 UI 隐藏，同时不保留字段数据
- display 为 hidden 代表字段 UI 隐藏，保留字段数据
- display 为 visible 代表字段 UI 显示，同时恢复字段数据

在 display 属性之上，我们还提供了两个便捷属性

1. visible，如果为 true 代表 display 等于 visible，如果为 false 代表 display 等于 none
2. hidden，如果为 true 代表 display 等于 hidden，如果为 false 代表 display 等于 visible

上面讲的是显隐属性的写规则，读取规则就会更复杂一些，这里有一个默认继承逻辑：

如果父节点主动设置了 display 属性，子节点没有主动设置 display 属性，那么子节点会继承父节点的 display

那什么才是主动设置 display 呢？主要包括：

- 给字段配置了初始化属性 display/visible/hidden
- 如果初始化时没有配置，但是在后期又给字段设置了 display/visible/hidden

那如果希望从不继承变为继承怎么办？把 display 设置为 null 即可。

### 数据读写规则

因为 Field 是数据型字段，它负责维护表单数据的某个节点的数据，这里的读取，其实是直接读取的表单数据，通过 path 属性来寻址，这样也保证了表单数据与字段数据的绝对幂等，读取的方式直接读取 value/initialValue 即可。

数据写入规则与读取规则一致，Field 不会独立维护一份数据，它操作的直接就是具体表单的数据，通过 path 属性来寻址，写入的方式主要有：

- 直接修改 value/initialValue 属性
- 调用 onInput 会写入数据，同时设置字段的 inputValue 为入参数据，inputValues 为多参数据，然后设置 modified 属性为 true，代表该字段被手动修改过，最后触发 triggerType 为 onInput 的校验规则
- 调用 setValue 方法

### 数据源规则

考虑到字段的值来源不是只有通过 Input 输入框输入的，还有会从一个数据源中选取的，比如下拉框之类的，所以字段模型加了一个数据源的属性 dataSource，专门用于读取数据源。只是在组件消费端需要做一层映射。写入数据源的方式可以直接修改 dataSource 属性，也可以调用 setDataSource 方法

### 组件规则

字段模型，如果没有代理 UI 组件信息，那就没法实现更加精细化的联动控制了，比如 A 字段的值变化要控制 B 字段的 placeholder，那就必须将字段的属性给代理起来，所以 formily 提供了 component 属性，专门用于代理 UI 组件信息，component 是一个数组`[Component,ComponentProps]`，第一个元素代表是哪个组件，第二个代表组件的属性有哪些，为什么用数组，主要原因是这样方便类型提示，同时写法也比较简单。

读取组件信息的方式直接读取 component 属性即可。

写入组件信息的方式主要有：

- 直接修改 component 属性，传入数组
- 调用 setComponent 方法，第一个参数是组件，第二个是组件属性
- 调用 setComponentProps 方法，直接会设置组件属性

### 装饰器规则

与字段组件规则相似，字段装饰器主要用来维护字段的包裹容器，比如 FormItem，更偏 UI 布局的控制，这里我们用 decorator 属性来描述字段装饰器。

读取装饰器信息的方式直接读取 decorator 属性即可。

写入装饰器信息的方式主要有：

- 直接修改 decorator 属性，传入数组
- 调用 setDecorator 方法，第一个参数是组件，第二个是组件属性
- 调用 setDecoratorProps 方法，直接会设置组件属性

### 校验规则

校验规则主要包含：

- 校验器
- 校验时机
- 校验策略
- 校验结果

#### 校验器

在字段模型中的校验器主要用 validator 属性描述，在字段初始化的时候可以给字段传入 validator，初始化之后也可以再次修改 validator

一个 validator 主要有以下几种形态：

- 纯字符串格式校验，比如`"phone" | validator = "url" | validator= "email"` ，这样的格式校验是正则规则的简写形式，formily 内部提供了一些标准的正则规则，当然用户也能通过 registerValidateFormats 来手动创建规则，方便复用
- 自定义函数校验，有 3 种返回值模式：
  - `(value)=>"message"`，返回字符串代表有错误，不返回字符串代表无错误
  - `(value)=>({type:"error",message:"message"})`，返回对象形式，可以指定 type 是 error 或 warning 或 success
  - `{validator:()=>false,message:"message"}`，返回布尔形式，错误消息会复用对象结构的 message 字段
- 对象结构校验，是一种更完备的表达，比如：
  - `{format:"url"}` 这样可以指定正则格式
  - `{required:true}`这样可以指定必填
  - 还有更多的规则属性可以参考 API 文档，同时我们还能通过 registerValidateRules 来注册类似的校验规则
- 对象数组结构校验，是前面三种的组合表达，其实前 3 种，都会转换成对象数组结构，比如：
  - `["url",{required:true},(value)=>"message"]`其实相当于 `[{format:"url"},{required:true},{validator:(value)=>"message"}]`

#### 校验时机

有些时候，我们希望某些校验规则只在聚焦或者失焦的时候触发，我们可以在每个校验规则对象中加一个 triggerType，比如`{validator:(value)=>"message",triggerType:"onBlur"}` 这样就可以精确的控制某个校验规则只在某个事件中执行校验，这里的 triggerType 主要有`"onInput" | "onBlur" | "onFocus"` ，如果调用`form.validate`，是会一次性校验所有 triggerType 的规则，如果手动调用`field.validate`，则可以在入参中指定 triggerType，不传参就会校验所有。

#### 校验策略

有些时候，我们希望某个字段的校验策略是，执行所有校验规则的时候，如果某个校验规则校验失败则立即返回结果，我们只需要在 field 初始化的时候传入参数 validateFirst 为 true 即可，默认是 false，也就是校验失败也会继续校验，拿到的校验结果是一个数组。

#### 校验结果读取

对于校验结果，在字段模型中主要是存放在 feedbacks 属性中的，feedbacks 是由 Feedback 对象组成的数组，每个 Feedback 的结构是：

```ts
interface Feedback {
  path: string //字段数据路径
  address: string //字段绝对路径
  type: 'error' | 'success' | 'warning' //校验结果类型
  code: //校验结果编码
  | 'ValidateError'
    | 'ValidateSuccess'
    | 'ValidateWarning'
    | 'EffectError'
    | 'EffectSuccess'
    | 'EffectWarning'
  messages: string[] //校验消息
}
```

读取方式主要有 4 种：

- 直接读取 feedbacks 属性
- 读取 errors 属性，相当于是从 feedbacks 中过滤出 type 为 error 的所有校验结果
- 读取 warnings 属性，相当于是从 feedbacks 中过滤出 type 为 warning 的所有校验结果
- 读取 successes 属性，相当于是从 feedbacks 中过滤出 type 为 success 的所有校验结果

#### 校验结果写入

写入方式有 3 种：

- 调用 validate 方法，触发字段校验器执行校验动作，校验结果的 Code 统一是 Validate\*`
  - 调用 onInput 会触发 validate
  - 调用 onFocus 会触发 validate
  - 调用 onBlur 会触发 validate
  - 调用 reset，并指定 validate 为 true 会触发 validate
- 直接修改 feedbacks 属性
- 直接修改 errors 属性，会转换成 feedbacks 对象数组，同时 Feedback 的 code 会被强制覆盖为 EffectError
- 直接修改 warnings 属性，会转换成 feedbacks 对象数组，同时 Feedback 的 code 会被强制覆盖为 EffectWarning
- 直接修改 successes 属性，会转换成 feedbacks 对象数组，同时 Feedback 的 code 会被强制覆盖为 EffectSuccess

这样的写入逻辑主要是为了防止用户修改校验结果污染本身校验器的校验结果，做严格分离，容易恢复现场。

#### 校验结果查询

校验结果的查询主要通过 queryFeedbacks 来查询，查询的入参与 Feedback 对象一致，可以按照 type 或者 code，也可以按照路径进行过滤。

## ArrayField

ArrayField 相比于 Field，仅仅只是在继承 Field 的基础上扩展了数组相关的方法，比如 push/pop/insert/move 这些，为什么要提供这些方法，它的能力不只是对字段的数据做处理，它内部还提供了对 ArrayField 子节点的状态转置处理主要为了保证字段的顺序与数据的顺序是一致。可以举个例子：

![](//img.alicdn.com/imgextra/i3/O1CN01mpGugu1QFlnfQ4qfo_!!6000000001947-2-tps-3506-1794.png)

这是一个 move 调用的过程，数组元素的值会发生移动，同时对应字段的状态也会发生移动。

## ObjectField

因为 object 类型是无序的，也就不存在状态转置，所以 ObjectField 就提供了 addProperty/removeProperty/existProperty 3 个 API 给用户使用。

## VoidField

VoidField 相比于 Field，主要是阉割了数据读写规则、数据源规则和校验规则，用户使用的时候，主要还是使用显隐规则和组件，装饰器规则。

<Alert>

前面讲的一系列字段领域规则，并没有提到详细的 API 使用细节，更多的是从思路上帮助用户梳理 formily，如果对 API 不熟悉的，最好先看 API 文档。

</Alert>
</file>

<file path="packages/core/docs/guide/form.md">
# Form model

Earlier I talked about the overall architecture of the Formily kernel, and also talked about MVVM. You should also be able to roughly understand what Formily's form model is. Let's take a deeper look at the specific domain logic of the form model, which is mainly biased. Concluding content, if you don't understand it the first time, you can go directly to the API documentation, and come back after reading it, you can deepen your understanding of formily.

## Combing

The entire form model is very large and complicated. In fact, the core of the decomposition is the following sub-models:

- Field management model
- Field model
- Data model
- Linkage model
- Path system

Let's talk about how the form model is managed in detail below.

## Field Management Model

The field management model mainly includes:

- Field addition
- Field query
- Import field set
- Export field set
- Clear the field set

#### Field addition

The field is created mainly through the createField/createArrayField/createObjectField/createVoidField method. If the field already exists, it will not be created repeatedly

#### Field query

The query method is mainly used to query the field. The query method can pass in the path of the field or regular expression to match the field.

Because the detailed rules of the field path are still more complicated, they will be explained in detail in the following [Path System](/api/entry/form-path) article.

Then calling the query method will return a Query object. The Query object can have a forEach/map/reduce method that traverses all fields in batches, or a take method that takes only the first field that is queried, as well as direct reading of fields. The get method of properties, and the getIn method that can read field properties in depth, the difference between the two methods is that the former can have smart prompts, and the latter has no prompts, so it is recommended that users use the get method.

#### Import field set

The field set is imported mainly through setFormGraph. The input parameter format is a flat object format, the key is the absolute path of the field, and the value is the state of the field. Use this API to import the Immutable field state into the form in some scenarios that require time travel. In the model.

#### Export field set

The field set is mainly exported through getFormGraph. The export format is a flat object format, the key is the absolute path of the field, and the value is the state of the field, which is consistent with the imported field set input parameters. Because the returned data is an Immutable data, it is OK Completely persistent storage, convenient for time travel.

#### Clear the field set

The field set is cleared mainly through clearFormGraph.

## Field Model

The field model mainly includes:

- Field model, which is mainly responsible for managing the state of non-incremental fields, such as Input/Select/NumberPicker/DatePicker components
- The ArrayField model is mainly responsible for managing the state of the auto-increment list field, and can add, delete, and move list items.
- ObjectField model, which is mainly responsible for managing the state of auto-incremented object fields, and can add or delete the key of the object.
- The VoidField model is mainly responsible for managing the state of the virtual field. The virtual field is a node that does not pollute the form data, but it can control the display and hiding of its child nodes, and the interactive mode.

Because the field model is very complicated, it will be explained in detail in the following [Field Model](/guide/field) article.

## Data Model

For the form data model, the previous version of Formily will more or less have some boundary problems. After reorganizing a version in 2.x, it really broke through the previous legacy problems.

The data model mainly includes:

- Form values (values) management
- Form default value (initialValues) management
- Field value (value) management
- Field default value (initialValue) management
- Value and default value selection merge strategy

Form value management is actually the values attribute of an object structure, but it is an @formily/reactive observable attribute. At the same time, with the help of @formily/reactive's deep observer capability, it monitors any attribute changes, and if it changes, it will trigger The life cycle hook of onFormValuesChange.

In the same way, the default value management is actually the initialValues property of an object structure. It will also deeply monitor property changes and trigger the onFormInitialValues life cycle hook.

Field value management is reflected in the value attribute of each data type field. Formily will maintain a data path attribute called path for each field, and then read and write values are all read and write the values of the top-level form. This ensures that the value of the field and the value of the form are absolutely idempotent, and the default value of the field is the same.

To sum up, the management of **values is all managed on the top-level form, and the value of the field and the value of the form are absolutely idempotent through path. **

<Alert>

The difference between the value and the default value is actually whether the field will be reset to the default value state when the form is reset

</Alert>

#### Value and default value selection merge strategy

Usually, in the process of business development, there is always a need for data echo. This data is generally used as an asynchronous default value. If it is used as a detail page, it is okay, but as an editing page, there will be some problems. :

**There is a conflict**

For example, the form value is `{xx:123}`, and the default form value is `{xx:321}`. The strategy here is:

- If `xx` does not have a corresponding field model, it means it is just redundant data and cannot be modified by the user
  - If the form value is assigned first, and the default value is assigned later, then the default value directly overrides the form value. This scenario is suitable for asynchronous data echo scenarios. Different business states have different default data echoes, and the data is finally submitted.` {xx:321}`
  - If the default value is assigned first, and the form value is assigned later, the form value directly overrides the default value. This scenario is suitable for synchronizing the default value and finally submitting the data `{xx:123}`
- If `xx` has a field model
  - If the form value is assigned first, the default value is assigned later
    - If the current field has been modified by the user (modified is true), then the default value cannot overwrite the form value, and finally submit the data `{xx:123}`
    - If the current field has not been modified by the user (modified is false), then the default value will directly override the field value. This scenario is suitable for asynchronous data echo scenarios. Different business states have different default data echoes, and the data is finally submitted `{xx:321}`
  - If the default value is assigned first, and the form value is assigned later, the form value directly overrides the default value. This scenario is suitable for synchronizing the default value and finally submitting the data `{xx:123}`

**No conflicts**

For example, the form value is `{xx:123}`, and the default form value is `{yy:321}`. The strategy here is to merge directly.

To sum up, the selection and merging strategy of the value and the default value, the core is to see whether the field has been modified by the user, everything is subject to the user, if it has not been modified by the user, the order of assignment shall prevail.\*\*

<Alert>

The default value mentioned here can be assigned repeatedly, and it is also the question of whether to discard the value in the process of repeated assignment.

</Alert>

## Validation model

The core of the form verification model is to verify the validity of the data, and then manage the verification results, so the verification model mainly includes:

- Validation rule management
- Calibration result management

Because the verification model belongs to the field model, it will be explained in detail in the following [Field Model](/guide/field#Verification Rules)

## Linkage model

The core of the linkage model in formily1.x is the active linkage model, which is roughly expressed in one sentence:

```ts
setFieldState(Subscribe(FormLifeCycle, Selector(Path)), TargetState)
```

The explanation is that any linkage is based on a certain life cycle hook of the form to trigger the state of the field under the specified path. Such a model can solve many problems, but it also has an obvious problem, which is the many-to-one linkage. In the scenario where you need to monitor changes in multiple fields at the same time to control the state of a field, the implementation cost is still relatively high for users, especially to achieve some calculator linkage requirements, and the amount of code increases sharply. Of course, for one-to-many scenarios, this model is the most efficient.

Therefore, in formily 2.x, a passive linkage model is added to the active linkage model, which is also an expression:

```ts
subscribe(Dependencies, Reactions)
```

Simplified a lot, the core is to respond to dependent data changes. The dependent data can be form model attributes or attributes of any field model. The response action can be to change the attributes of any field model or do other asynchronous actions. . Such a model is also a complete linkage model, but in a one-to-many scenario, the implementation cost will be higher than the active model.

Therefore, the two linkage models require users to choose according to their own needs.

## Path system

The path system is very important. The path system is used everywhere in almost the entire form model. It mainly provides the following capabilities for the form model:

- It can be used to find any field from the field set, and it also supports batch search according to the rules
- It can be used to express the model of the relationship between the fields. With the help of the path system, we can find the father of a certain field, can find the father, and can also realize the data inheritance ability of the tree level. Similarly, we can also find the data of a certain field. Adjacent node
- It can be used to read and write field data, read and write data with deconstruction

The entire path system is actually implemented based on the path DSL of @formily/path. If you want to know more about the path system, you can take a look at [FormPath API](/api/entry/form-path) in detail
</file>

<file path="packages/core/docs/guide/form.zh-CN.md">
# 表单模型

前面讲到了 Formily 内核的整体架构，同时也讲了 MVVM，你应该也能大致能理解什么是 Formily 的表单模型了，下面我们再深一步来讲表单模型的具体领域逻辑，主要是偏思路性的总结性内容，如果第一遍看不懂，可以先直接去看 API 文档，看完之后再回来看，就能加深对 formily 的理解了。

## 梳理

整个表单模型很大很复杂，分解下来其实核心是以下几个子模型：

- 字段管理模型
- 字段模型
- 数据模型
- 联动模型
- 路径系统

下面具体来讲一下表单模型是如何管理的。

## 字段管理模型

字段管理模型，主要包含：

- 字段添加
- 字段查询
- 导入字段集
- 导出字段集
- 清空字段集

#### 字段添加

主要通过 createField/createArrayField/createObjectField/createVoidField 方法来创建字段，如果字段已经存在，则不会重复创建

#### 字段查询

主要通过 query 方法来查询字段，query 方法可以传入字段的路径或者正则表达式来匹配字段。

因为字段路径的详细规则还是比较复杂的，在后面的[路径系统](/api/entry/form-path)篇中会详细讲解。

然后调用 query 方法会返回一个 Query 对象，Query 对象中可以有批量遍历所有字段的 forEach/map/reduce 方法，也可以有只取查询到的第一个字段的 take 方法，同时还有直接读取字段属性的 get 方法，还有可以深层读取字段属性的 getIn 方法，两个方法的差别就是前者可以有智能提示，后者没有提示，所以推荐用户都用 get 方法。

#### 导入字段集

主要通过 setFormGraph 来导入字段集，入参格式是一个扁平对象格式，key 是字段的绝对路径，value 是字段的状态，使用该 API 主要在一些需要做时间旅行的场景，将 Immutable 字段状态导入至表单模型中。

#### 导出字段集

主要通过 getFormGraph 来导出字段集，导出格式是一个扁平对象格式，key 是字段的绝对路径，value 是字段的状态，与导入字段集入参一致，因为返回的数据是一个 Immutable 的数据，所以是可以完全做持久化存储的，方便时间旅行。

#### 清空字段集

主要通过 clearFormGraph 来清空字段集。

## 字段模型

字段模型主要包含了：

- Field 模型，主要负责管理非自增型字段状态，比如 Input/Select/NumberPicker/DatePicker 这些组件
- ArrayField 模型，主要负责管理自增列表字段状态，可以对列表项进行增删移动的。
- ObjectField 模型，主要负责管理自增对象字段状态，可以对对象的 key 做增删操作。
- VoidField 模型，主要负责管理虚字段状态，虚字段是一种不会污染表单数据的节点存在，但是它可以控制它的子节点显示隐藏，交互模式。

因为字段模型非常复杂，所以会在后面的[字段模型](/guide/field)篇中详细讲解。

## 数据模型

表单数据模型，formily 之前的版本或多或少都会存在一些边界问题，在 2.x 中重新梳理了一版，才真正把之前的遗留问题突破掉了。

数据模型主要包含：

- 表单值(values)管理
- 表单默认值(initialValues)管理
- 字段值(value)管理
- 字段默认值(initialValue)管理
- 值与默认值的选择合并策略

表单值管理，其实就是一个对象结构的 values 属性，只是它是一个 @formily/reactive observable 属性，同时借助了 @formily/reactive 的深度 observer 能力，监听了它任意属性变化，如果发生变化，便会触发 onFormValuesChange 的生命周期钩子。

同理，默认值管理其实也是一个对象结构的 initialValues 属性，同样会深度监听属性变化，触发 onFormInitialValues 的生命周期钩子。

字段值管理，是在每个数据型字段的 value 属性上体现的，formily 会给每个字段维护一个叫 path 的数据路径属性，然后 value 的读写，都是对顶层表单的 values 进行读写，这样保证了字段的值与表单的值是绝对幂等的，同理字段默认值也一样。

总结一下，**值的管理，都是在顶层表单上管理的，字段的值与表单的值是通过 path 来实现的绝对幂等。**

<Alert>

值与默认值的差别其实就在于表单重置的时候，字段是否会重置为默认值状态

</Alert>

#### 值与默认值的选择合并策略

平时我们在业务开发的过程中，总会有数据回显的需求，这份数据一般都是作为异步默认值，作为详情页面的话，都还好，但是作为编辑页面的话，就会存在一些问题了：

**存在冲突**

比如表单值为`{xx:123}`，表单默认值为`{xx:321}`，这里的策略是：

- 如果`xx`没有相应的字段模型，代表仅仅只是冗余数据，用户无法修改
  - 如果表单值是先赋值，默认值是后赋值的，那么默认值直接覆盖表单值，这种场景适用于异步数据回显场景，不同业务状态，回显的默认数据不一样，最终提交数据`{xx:321}`
  - 如果默认值先赋值，表单值是后赋值的，那么表单值直接覆盖默认值，这种场景适用于同步默认值，最终提交数据`{xx:123}`
- 如果`xx`有字段模型
  - 如果表单值先赋值，默认值是后赋值的
    - 如果当前字段被用户修改过(modified 为 true)，那么默认值不能覆盖表单值，最终提交数据`{xx:123}`
    - 如果当前字段没有被用户修改过(modified 为 false)，那么默认值会直接覆盖字段值，这种场景适用于异步数据回显场景，不同业务状态，回显的默认数据不一样，最终提交数据`{xx:321}`
  - 如果默认值先赋值，表单值是后赋值的，那么表单值直接覆盖默认值，这种场景适用于同步默认值，最终提交数据`{xx:123}`

**不存在冲突**

比如表单值为`{xx:123}`，表单默认值为`{yy:321}`，这里的策略是直接合并。

总结一下，值与默认值的选择合并策略，**核心是看该字段是否被用户修改过，一切以用户为准，如果没被用户修改过就以赋值顺序为准**

<Alert>

这里提到的默认值，是可以重复赋值的，说的也是在重复赋值的过程中，要不要舍弃值的问题。

</Alert>

## 校验模型

表单校验模型核心是对数据的合法性校验，然后将校验结果管理起来，所以校验模型主要包含了：

- 校验规则管理
- 校验结果管理

因为校验模型隶属于字段模型，所以会在后面的[字段模型](/guide/field#校验规则)篇中详细讲解

## 联动模型

联动模型在 formily1.x 中核心是走的主动式联动模型，大致用一句表达式来表达就是：

```ts
setFieldState(Subscribe(FormLifeCycle, Selector(Path)), TargetState)
```

解释下就是，任意一次联动，都是基于表单的某个生命周期钩子去触发指定路径下字段的状态，这样的模型能解决很多问题，但是它也有个很明显的问题，就是在多对一联动的场景下，需要同时监听多个字段变化去控制某个字段的状态，这样对用户而言，实现成本还是比较高的，特别是实现一些计算器联动需求，代码量剧增。当然，对于一对多场景，反而这种模型又是最高效的。

所以，在 formily2.x 中，在主动联动模型上新增了被动联动模型，同样是一句表达式表达：

```ts
subscribe(Dependencies, Reactions)
```

简化了很多，核心就是针对依赖数据变化做响应，依赖的数据可以是表单模型属性，也可以是任意字段模型的属性，响应的动作可以是改任意字段模型的属性，也可以是做其他异步动作。这样的模型同样是一个完备的联动模型，只是在一对多场景下，比起主动模型而言，实现成本会比较高。

所以，两种联动模型，需要用户根据自身需求来选择。

## 路径系统

路径系统，非常重要，几乎整个表单模型处处都有用到路径系统，它的主要给表单模型提供了以下几个能力：

- 它可以用来从字段集中查找任意一个字段，同时支持按照规则批量查找
- 它可以用来表达字段间关系的模型，借助路径系统，我们可以实现查找某个字段父亲，能查找父亲，也就能实现树级别的数据继承能力，同样，我们也能查找某个字段的相邻节点
- 它可以用来实现字段数据的读写，带解构的数据读写

整个路径系统，其实是基于@formily/path 的路径 DSL 来实现的，想要了解更多路径系统的内容，可以详细看看[FormPath API](/api/entry/form-path)篇
</file>

<file path="packages/core/docs/guide/index.md">
# Introduction

## Pure Core,No UI

Because @formily/core exists as an independent package, its core meaning is to separate the domain model from the UI framework, and at the same time, it can bring the following two intuitive benefits to developers:

1. It is convenient for formily developers to release from the coupling relationship between UI and logic, and improve code maintainability;

2. Allow formily to have cross-terminal and cross-framework capabilities. Whether you are a React user, Vue user or Angular user, you can enjoy the efficiency improvement brought by formily's domain model.

## Ultra high performance

With the help of @formily/reactive, @formily/core naturally gains the ability to track dependencies, update efficiently, and render on-demand. Whether it is under React or Vue/Angular, whether it is frequent field input or field linkage, it can give Users bring O(1) performance experience, developers do not need to care about performance optimization, only need to focus on business logic implementation.

## Domain Model

If we break down the form question, we can actually break it down:

- Data management issues
- Field management issues
- Calibration management issues
- Linkage management issues

The problems in these directions can actually be solved as domain-level problems. Each domain problem is actually a very complex problem. In Formily, all of them are solved by breakthroughs, so you only need to focus on business logic. That's it.

## Smart tips

Because formily is a complete Typescript project, users can develop on VSCode or WebStorm to get the maximum intelligent prompt experience

![](https://img.alicdn.com/imgextra/i2/O1CN01yiREHk1X95KJPPz1c_!!6000000002880-2-tps-2014-868.png)

## Status observable

Install [FormilyDevtools](https://chrome.google.com/webstore/detail/formily-devtools/kkocalmbfnplecdmbadaapgapdioecfm?hl=zh-CN) to observe the model status changes in real time and troubleshoot problems

![](//img.alicdn.com/imgextra/i4/O1CN01DSci5h1rAGfRafpXw_!!6000000005590-2-tps-2882-1642.png)
</file>

<file path="packages/core/docs/guide/index.zh-CN.md">
# 介绍

## UI 无关

因为 @formily/core 作为一个独立的包而存在，它的核心意义是将领域模型从 UI 框架中抽离出来，同时给开发者带来了以下两个直观收益：

1. 可以方便 formily 开发者从 UI 与逻辑的耦合关系中释放出来，提升代码可维护性；

2. 可以让 formily 拥有跨终端，跨框架的能力，不管你是 React 用户，Vue 用户还是 Angular 用户，都能享受到 formily 的领域模型带来的提效。

## 超高性能

借助 @formily/reactive，@formily/core 天然获得了依赖追踪，高效更新，按需渲染的能力，不管是在 React 下，还是 Vue/Angular 下，不管是字段频繁输入，还是字段联动，都能给用户带来 O(1)的性能体验，开发者无需关心性能优化的事情，只需要专注于业务逻辑实现即可。

## 领域模型

如果把表单问题做分解，其实我们可以分解出：

- 数据管理问题
- 字段管理问题
- 校验管理问题
- 联动管理问题

这几个方向的问题其实都可以作为领域级问题去解决，每一个领域问题，其实都是非常复杂的问题，在 Formily 中，全部一一给您突破解决了，所以您只需要专注于业务逻辑即可。

## 智能提示

因为 formily 是完全的 Typescript 项目，所以用户在 VSCode 或 WebStorm 等上开发可以获得最大化的智能提示体验

![](https://img.alicdn.com/imgextra/i2/O1CN01yiREHk1X95KJPPz1c_!!6000000002880-2-tps-2014-868.png)

## 状态可观测

安装 [FormilyDevtools](https://chrome.google.com/webstore/detail/formily-devtools/kkocalmbfnplecdmbadaapgapdioecfm?hl=zh-CN) 可以实时观测模型状态变化，排查问题

![](//img.alicdn.com/imgextra/i4/O1CN01DSci5h1rAGfRafpXw_!!6000000005590-2-tps-2882-1642.png)
</file>

<file path="packages/core/docs/guide/mvvm.md">
# MVVM

## OOP architecture

**MVVM** (**Model–view–viewmodel**) is an OOP software architecture model. Its core is to separate the logic and view of our application to improve code maintainability and application robustness. We can use a picture to describe:

![](//img.alicdn.com/imgextra/i3/O1CN01jiB7h723ZFf0lBCTo_!!6000000007269-55-tps-1244-432.svg)

To explain, the View (view layer) is responsible for maintaining the UI structure and style, and is responsible for data binding with the ViewModel (view model). The data binding relationship here is two-way, that is, the ViewModel (view model) data occurs. Changes will trigger the update of the View (view layer), and at the same time changes in the data of the view layer will trigger the changes of the ViewModel (view model). Model is more biased towards the actual business data processing model. Both ViewModel and Model are congested models, and both are injected with business logic from different fields. For example, the business logic of ViewModel is more biased towards the domain logic of the view interaction layer, while the business logic of Model is more biased towards the processing logic of business data.

So, what should the Formily solution be positioned in MVVM?

Obviously, Formily provides two tiers of View and ViewModel capabilities. View is @formily/react @formily/vue, which is specifically used to bridge communication with @formily/core. Therefore, @formily/core is positioned at the ViewModel layer. ,

Where is the Model layer?

Of course it is our actual business code layer, this layer formily will not manage, so at this layer, whether users maintain a Model in OOP mode or maintain a series of business logic function sets in FP mode, formily Don't care.

Therefore, this also makes formily's intrusion into the business very low, because formily's goal is to reduce the cost of users designing ViewModels, allowing users to focus more on the realization of business logic.

## FP architecture

Remember before the React team used the simplest expression **UI = fn(State)** to express the entire React system? Such a functional UI is very simple and clear. Will it conflict with the MVVM model?

There is no conflict, because in the MVVM mode, the relationship between View and ViewModel is actually approximately equal to **UI = fn(State)**, because ViewModel is a congestion model injected with logic, which is related to **fn(State) ** can achieve the same goal, but it is a more OOP expression, but **fn(State)** is a more functional expression, the state exists as an anemia model, through one function after another, Immutable updates to the anemia model are finally reflected in the UI.

Therefore, from the perspective of separation of logic and data, functional expression is clearer, but functional expression requires all data to be Immutable. Therefore, in scenarios with high performance requirements, the benefits of using a functional model will not be too great, of course, this is only the case in the js language. On the contrary, the MVVM model requires more data for Reactive data, that is, a responsive data model that can manipulate data by reference, so that data changes can be accurately monitored, and finally reflected on the UI.

Therefore, in the form scenario, the performance advantage of the MVVM mode will be better. The most important thing is that most of the GUI products that have survived for decades almost all use MVVM coincidentally. It seems that in the front-end field, the function The type system will be more academic. In terms of the actual benefits to the business, MVVM is still the first choice.
</file>

<file path="packages/core/docs/guide/mvvm.zh-CN.md">
# MVVM

## OOP 架构

**MVVM**（**Model–view–viewmodel**）是一种 OOP 软件架构模式，它的核心是将我们的应用程序的逻辑与视图做分离，提升代码可维护性与应用健壮性。我们可以用一张图来描述：

![](//img.alicdn.com/imgextra/i3/O1CN01jiB7h723ZFf0lBCTo_!!6000000007269-55-tps-1244-432.svg)

解释一下就是，View(视图层)负责维护 UI 结构与样式，同时负责与 ViewModel(视图模型)做数据绑定，这里的数据绑定关系是双向的，也就是，ViewModel(视图模型)的数据发生变化，会触发 View(视图层)的更新，同时视图层的数据变化又会触发 ViewModel(视图模型)的变化。Model 则更偏实际业务数据处理模型。ViewModel 和 Model 都是充血模型，两者都注入了不同领域的业务逻辑，比如 ViewModel 的业务逻辑更偏视图交互层的领域逻辑，而 Model 的业务逻辑则更偏业务数据的处理逻辑。

那么，Formily 解决方案在 MVVM 中应该是什么样的定位呢？

很明显，Formily 它提供了 View 和 ViewModel 两层能力，View 则是@formily/react @formily/vue，专门用来与@formily/core 做桥接通讯的，所以，@formily/core 的定位就是 ViewModel 层，

那 Model 层在哪里呢？

当然就是我们的实际业务代码层了，这一层 formily 就不会管了，所以这一层，用户到底是用 OOP 模式维护了一个 Model 还是用 FP 模式维护了一系列的业务逻辑函数集，formily 都不关心。

所以，这也使得 formily 对业务的入侵性很低，因为 formily 的目标是减少用户设计 ViewModel 的成本，让用户更加专注于业务逻辑的实现。

## FP 架构

还记得之前 React 团队用了一个最简单的表达式 **UI = fn(State)** 来表达整个 React 体系吗？这样的函数式表达 UI，非常简单清晰，那会不会和 MVVM 模式产生冲突呢？

并不会冲突，因为在 MVVM 的模式中，View 和 ViewModel 的关系其实就约等于 **UI = fn(State)** ，因为 ViewModel 是一个注入逻辑的充血模型，它与 **fn(State)** 都能达到相同的目标，只是它是更 OOP 的表达，只是**fn(State)** 是一种更加函数式的表达，将状态作为贫血模型而存在，通过一个又一个的函数，对贫血模型做 Immutable 式的更新，最终反应到 UI 上。

所以，从逻辑和数据分离的角度上来看，函数式表达更加清晰，只是函数式表达要求所有数据都是 Immutable 的。所以在性能要求高的场景上，采用函数式模型收益并不会太大，当然只是在 js 语言下是这样的。相反，MVVM 这种模式对数据的要求更多的是 Reactive 数据，也就是可以通过引用式操作数据的响应式数据模型，这样可以做到精确监控数据变化，最终反应到 UI 上。

所以，在表单场景上，MVVM 模式性能优势会更好一些，最重要的是，目前大多数存活了几十年的 GUI 产品，几乎都是不约而同的使用 MVVM，这么看来，在前端领域，函数式体系会更偏学术化一些，从实际对业务的收益来看的话，MVVM 还是首选。
</file>

<file path="packages/core/docs/guide/values.md">
# Data Model
</file>

<file path="packages/core/docs/guide/values.zh-CN.md">
# 数据模型
</file>

<file path="packages/core/docs/index.md">
---
title: Formily-Alibaba unified front-end form solution
order: 10
hero:
  title: Core Library
  desc: Alibaba Unified Form Solution
  actions:
    - text: Home Site
      link: //formilyjs.org
    - text: Document
      link: /guide
features:
  - icon: https://img.alicdn.com/imgextra/i1/O1CN01bHdrZJ1rEOESvXEi5_!!6000000005599-55-tps-800-800.svg
    title: High Performance
    desc: Efficient update, Demand rendering
  - icon: https://img.alicdn.com/imgextra/i3/O1CN0194OqFF1ui6mMT4g7O_!!6000000006070-55-tps-800-800.svg
    title: Excellent Reusability
    desc: Independent side effects, Pluggable
  - icon: https://img.alicdn.com/imgextra/i2/O1CN01QnfYS71E44I1ZpxU9_!!6000000000297-55-tps-800-800.svg
    title: Elegant Linkage Writing
    desc: Flexible, Complete, Elegant
  - icon: https://img.alicdn.com/imgextra/i2/O1CN01YqmcpN1tDalwgyHBH_!!6000000005868-55-tps-800-800.svg
    title: Complete domain model
    desc: Pure Core, No UI, No Framework
  - icon: https://img.alicdn.com/imgextra/i4/O1CN018vDmpl2186xdLu6KI_!!6000000006939-55-tps-800-800.svg
    title: Friendly debugging
    desc: Natural docking with Formily DevTools
  - icon: https://img.alicdn.com/imgextra/i4/O1CN01u6jHgs1ZMwXpjAYnh_!!6000000003181-55-tps-800-800.svg
    title: Smart Tips
    desc: Embrace Typescript
footer: Open-source MIT Licensed | Copyright © 2019-present<br />Powered by self
---

## Installation

```bash
$ npm install --save @formily/core

```

## Quick start

> The following case is to teach you step by step to implement a form from scratch
>
> @formily/core brings you the following capabilities:
>
> 1. Responsive computing capabilities
> 2. Verification capability, verification internationalization capability
> 3. Value Management Ability
> 4. Linkage management capabilities
> 5. Development tool debugging capabilities, [download Formily Devtools](https://chrome.google.com/webstore/detail/formily-devtools/kkocalmbfnplecdmbadaapgapdioecfm?hl=zh-CN)

```tsx
/**
 * defaultShowCode: true
 */
import React, { createContext, useMemo, useContext, useEffect } from 'react'
import { createForm, setValidateLanguage } from '@formily/core'
import { observer } from '@formily/reactive-react'

//Create a context to facilitate Field consumption
const FormContext = createContext()
//Create a context to facilitate the consumption of FormItem
const FieldContext = createContext()

//State bridge component
const Field = observer((props) => {
  const form = useContext(FormContext)
  //Create a field
  const field = form.createField(props)
  useEffect(() => {
    //Mount field
    field.onMount()
    return () => {
      //Unload field
      field.onUnmount()
    }
  })
  if (!field.visible || field.hidden) return null
  //Render the field, associate the field state with the UI component
  const component = React.createElement(field.component[0], {
    ...field.component[1],
    value: field.value,
    onChange: field.onInput,
  })

  //Render field wrapper
  const decorator = React.createElement(
    field.decorator[0],
    field.decorator[1],
    component
  )

  return (
    <FieldContext.Provider value={field}>{decorator}</FieldContext.Provider>
  )
})

// FormItem UI component
const FormItem = observer(({ children }) => {
  const field = useContext(FieldContext)
  return (
    <div>
      <div style={{ height: 20 }}>{field.title}:</div>
      {children}
      <div style={{ height: 20, fontSize: 12, color: 'red' }}>
        {field.selfErrors.join(',')}
      </div>
    </div>
  )
})

// Input UI component
const Input = (props) => {
  return (
    <input
      {...props}
      value={props.value || ''}
      style={{
        ...props.style,
        border: '2px solid rgb(186 203 255)',
        borderRadius: 6,
        width: '100%',
        height: 28,
        padding: '0 5px',
      }}
    />
  )
}

//Form management entrance
const FormProvider = (props) => {
  useEffect(() => {
    //Mount form
    props.form?.onMount()
    return () => {
      //Uninstall the form
      props.form?.onUnmount()
    }
  })
  return (
    <FormContext.Provider value={props.form}>
      {props.children}
    </FormContext.Provider>
  )
}

//Form response monitor
const FormConsumer = observer((props) => {
  const form = useContext(FormContext)
  return <div>{props.children(form)}</div>
})

/*
 * The above logic has been implemented in @formily/react or @formily/vue, and there is no need to rewrite it in actual use
 */

//Switch the built-in check internationalization copy to English
setValidateLanguage('en')

export default () => {
  const form = useMemo(() => createForm({ validateFirst: true }))

  const createPasswordEqualValidate = (equalName) => (field) => {
    if (
      form.values.confirm_password &&
      field.value &&
      form.values[equalName] !== field.value
    ) {
      field.selfErrors = ['Password does not match Confirm Password.']
    } else {
      field.selfErrors = []
    }
  }

  return (
    <FormProvider form={form}>
      <Field
        name="name"
        title="Name"
        required
        decorator={[FormItem]}
        component={[Input, { placeholder: 'Please Input' }]}
      />
      <Field
        name="password"
        title="Password"
        required
        decorator={[FormItem]}
        component={[Input, { type: 'password', placeholder: 'Please Input' }]}
        reactions={createPasswordEqualValidate('confirm_password')}
      />
      <Field
        name="confirm_password"
        title="Confirm Password"
        required
        decorator={[FormItem]}
        component={[Input, { type: 'password', placeholder: 'Please Input' }]}
        reactions={createPasswordEqualValidate('password')}
      />
      <code>
        <pre>
          <FormConsumer>
            {(form) => JSON.stringify(form.values, null, 2)}
          </FormConsumer>
        </pre>
      </code>
    </FormProvider>
  )
}
```
</file>

<file path="packages/core/docs/index.zh-CN.md">
---
title: Formily - 阿里巴巴统一前端表单解决方案
order: 10
hero:
  title: Core Library
  desc: 阿里巴巴统一前端表单解决方案
  actions:
    - text: 主站文档
      link: //formilyjs.org
    - text: 内核文档
      link: /zh-CN/guide
features:
  - icon: https://img.alicdn.com/imgextra/i1/O1CN01bHdrZJ1rEOESvXEi5_!!6000000005599-55-tps-800-800.svg
    title: 超高的性能
    desc: 依赖追踪，高效更新，按需渲染
  - icon: https://img.alicdn.com/imgextra/i3/O1CN0194OqFF1ui6mMT4g7O_!!6000000006070-55-tps-800-800.svg
    title: 极佳的复用性
    desc: 副作用独立，逻辑可拔插
  - icon: https://img.alicdn.com/imgextra/i2/O1CN01QnfYS71E44I1ZpxU9_!!6000000000297-55-tps-800-800.svg
    title: 优雅的联动写法
    desc: 灵活，完备，优雅
  - icon: https://img.alicdn.com/imgextra/i2/O1CN01YqmcpN1tDalwgyHBH_!!6000000005868-55-tps-800-800.svg
    title: 完备的领域模型
    desc: 跨终端，跨框架，UI无关
  - icon: https://img.alicdn.com/imgextra/i4/O1CN018vDmpl2186xdLu6KI_!!6000000006939-55-tps-800-800.svg
    title: 友好的调试体验
    desc: 天然对接Formily DevTools
  - icon: https://img.alicdn.com/imgextra/i4/O1CN01u6jHgs1ZMwXpjAYnh_!!6000000003181-55-tps-800-800.svg
    title: 完美的智能提示
    desc: 拥抱Typescript
footer: Open-source MIT Licensed | Copyright © 2019-present<br />Powered by self
---

## 安装

```bash
$ npm install --save @formily/core

```

## 快速开始

> 以下案例是一步步教您从零实现一个表单
>
> @formily/core 给您带来了以下几个能力：
>
> 1. 响应式计算能力
> 2. 校验能力、校验国际化能力
> 3. 值管理能力
> 4. 联动管理能力
> 5. 开发工具调试能力，[下载 Formily Devtools](https://chrome.google.com/webstore/detail/formily-devtools/kkocalmbfnplecdmbadaapgapdioecfm?hl=zh-CN)

```tsx
/**
 * defaultShowCode: true
 */
import React, { createContext, useMemo, useContext, useEffect } from 'react'
import { createForm, setValidateLanguage } from '@formily/core'
import { observer } from '@formily/reactive-react'

//创建上下文，方便Field消费
const FormContext = createContext()
//创建上下文，方便FormItem消费
const FieldContext = createContext()

//状态桥接器组件
const Field = observer((props) => {
  const form = useContext(FormContext)
  //创建字段
  const field = form.createField(props)
  useEffect(() => {
    //挂载字段
    field.onMount()
    return () => {
      //卸载字段
      field.onUnmount()
    }
  })
  if (!field.visible || field.hidden) return null
  //渲染字段，将字段状态与UI组件关联
  const component = React.createElement(field.component[0], {
    ...field.component[1],
    value: field.value,
    onChange: field.onInput,
  })

  //渲染字段包装器
  const decorator = React.createElement(
    field.decorator[0],
    field.decorator[1],
    component
  )

  return (
    <FieldContext.Provider value={field}>{decorator}</FieldContext.Provider>
  )
})

// FormItem UI组件
const FormItem = observer(({ children }) => {
  const field = useContext(FieldContext)
  return (
    <div>
      <div style={{ height: 20 }}>{field.title}:</div>
      {children}
      <div style={{ height: 20, fontSize: 12, color: 'red' }}>
        {field.selfErrors.join(',')}
      </div>
    </div>
  )
})

// Input UI组件
const Input = (props) => {
  return (
    <input
      {...props}
      value={props.value || ''}
      style={{
        ...props.style,
        border: '2px solid rgb(186 203 255)',
        borderRadius: 6,
        width: '100%',
        height: 28,
        padding: '0 5px',
      }}
    />
  )
}

//表单管理入口
const FormProvider = (props) => {
  useEffect(() => {
    //挂载表单
    props.form?.onMount()
    return () => {
      //卸载表单
      props.form?.onUnmount()
    }
  })
  return (
    <FormContext.Provider value={props.form}>
      {props.children}
    </FormContext.Provider>
  )
}

//表单响应式监控器
const FormConsumer = observer((props) => {
  const form = useContext(FormContext)
  return <div>{props.children(form)}</div>
})

/*
 * 以上逻辑都已经在 @formily/react 或 @formily/vue 中实现，实际使用无需重复编写
 */

//切换内置校验国际化文案为英文
setValidateLanguage('en')

export default () => {
  const form = useMemo(() => createForm({ validateFirst: true }))

  const createPasswordEqualValidate = (equalName) => (field) => {
    if (
      form.values.confirm_password &&
      field.value &&
      form.values[equalName] !== field.value
    ) {
      field.selfErrors = ['Password does not match Confirm Password.']
    } else {
      field.selfErrors = []
    }
  }

  return (
    <FormProvider form={form}>
      <Field
        name="name"
        title="Name"
        required
        decorator={[FormItem]}
        component={[Input, { placeholder: 'Please Input' }]}
      />
      <Field
        name="password"
        title="Password"
        required
        decorator={[FormItem]}
        component={[Input, { type: 'password', placeholder: 'Please Input' }]}
        reactions={createPasswordEqualValidate('confirm_password')}
      />
      <Field
        name="confirm_password"
        title="Confirm Password"
        required
        decorator={[FormItem]}
        component={[Input, { type: 'password', placeholder: 'Please Input' }]}
        reactions={createPasswordEqualValidate('password')}
      />
      <code>
        <pre>
          <FormConsumer>
            {(form) => JSON.stringify(form.values, null, 2)}
          </FormConsumer>
        </pre>
      </code>
    </FormProvider>
  )
}
```
</file>

<file path="packages/react/docs/api/components/ArrayField.md">
---
order: 1
---

# ArrayField

## Description

As @formily/core's [createArrayField](https://core.formilyjs.org/api/models/form#createarrayfield) React implementation, it is a bridge component specifically used to bind ViewModel and input controls, ArrayField component Property reference [IFieldFactoryProps](https://core.formilyjs.org/api/models/form#ifieldfactoryprops)

<Alert>
When we use the ArrayField component, we must remember to pass the name attribute. At the same time, use render props to organize sub-components
</Alert>

## Signature

```ts
type ArrayField = React.FC<React.PropsWithChildren<IFieldFactoryProps>>
```

## Custom component use case

```tsx
import React from 'react'
import { createForm, ArrayField as ArrayFieldType } from '@formily/core'
import {
  FormProvider,
  Field,
  ArrayField,
  useField,
  observer,
} from '@formily/react'
import { Input, Button, Space } from 'antd'

const form = createForm()

const ArrayComponent = observer(() => {
  const field = useField<ArrayFieldType>()
  return (
    <>
      <div>
        {field.value?.map((item, index) => (
          <div key={index} style={{ display: 'flex-block', marginBottom: 10 }}>
            <Space>
              <Field name={index} component={[Input]} />
              <Button
                onClick={() => {
                  field.remove(index)
                }}
              >
                Remove
              </Button>
              <Button
                onClick={() => {
                  field.moveUp(index)
                }}
              >
                Move Up
              </Button>
              <Button
                onClick={() => {
                  field.moveDown(index)
                }}
              >
                Move Down
              </Button>
            </Space>
          </div>
        ))}
      </div>
      <Button
        onClick={() => {
          field.push('')
        }}
      >
        Add
      </Button>
    </>
  )
})

export default () => (
  <FormProvider form={form}>
    <ArrayField name="array" component={[ArrayComponent]} />
  </FormProvider>
)
```

## RenderProps use cases

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, Field, ArrayField } from '@formily/react'
import { Input, Button, Space } from 'antd'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <ArrayField name="array">
      {(field) => {
        return (
          <>
            <div>
              {field.value?.map((item, index) => (
                <div
                  key={index}
                  style={{ display: 'flex-block', marginBottom: 10 }}
                >
                  <Space>
                    <Field name={index} component={[Input]} />
                    <Button
                      onClick={() => {
                        field.remove(index)
                      }}
                    >
                      Remove
                    </Button>
                    <Button
                      onClick={() => {
                        field.moveUp(index)
                      }}
                    >
                      Move Up
                    </Button>
                    <Button
                      onClick={() => {
                        field.moveDown(index)
                      }}
                    >
                      Move Down
                    </Button>
                  </Space>
                </div>
              ))}
            </div>
            <Button onClick={() => field.push('')}>Add</Button>
          </>
        )
      }}
    </ArrayField>
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/components/ArrayField.zh-CN.md">
---
order: 1
---

# ArrayField

## 描述

作为@formily/core 的 [createArrayField](https://core.formilyjs.org/zh-CN/api/models/form#createarrayfield) React 实现，它是专门用于将 ViewModel 与输入控件做绑定的桥接组件，ArrayField 组件属性参考[IFieldFactoryProps](https://core.formilyjs.org/zh-CN/api/models/form#ifieldfactoryprops)

<Alert>
我们在使用 ArrayField 组件的时候，一定要记得传name属性。同时要使用render props形式来组织子组件
</Alert>

## 签名

```ts
type ArrayField = React.FC<React.PropsWithChildren<IFieldFactoryProps>>
```

## 自定义组件用例

```tsx
import React from 'react'
import { createForm, ArrayField as ArrayFieldType } from '@formily/core'
import {
  FormProvider,
  Field,
  ArrayField,
  useField,
  observer,
} from '@formily/react'
import { Input, Button, Space } from 'antd'

const form = createForm()

const ArrayComponent = observer(() => {
  const field = useField<ArrayFieldType>()
  return (
    <>
      <div>
        {field.value?.map((item, index) => (
          <div key={index} style={{ display: 'flex-block', marginBottom: 10 }}>
            <Space>
              <Field name={index} component={[Input]} />
              <Button
                onClick={() => {
                  field.remove(index)
                }}
              >
                Remove
              </Button>
              <Button
                onClick={() => {
                  field.moveUp(index)
                }}
              >
                Move Up
              </Button>
              <Button
                onClick={() => {
                  field.moveDown(index)
                }}
              >
                Move Down
              </Button>
            </Space>
          </div>
        ))}
      </div>
      <Button
        onClick={() => {
          field.push('')
        }}
      >
        Add
      </Button>
    </>
  )
})

export default () => (
  <FormProvider form={form}>
    <ArrayField name="array" component={[ArrayComponent]} />
  </FormProvider>
)
```

## RenderProps 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, Field, ArrayField } from '@formily/react'
import { Input, Button, Space } from 'antd'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <ArrayField name="array">
      {(field) => {
        return (
          <>
            <div>
              {field.value?.map((item, index) => (
                <div
                  key={index}
                  style={{ display: 'flex-block', marginBottom: 10 }}
                >
                  <Space>
                    <Field name={index} component={[Input]} />
                    <Button
                      onClick={() => {
                        field.remove(index)
                      }}
                    >
                      Remove
                    </Button>
                    <Button
                      onClick={() => {
                        field.moveUp(index)
                      }}
                    >
                      Move Up
                    </Button>
                    <Button
                      onClick={() => {
                        field.moveDown(index)
                      }}
                    >
                      Move Down
                    </Button>
                  </Space>
                </div>
              ))}
            </div>
            <Button onClick={() => field.push('')}>Add</Button>
          </>
        )
      }}
    </ArrayField>
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/components/ExpressionScope.md">
---
order: 8
---

# ExpressionScope

## Description

Used to pass local scopes to json-schema expressions inside custom components

## Signature

```ts
interface IExpressionScopeProps {
  value?: any
}
type ExpressionScope = React.FC<React.PropsWithChildren<IExpressionScopeProps>>
```

## Example

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import {
  FormProvider,
  createSchemaField,
  ExpressionScope,
} from '@formily/react'
import { Input } from 'antd'

const form = createForm()

const Container = (props) => {
  return (
    <ExpressionScope value={{ $innerScope: 'this inner scope value' }}>
      {props.children}
    </ExpressionScope>
  )
}

const SchemaField = createSchemaField({
  components: {
    Container,
    Input,
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Void x-component="Container">
        <SchemaField.String
          name="input"
          x-component="Input"
          x-value="{{$innerScope}}"
        />
      </SchemaField.Void>
    </SchemaField>
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/components/ExpressionScope.zh-CN.md">
---
order: 8
---

# ExpressionScope

## 描述

用于自定义组件内部给 json-schema 表达式传递局部作用域

## 签名

```ts
interface IExpressionScopeProps {
  value?: any
}
type ExpressionScope = React.FC<React.PropsWithChildren<IExpressionScopeProps>>
```

## 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import {
  FormProvider,
  createSchemaField,
  ExpressionScope,
} from '@formily/react'
import { Input } from 'antd'

const form = createForm()

const Container = (props) => {
  return (
    <ExpressionScope value={{ $innerScope: 'this inner scope value' }}>
      {props.children}
    </ExpressionScope>
  )
}

const SchemaField = createSchemaField({
  components: {
    Container,
    Input,
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Void x-component="Container">
        <SchemaField.String
          name="input"
          x-component="Input"
          x-value="{{$innerScope}}"
        />
      </SchemaField.Void>
    </SchemaField>
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/components/Field.md">
---
order: 0
---

# Field

## Description

As @formily/core's [createField](https://core.formilyjs.org/api/models/form#createfield) React implementation, it is a bridge component specifically used to bind ViewModel and input controls, the Field component Property reference [IFieldFactoryProps](https://core.formilyjs.org/api/models/form#ifieldfactoryprops)

<Alert>
When we use the Field component, we must remember to pass the name attribute.
</Alert>

## Signature

```ts
type Field = React.FC<React.PropsWithChildren<IFieldFactoryProps>>
```

## Example

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'
import { Input } from 'antd'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field name="input" component={[Input, { placeholder: 'Please Input' }]} />
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/components/Field.zh-CN.md">
---
order: 0
---

# Field

## 描述

作为@formily/core 的 [createField](https://core.formilyjs.org/zh-CN/api/models/form#createfield) React 实现，它是专门用于将 ViewModel 与输入控件做绑定的桥接组件，Field 组件属性参考[IFieldFactoryProps](https://core.formilyjs.org/zh-CN/api/models/form#ifieldfactoryprops)

<Alert>
我们在使用 Field 组件的时候，一定要记得传name属性。
</Alert>

## 签名

```ts
type Field = React.FC<React.PropsWithChildren<IFieldFactoryProps>>
```

## 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'
import { Input } from 'antd'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field name="input" component={[Input, { placeholder: 'Please Input' }]} />
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/components/FormConsumer.md">
---
order: 7
---

# FormConsumer

## Description

The form response consumer is specifically used to monitor the data changes of the form model to implement various UI response components. The use method is render props.

When the dependent data in the callback function changes, the callback function will be re-rendered

## Signature

```ts
type FormConsumer = React.FC<{ children: (form: Form) => React.ReactNode }>
```

Form reference [Form](https://core.formilyjs.org/api/models/form)

## Example

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, FormConsumer, Field } from '@formily/react'
import { Input } from 'antd'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field name="input" component={[Input]} />
    <FormConsumer>{(form) => form.values.input}</FormConsumer>
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/components/FormConsumer.zh-CN.md">
---
order: 7
---

# FormConsumer

## 描述

表单响应消费者，专门用于监听表单模型数据变化而实现各种 UI 响应的组件，使用方式为 render props.

当回调函数内依赖的数据发生变化时就会重新渲染回调函数

## 签名

```ts
type FormConsumer = React.FC<{ children: (form: Form) => React.ReactNode }>
```

Form 参考[Form](https://core.formilyjs.org/zh-CN/api/models/form)

## 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, FormConsumer, Field } from '@formily/react'
import { Input } from 'antd'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field name="input" component={[Input]} />
    <FormConsumer>{(form) => form.values.input}</FormConsumer>
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/components/FormProvider.md">
---
order: 6
---

# FormProvider

## Description

The entry component is used to place the order context to the field component and is responsible for the communication of the entire form state. It is equivalent to a communication hub.

## Signature

```ts
type FormProvider = React.FC<{
  form: Form // form instance created by createForm
}>
```

Form reference [Form](https://core.formilyjs.org/api/models/form)

## Example

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'
import { Input } from 'antd'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field name="input" component={[Input]} />
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/components/FormProvider.zh-CN.md">
---
order: 6
---

# FormProvider

## 描述

入口组件，用于下发表单上下文给字段组件，负责整个表单状态的通讯，它相当于是一个通讯枢纽。

## 签名

```ts
type FormProvider = React.FC<{
  form: Form //通过createForm创建的form实例
}>
```

Form 参考[Form](https://core.formilyjs.org/zh-CN/api/models/form)

## 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'
import { Input } from 'antd'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field name="input" component={[Input]} />
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/components/ObjectField.md">
---
order: 2
---

# ObjectField

## Description

As @formily/core's [createObjectField](https://core.formilyjs.org/api/models/form#createobjectfield) React implementation, it is a bridge component specifically used to bind ViewModel and input controls, ObjectField component Property reference [IFieldFactoryProps](https://core.formilyjs.org/api/models/form#ifieldfactoryprops)

<Alert>
When we use the ObjectField component, we must remember to pass the name attribute. At the same time, use render props to organize sub-components
</Alert>

## Signature

```ts
type ObjectField = React.FC<React.PropsWithChildren<IFieldFactoryProps>>
```

## Custom component use case

```tsx
import React from 'react'
import { createForm, ObjectField as ObjectFieldType } from '@formily/core'
import {
  FormProvider,
  Field,
  ObjectField,
  useField,
  observer,
} from '@formily/react'
import { Input, Button, Space } from 'antd'

const form = createForm()

const ObjectComponent = observer(() => {
  const field = useField<ObjectFieldType>()
  return (
    <>
      <div>
        {Object.keys(field.value || {}).map((key) => (
          <div key={key} style={{ display: 'flex-block', marginBottom: 10 }}>
            <Space>
              <Field name={key} component={[Input, { placeholder: key }]} />
              <Button
                onClick={() => {
                  field.removeProperty(key)
                }}
              >
                Remove
              </Button>
            </Space>
          </div>
        ))}
      </div>
      <Space>
        <Field
          name="propertyName"
          basePath={''}
          required
          component={[Input, { placeholder: 'Property Name' }]}
        />
        <Button
          onClick={() => {
            const name = form.values.propertyName
            if (name && !form.existValuesIn(`${field.path}.${name}`)) {
              field.addProperty(name, '')
              form.deleteValuesIn('propertyName')
            }
          }}
        >
          Add
        </Button>
      </Space>
    </>
  )
})

export default () => (
  <FormProvider form={form}>
    <ObjectField name="object" component={[ObjectComponent]} />
  </FormProvider>
)
```

## RenderProps use cases

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, Field, ObjectField } from '@formily/react'
import { Input, Button, Space } from 'antd'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <ObjectField name="object">
      {(field) => {
        return (
          <>
            <div>
              {Object.keys(field.value || {}).map((key) => (
                <div
                  key={key}
                  style={{ display: 'flex-block', marginBottom: 10 }}
                >
                  <Space>
                    <Field
                      name={key}
                      component={[Input, { placeholder: key }]}
                    />
                    <Button
                      onClick={() => {
                        field.removeProperty(key)
                      }}
                    >
                      Remove
                    </Button>
                  </Space>
                </div>
              ))}
            </div>
            <Space>
              <Field
                name="propertyName"
                basePath={''}
                required
                component={[Input, { placeholder: 'Property Name' }]}
              />
              <Button
                onClick={() => {
                  const name = form.values.propertyName
                  if (name && !form.existValuesIn(`${field.path}.${name}`)) {
                    field.addProperty(name, '')
                    form.deleteValuesIn('propertyName')
                  }
                }}
              >
                Add
              </Button>
            </Space>
          </>
        )
      }}
    </ObjectField>
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/components/ObjectField.zh-CN.md">
---
order: 2
---

# ObjectField

## 描述

作为@formily/core 的 [createObjectField](https://core.formilyjs.org/zh-CN/api/models/form#createobjectfield) React 实现，它是专门用于将 ViewModel 与输入控件做绑定的桥接组件，ObjectField 组件属性参考[IFieldFactoryProps](https://core.formilyjs.org/zh-CN/api/models/form#ifieldfactoryprops)

<Alert>
我们在使用 ObjectField 组件的时候，一定要记得传name属性。同时要使用render props形式来组织子组件
</Alert>

## 签名

```ts
type ObjectField = React.FC<React.PropsWithChildren<IFieldFactoryProps>>
```

## 自定义组件用例

```tsx
import React from 'react'
import { createForm, ObjectField as ObjectFieldType } from '@formily/core'
import {
  FormProvider,
  Field,
  ObjectField,
  useField,
  observer,
} from '@formily/react'
import { Input, Button, Space } from 'antd'

const form = createForm()

const ObjectComponent = observer(() => {
  const field = useField<ObjectFieldType>()
  return (
    <>
      <div>
        {Object.keys(field.value || {}).map((key) => (
          <div key={key} style={{ display: 'flex-block', marginBottom: 10 }}>
            <Space>
              <Field name={key} component={[Input, { placeholder: key }]} />
              <Button
                onClick={() => {
                  field.removeProperty(key)
                }}
              >
                Remove
              </Button>
            </Space>
          </div>
        ))}
      </div>
      <Space>
        <Field
          name="propertyName"
          basePath={''}
          required
          component={[Input, { placeholder: 'Property Name' }]}
        />
        <Button
          onClick={() => {
            const name = form.values.propertyName
            if (name && !form.existValuesIn(`${field.path}.${name}`)) {
              field.addProperty(name, '')
              form.deleteValuesIn('propertyName')
            }
          }}
        >
          Add
        </Button>
      </Space>
    </>
  )
})

export default () => (
  <FormProvider form={form}>
    <ObjectField name="object" component={[ObjectComponent]} />
  </FormProvider>
)
```

## RenderProps 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, Field, ObjectField } from '@formily/react'
import { Input, Button, Space } from 'antd'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <ObjectField name="object">
      {(field) => {
        return (
          <>
            <div>
              {Object.keys(field.value || {}).map((key) => (
                <div
                  key={key}
                  style={{ display: 'flex-block', marginBottom: 10 }}
                >
                  <Space>
                    <Field
                      name={key}
                      component={[Input, { placeholder: key }]}
                    />
                    <Button
                      onClick={() => {
                        field.removeProperty(key)
                      }}
                    >
                      Remove
                    </Button>
                  </Space>
                </div>
              ))}
            </div>
            <Space>
              <Field
                name="propertyName"
                basePath={''}
                required
                component={[Input, { placeholder: 'Property Name' }]}
              />
              <Button
                onClick={() => {
                  const name = form.values.propertyName
                  if (name && !form.existValuesIn(`${field.path}.${name}`)) {
                    field.addProperty(name, '')
                    form.deleteValuesIn('propertyName')
                  }
                }}
              >
                Add
              </Button>
            </Space>
          </>
        )
      }}
    </ObjectField>
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/components/RecordScope.md">
---
order: 9
---

# RecordScope

## Description

Standard scoped injection component for injecting the following built-in variables:

- `$record` current record data
- `$record.$lookup` The parent record of the current record, you can always look up
- `$record.$index` the index of the current record
- `$index` The current record index, equivalent to `$record.$index`, considering that if the record data is not an object, it needs to be read independently
- `$lookup` The parent record of the current record, equivalent to `$record.$lookup`, considering that if the record data is not an object, it needs to be read independently

## Signature

```ts
interface IRecordScopeProps {
  getRecord(): any
  getIndex?(): number
}

type RecordScope = React.FC<React.PropsWithChildren<IRecordScopeProps>>
```

## Usage

Any auto-increment list extension component should use RecordScope internally to pass record scope variables. Components that have implemented this convention include:
All components of the ArrayX family in @formily/antd and @formily/next

## Custom component extension use case

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField, RecordScope } from '@formily/react'
import { Input } from 'antd'

const form = createForm()

const MyCustomComponent = (props) => {
  return (
    <RecordScope getRecord={() => props.record} getIndex={() => props.index}>
      {props.children}
    </RecordScope>
  )
}

const SchemaField = createSchemaField({
  components: {
    Input,
    MyCustomComponent,
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField
      schema={{
        type: 'object',
        properties: {
          lookup: {
            type: 'void',
            'x-component': 'MyCustomComponent',
            'x-component-props': {
              record: {
                name: 'Lookup Name',
                code: 'Lookup Code',
              },
              index: 1,
            },
            properties: {
              record: {
                type: 'void',
                'x-component': 'MyCustomComponent',
                'x-component-props': {
                  record: {
                    name: 'Name',
                    code: 'Code',
                  },
                  index: 0,
                },
                properties: {
                  input: {
                    type: 'string',
                    'x-component': 'Input',
                    'x-value':
                      '{{`' +
                      '${$record.name} ' +
                      '${$record.code} ' +
                      '${$record.$index} ' +
                      '${$record.$lookup.name} ' +
                      '${$record.$lookup.code} ' +
                      '${$index} ' +
                      '${$lookup.name} ' +
                      '${$lookup.code} ' +
                      '`}}',
                  },
                },
              },
            },
          },
        },
      }}
    ></SchemaField>
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/components/RecordScope.zh-CN.md">
---
order: 9
---

# RecordScope

## 描述

标准作用域注入组件，用于注入以下内置变量：

- `$record` 当前记录数据
- `$record.$lookup` 当前记录的父级记录，可以一直往上查找
- `$record.$index` 当前记录的索引
- `$index` 当前记录索引，等同于`$record.$index`，考虑到记录数据如果不是对象，则需要独立读取
- `$lookup` 当前记录的父级记录，等同于`$record.$lookup`，考虑到记录数据如果不是对象，则需要独立读取

## 签名

```ts
interface IRecordScopeProps {
  getRecord(): any
  getIndex?(): number
}

type RecordScope = React.FC<React.PropsWithChildren<IRecordScopeProps>>
```

## 使用约定

任何自增列表扩展组件，内部都应该使用 RecordScope，用于传递记录作用域变量，目前已实现该约定的组件包括：
@formily/antd 和 @formily/next 中的 ArrayX 系列的所有组件

## 自定义组件扩展用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField, RecordScope } from '@formily/react'
import { Input } from 'antd'

const form = createForm()

const MyCustomComponent = (props) => {
  return (
    <RecordScope getRecord={() => props.record} getIndex={() => props.index}>
      {props.children}
    </RecordScope>
  )
}

const SchemaField = createSchemaField({
  components: {
    Input,
    MyCustomComponent,
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField
      schema={{
        type: 'object',
        properties: {
          lookup: {
            type: 'void',
            'x-component': 'MyCustomComponent',
            'x-component-props': {
              record: {
                name: 'Lookup Name',
                code: 'Lookup Code',
              },
              index: 1,
            },
            properties: {
              record: {
                type: 'void',
                'x-component': 'MyCustomComponent',
                'x-component-props': {
                  record: {
                    name: 'Name',
                    code: 'Code',
                  },
                  index: 0,
                },
                properties: {
                  input: {
                    type: 'string',
                    'x-component': 'Input',
                    'x-value':
                      '{{`' +
                      '${$record.name} ' +
                      '${$record.code} ' +
                      '${$record.$index} ' +
                      '${$record.$lookup.name} ' +
                      '${$record.$lookup.code} ' +
                      '${$index} ' +
                      '${$lookup.name} ' +
                      '${$lookup.code} ' +
                      '`}}',
                  },
                },
              },
            },
          },
        },
      }}
    ></SchemaField>
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/components/RecordsScope.md">
---
order: 10
---

# RecordsScope

## Description

Standard scoped injection component for injecting the following built-in variables:

- `$records` current record list data

## Signature

```ts
interface IRecordsScopeProps {
  getRecords(): any[]
}

type RecordsScope = React.FC<React.PropsWithChildren<IRecordsScopeProps>>
```

## Usage

Any auto-incrementing list extension component should use RecordsScope internally to pass record scope variables. Components that have implemented this convention include:
All components of the ArrayX family in @formily/antd and @formily/next

## Custom component extension use case

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField, RecordsScope } from '@formily/react'
import { Input } from 'antd'

const form = createForm()

const MyCustomComponent = (props) => {
  return (
    <RecordsScope getRecords={() => props.records}>
      {props.children}
    </RecordsScope>
  )
}

const SchemaField = createSchemaField({
  components: {
    Input,
    MyCustomComponent,
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField
      schema={{
        type: 'object',
        properties: {
          records: {
            type: 'void',
            'x-component': 'MyCustomComponent',
            'x-component-props': {
              records: [
                {
                  name: 'Name',
                  code: 'Code',
                },
              ],
            },
            properties: {
              input: {
                type: 'string',
                'x-component': 'Input',
                'x-value':
                  '{{`' +
                  '${$records[0].name} ' +
                  '${$records[0].code}' +
                  '`}}',
              },
            },
          },
        },
      }}
    ></SchemaField>
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/components/RecordsScope.zh-CN.md">
---
order: 10
---

# RecordsScope

## 描述

标准作用域注入组件，用于注入以下内置变量：

- `$records` 当前记录列表数据

## 签名

```ts
interface IRecordsScopeProps {
  getRecords(): any[]
}

type RecordsScope = React.FC<React.PropsWithChildren<IRecordsScopeProps>>
```

## 使用约定

任何自增列表扩展组件，内部都应该使用 RecordsScope，用于传递记录作用域变量，目前已实现该约定的组件包括：
@formily/antd 和 @formily/next 中的 ArrayX 系列的所有组件

## 自定义组件扩展用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField, RecordsScope } from '@formily/react'
import { Input } from 'antd'

const form = createForm()

const MyCustomComponent = (props) => {
  return (
    <RecordsScope getRecords={() => props.records}>
      {props.children}
    </RecordsScope>
  )
}

const SchemaField = createSchemaField({
  components: {
    Input,
    MyCustomComponent,
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField
      schema={{
        type: 'object',
        properties: {
          records: {
            type: 'void',
            'x-component': 'MyCustomComponent',
            'x-component-props': {
              records: [
                {
                  name: 'Name',
                  code: 'Code',
                },
              ],
            },
            properties: {
              input: {
                type: 'string',
                'x-component': 'Input',
                'x-value':
                  '{{`' +
                  '${$records[0].name} ' +
                  '${$records[0].code} ' +
                  '`}}',
              },
            },
          },
        },
      }}
    ></SchemaField>
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/components/RecursionField.md">
---
order: 5
---

# RecursionField

## Description

The recursive rendering component is mainly based on [JSON-Schema](/api/shared/schema) for recursive rendering. It is the core rendering component inside the [SchemaField](/api/components/schema-field) component. Of course, it can It is used separately from SchemaField. When we use it, it is mainly used in custom components to implement custom components with recursive rendering capabilities.

## Signature

```ts
interface IRecursionFieldProps {
  schema: ISchema //Field schema
  name?: string //Path name
  basePath?: FormPathPattern //base path
  propsRecursion?: boolean //Whether to recursiveliy pass mapProperties and filterProperties
  onlyRenderProperties?: boolean //Whether to only render properties
  onlyRenderSelf?: boolean //Whether to only render itself without rendering properties
  mapProperties?: (schema: Schema, name: string) => Schema //schema properties mapper, mainly used to rewrite the schema
  filterProperties?: (schema: Schema, name: string) => boolean //schema properties filter, the filtered schema nodes will not be rendered
}

type RecursionField = React.FC<React.PropsWithChildren<IRecursionFieldProps>>
```

## Example

### Simple recursion

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField, RecursionField } from '@formily/react'
import { Input } from 'antd'

const form = createForm()

const Custom = (props) => {
  return <RecursionField schema={props.schema} onlyRenderProperties />
}

const SchemaField = createSchemaField({
  components: {
    Custom,
    Input,
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Object
        name="custom"
        x-component="Custom"
        x-component-props={{
          schema: {
            type: 'object',
            properties: {
              input: {
                type: 'string',
                'x-component': 'Input',
              },
            },
          },
        }}
      />
    </SchemaField>
  </FormProvider>
)
```

We can read independent schema objects from component properties and pass them to RecursionField for rendering

### Incremental list recursion

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import {
  FormProvider,
  createSchemaField,
  RecursionField,
  useField,
  useFieldSchema,
  observer,
} from '@formily/react'
import { Input, Space, Button } from 'antd'

const form = createForm()

const ArrayItems = observer((props) => {
  const field = useField()
  const schema = useFieldSchema()
  return (
    <div>
      {props.value?.map((item, index) => {
        return (
          <div key={index} style={{ marginBottom: 10 }}>
            <Space>
              <RecursionField schema={schema.items} name={index} />
              <Button
                onClick={() => {
                  field.remove(index)
                }}
              >
                Remove
              </Button>
            </Space>
          </div>
        )
      })}
      <Button
        onClick={() => {
          field.push({})
        }}
      >
        Add
      </Button>
    </div>
  )
})

const SchemaField = createSchemaField({
  components: {
    ArrayItems,
    Input,
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Array name="custom" x-component="ArrayItems">
        <SchemaField.Object>
          <SchemaField.String name="input" x-component="Input" />
        </SchemaField.Object>
      </SchemaField.Array>
    </SchemaField>
  </FormProvider>
)
```

Use [useField](/api/hooks/useField) and [useFieldSchema](/api/shared/use-field-schema) to get the field instance and field schema in the current field context
</file>

<file path="packages/react/docs/api/components/RecursionField.zh-CN.md">
---
order: 5
---

# RecursionField

## 描述

递归渲染组件，主要基于[JSON-Schema](/api/shared/schema)做递归渲染，它是[SchemaField](/api/components/schema-field)组件内部的核心渲染组件，当然，它是可以独立于 SchemaField 单独使用的，我们使用的时候主要是在自定义组件中使用，用于实现具有递归渲染能力的自定义组件

## 签名

```ts
interface IRecursionFieldProps {
  schema: ISchema //字段schema
  name?: string //路径名称
  basePath?: FormPathPattern //基础路径
  propsRecursion?: boolean //是否递归传递 mapProperties 和 filterProperties
  onlyRenderProperties?: boolean //是否只渲染properties
  onlyRenderSelf?: boolean //是否只渲染自身，不渲染properties
  mapProperties?: (schema: Schema, name: string) => Schema //schema properties映射器，主要用于改写schema
  filterProperties?: (schema: Schema, name: string) => boolean //schema properties过滤器，被过滤掉的schema节点不会被渲染
}

type RecursionField = React.FC<React.PropsWithChildren<IRecursionFieldProps>>
```

## 用例

### 简单递归

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField, RecursionField } from '@formily/react'
import { Input } from 'antd'

const form = createForm()

const Custom = (props) => {
  return <RecursionField schema={props.schema} onlyRenderProperties />
}

const SchemaField = createSchemaField({
  components: {
    Custom,
    Input,
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Object
        name="custom"
        x-component="Custom"
        x-component-props={{
          schema: {
            type: 'object',
            properties: {
              input: {
                type: 'string',
                'x-component': 'Input',
              },
            },
          },
        }}
      />
    </SchemaField>
  </FormProvider>
)
```

我们可以从组件属性中读取独立的 schema 对象，传给 RecursionField 渲染

### 自增列表递归

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import {
  FormProvider,
  createSchemaField,
  RecursionField,
  useField,
  useFieldSchema,
  observer,
} from '@formily/react'
import { Input, Space, Button } from 'antd'

const form = createForm()

const ArrayItems = observer((props) => {
  const field = useField()
  const schema = useFieldSchema()
  return (
    <div>
      {props.value?.map((item, index) => {
        return (
          <div key={index} style={{ marginBottom: 10 }}>
            <Space>
              <RecursionField schema={schema.items} name={index} />
              <Button
                onClick={() => {
                  field.remove(index)
                }}
              >
                Remove
              </Button>
            </Space>
          </div>
        )
      })}
      <Button
        onClick={() => {
          field.push({})
        }}
      >
        Add
      </Button>
    </div>
  )
})

const SchemaField = createSchemaField({
  components: {
    ArrayItems,
    Input,
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Array name="custom" x-component="ArrayItems">
        <SchemaField.Object>
          <SchemaField.String name="input" x-component="Input" />
        </SchemaField.Object>
      </SchemaField.Array>
    </SchemaField>
  </FormProvider>
)
```

使用[useField](/api/hooks/useField)和[useFieldSchema](/api/shared/use-field-schema)来获取当前字段上下文中的字段实例和字段 schema
</file>

<file path="packages/react/docs/api/components/SchemaField.md">
---
order: 4
---

# SchemaField

## Description

The SchemaField component is a component specially used to parse [JSON-Schema](/api/shared/schema) dynamically rendering forms.
When using the SchemaField component, you need to create a SchemaField component through the createSchemaField factory function.

## Signature

```ts
//SchemaField component and its static properties
type ComposeSchemaField = React.FC<
  React.PropsWithChildren<ISchemaFieldProps>
> & {
  Markup: React.FC<React.PropsWithChildren<ISchema>>
  String: React.FC<React.PropsWithChildren<Omit<ISchema, 'type'>>>
  Object: React.FC<React.PropsWithChildren<Omit<ISchema, 'type'>>>
  Array: React.FC<React.PropsWithChildren<Omit<ISchema, 'type'>>>
  Date: React.FC<React.PropsWithChildren<Omit<ISchema, 'type'>>>
  DateTime: React.FC<React.PropsWithChildren<Omit<ISchema, 'type'>>>
  Boolean: React.FC<React.PropsWithChildren<Omit<ISchema, 'type'>>>
  Number: React.FC<React.PropsWithChildren<Omit<ISchema, 'type'>>>
  Void: React.FC<React.PropsWithChildren<Omit<ISchema, 'type'>>>
}

//Factory function parameter attributes
interface ISchemaFieldFactoryProps {
  components?: {
    [key: string]: React.FC //Component list
  }
  scope?: any //Global scope, used to implement protocol expression variable injection
}

//SchemaField attribute
interface ISchemaFieldProps extends IFieldFactoryProps {
  schema?: ISchema //Field schema
  scope?: any //Protocol expression scope
  name?: string //Field name
  components?: {
    [key: string]: React.FC //Partial component list, note: the components passed here cannot enjoy smart prompts
  }
}

//Factory function
interface createSchemaField {
  (props: ISchemaFieldFactoryProps): ComposeSchemaField
}
```

IFieldFactoryProps reference [IFieldFactoryProps](https://core.formilyjs.org/api/models/form#ifieldfactoryprops)

ISchema Reference [ISchema](/api/shared/schema#ischema)

## Markup Schema Use Case

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Input, Select } from 'antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    Input,
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField
      components={{
        Select,
      }}
    >
      <SchemaField.String name="input" x-component="Input" />
      <SchemaField.String
        name="select"
        x-component="Select"
        x-component-props={{
          style: {
            width: 200,
            marginTop: 20,
          },
        }}
      />
    </SchemaField>
  </FormProvider>
)
```

## JSON Schema Use Case

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Input, Select } from 'antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    Input,
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField
      components={{
        Select,
      }}
      schema={{
        type: 'object',
        properties: {
          input: {
            type: 'string',
            'x-component': 'Input',
          },
          select: {
            type: 'string',
            'x-component': 'Select',
            'x-component-props': {
              style: {
                width: 200,
                marginTop: 20,
              },
            },
          },
        },
      }}
    ></SchemaField>
  </FormProvider>
)
```

## JSON Schema ReactNode Prop Use Case （x-slot-node）

Reference [Slot](https://react.formilyjs.org/api/shared/schema#slot)

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Input, Tag } from 'antd'
import { CheckCircleTwoTone, CloseCircleOutlined } from '@ant-design/icons'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    Input,
    CheckCircleTwoTone,
    CloseCircleOutlined,
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField
      components={{
        Tag,
      }}
      schema={{
        type: 'object',
        properties: {
          tag: {
            'x-slot-node': {
              target: 'input.x-component-props.prefix',
            },
            'x-component': 'Tag',
            'x-component-props': {
              children: 'www.',
            },
          },
          tag2: {
            'x-slot-node': {
              target: 'input.x-component-props.suffix',
            },
            'x-component': 'Tag',
            'x-component-props': {
              children: '.com',
            },
          },
          icon: {
            'x-slot-node': {
              target: 'input.x-component-props.addonAfter',
            },
            'x-component':
              '{{$form.values.input?.length > 5 ? "CheckCircleTwoTone" : "CloseCircleOutlined"}}',
          },
          input: {
            type: 'string',
            'x-component': 'Input',
            'x-component-props': {},
          },
        },
      }}
    ></SchemaField>
  </FormProvider>
)
```

## JSON Schema Render Prop Use Case （x-slot-node & isRenderProp）

Reference [Slot](https://react.formilyjs.org/api/shared/schema#slot)

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Rate } from 'antd'
import { DollarOutlined } from '@ant-design/icons'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    DollarOutlined,
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField
      components={{
        Rate,
      }}
      schema={{
        type: 'object',
        properties: {
          icon: {
            'x-slot-node': {
              target: 'rate.x-component-props.character',
              isRenderProp: true,
            },
            'x-component': 'DollarOutlined',
            'x-component-props': {
              rotate: '{{ $slotArgs[0].value * 45 }}',
              style: {
                fontSize: '50px',
              },
            },
          },
          rate: {
            'x-component': 'Rate',
            'x-component-props': {
              defaultValue: 3,
            },
          },
        },
      }}
    ></SchemaField>
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/components/SchemaField.zh-CN.md">
---
order: 4
---

# SchemaField

## 描述

SchemaField 组件是专门用于解析[JSON-Schema](/api/shared/schema)动态渲染表单的组件。
在使用 SchemaField 组件的时候，需要通过 createSchemaField 工厂函数创建一个 SchemaField 组件。

## 签名

```ts
//SchemaField组件与其静态属性
type ComposeSchemaField = React.FC<
  React.PropsWithChildren<ISchemaFieldProps>
> & {
  Markup: React.FC<React.PropsWithChildren<ISchema>>
  String: React.FC<React.PropsWithChildren<Omit<ISchema, 'type'>>>
  Object: React.FC<React.PropsWithChildren<Omit<ISchema, 'type'>>>
  Array: React.FC<React.PropsWithChildren<Omit<ISchema, 'type'>>>
  Date: React.FC<React.PropsWithChildren<Omit<ISchema, 'type'>>>
  DateTime: React.FC<React.PropsWithChildren<Omit<ISchema, 'type'>>>
  Boolean: React.FC<React.PropsWithChildren<Omit<ISchema, 'type'>>>
  Number: React.FC<React.PropsWithChildren<Omit<ISchema, 'type'>>>
  Void: React.FC<React.PropsWithChildren<Omit<ISchema, 'type'>>>
}

//工厂函数参数属性
interface ISchemaFieldFactoryProps {
  components?: {
    [key: string]: React.FC //组件列表
  }
  scope?: any //全局作用域，用于实现协议表达式变量注入
}

//SchemaField属性
interface ISchemaFieldProps extends IFieldFactoryProps {
  schema?: ISchema //字段schema
  scope?: any //协议表达式作用域
  name?: string //字段名称
  components?: {
    [key: string]: React.FC //局部组件列表，注意：这里传的组件是享受不到智能提示的
  }
}

//工厂函数
interface createSchemaField {
  (props: ISchemaFieldFactoryProps): ComposeSchemaField
}
```

IFieldFactoryProps 参考 [IFieldFactoryProps](https://core.formilyjs.org/zh-CN/api/models/form#ifieldfactoryprops)

ISchema 参考 [ISchema](/api/shared/schema#ischema)

## Markup Schema 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Input, Select } from 'antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    Input,
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField
      components={{
        Select,
      }}
    >
      <SchemaField.String name="input" x-component="Input" />
      <SchemaField.String
        name="select"
        x-component="Select"
        x-component-props={{
          style: {
            width: 200,
            marginTop: 20,
          },
        }}
      />
    </SchemaField>
  </FormProvider>
)
```

## JSON Schema 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Input, Select } from 'antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    Input,
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField
      components={{
        Select,
      }}
      schema={{
        type: 'object',
        properties: {
          input: {
            type: 'string',
            'x-component': 'Input',
          },
          select: {
            type: 'string',
            'x-component': 'Select',
            'x-component-props': {
              style: {
                width: 200,
                marginTop: 20,
              },
            },
          },
        },
      }}
    ></SchemaField>
  </FormProvider>
)
```

## JSON Schema ReactNode Prop 用例 （x-slot-node）

参考[Slot](https://react.formilyjs.org/zh-CN/api/shared/schema#slot)

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Input, Tag } from 'antd'
import { CheckCircleTwoTone } from '@ant-design/icons'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    Input,
    CheckCircleTwoTone,
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField
      components={{
        Tag,
      }}
      schema={{
        type: 'object',
        properties: {
          tag: {
            'x-slot-node': {
              target: 'input.x-component-props.prefix',
            },
            'x-component': 'Tag',
            'x-component-props': {
              children: 'www.',
            },
          },
          tag2: {
            'x-slot-node': {
              target: 'input.x-component-props.suffix',
            },
            'x-component': 'Tag',
            'x-component-props': {
              children: '.com',
            },
          },
          icon: {
            'x-slot-node': {
              target: 'input.x-component-props.addonAfter',
            },
            'x-component':
              '{{$form.values.input?.length > 5 ? "CheckCircleTwoTone" : "CloseCircleOutlined"}}',
          },
          input: {
            type: 'string',
            'x-component': 'Input',
            'x-component-props': {},
          },
        },
      }}
    ></SchemaField>
  </FormProvider>
)
```

## JSON Schema Render Prop 用例 （x-slot-node & isRenderProp）

参考[Slot](https://react.formilyjs.org/zh-CN/api/shared/schema#slot)

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Rate } from 'antd'
import { DollarOutlined } from '@ant-design/icons'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    DollarOutlined,
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField
      components={{
        Rate,
      }}
      schema={{
        type: 'object',
        properties: {
          icon: {
            'x-slot-node': {
              target: 'rate.x-component-props.character',
              isRenderProp: true,
            },
            'x-component': 'DollarOutlined',
            'x-component-props': {
              rotate: '{{ $slotArgs[0].value * 45 }}',
              style: {
                fontSize: '50px',
              },
            },
          },
          rate: {
            'x-component': 'Rate',
            'x-component-props': {
              defaultValue: 3,
            },
          },
        },
      }}
    ></SchemaField>
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/components/VoidField.md">
---
order: 3
---

# VoidField

## Description

As @formily/core's [createVoidField](https://core.formilyjs.org/api/models/form#createvoidfield) React implementation, it is a bridge component specifically used to bind ViewModel and virtual layout controls. Used to control the display and hide of data type fields, interactive mode, etc., VoidField component properties refer to [IVoidFieldFactoryProps](https://core.formilyjs.org/api/models/form#ivoidfieldfactoryprops)

<Alert>
When we use the VoidField component, we must remember to pass the name attribute.
</Alert>

## Signature

```ts
type VoidField = React.FC<React.PropsWithChildren<IVoidFieldFactoryProps>>
```

## Example

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, FormConsumer, Field, VoidField } from '@formily/react'
import { Input, Button, Space } from 'antd'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Space>
      <VoidField name="layout">
        <Field name="input" component={[Input]} />
      </VoidField>
      <FormConsumer>
        {() => (
          <Space>
            <Button
              onClick={() => {
                form
                  .query('layout')
                  .take()
                  .setState((state) => {
                    state.visible = !state.visible
                  })
              }}
            >
              {form.query('layout').get('visible') ? 'Hide' : 'Show'}
            </Button>
            <div>{JSON.stringify(form.values, null, 2)}</div>
          </Space>
        )}
      </FormConsumer>
    </Space>
  </FormProvider>
)
```

This example demonstrates how to use VoidField to control the display and hiding of child nodes. Observe that when the VoidField is hidden, the data of the child nodes will be cleared at the same time, because visible is false, which means display is none. This kind of hiding does not retain the field value.

But when it is displayed again, the scene will be restored again. This is the internal feature of Formily Core, which supports the ability to completely restore the scene.
</file>

<file path="packages/react/docs/api/components/VoidField.zh-CN.md">
---
order: 3
---

# VoidField

## 描述

作为@formily/core 的 [createVoidField](https://core.formilyjs.org/zh-CN/api/models/form#createvoidfield) React 实现，它是专门用于将 ViewModel 与虚拟布局控件做绑定的桥接组件，可以用来控制数据型字段的显示隐藏，交互模式等，VoidField 组件属性参考[IVoidFieldFactoryProps](https://core.formilyjs.org/zh-CN/api/models/form#ivoidfieldfactoryprops)

<Alert>
我们在使用 VoidField 组件的时候，一定要记得传name属性。
</Alert>

## 签名

```ts
type VoidField = React.FC<React.PropsWithChildren<IVoidFieldFactoryProps>>
```

## 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, FormConsumer, Field, VoidField } from '@formily/react'
import { Input, Button, Space } from 'antd'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Space>
      <VoidField name="layout">
        <Field name="input" component={[Input]} />
      </VoidField>
      <FormConsumer>
        {() => (
          <Space>
            <Button
              onClick={() => {
                form
                  .query('layout')
                  .take()
                  .setState((state) => {
                    state.visible = !state.visible
                  })
              }}
            >
              {form.query('layout').get('visible') ? 'Hide' : 'Show'}
            </Button>
            <div>{JSON.stringify(form.values, null, 2)}</div>
          </Space>
        )}
      </FormConsumer>
    </Space>
  </FormProvider>
)
```

该例子演示了如何用 VoidField 控制子节点显示隐藏，注意观察，VoidField 隐藏的时候，子节点的数据会同时被清空，因为 visible 为 false 代表 display 为 none，这种隐藏是不会保留字段值的。

但是再次显示的时候，又会恢复现场，这里是 Formily Core 内部的特性，支持完全恢复现场的能力。
</file>

<file path="packages/react/docs/api/hooks/useExpressionScope.md">
# useExpressionScope

## Description

The expression scope is mainly read in the custom component. The sources of the expression scope are:

- createSchemaField top-level delivery
- SchemaField component attribute delivery
- ExpressionScope/RecordScope/RecordsScope are issued inside custom components

## Signature

```ts
interface useExpressionScope {
  (): any
}
```

## Example

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import {
  FormProvider,
  createSchemaField,
  useExpressionScope,
  RecordScope,
} from '@formily/react'

const form = createForm()

const Custom = () => {
  const scope = useExpressionScope()
  return (
    <code>
      <pre>{JSON.stringify(scope, null, 2)}</pre>
    </code>
  )
}

const SchemaField = createSchemaField({
  components: {
    Custom,
  },
  scope: {
    topScope: {
      aa: 123,
    },
  },
})

export default () => (
  <FormProvider form={form}>
    <RecordScope
      getRecord={() => ({ name: 'Record Name', code: 'Record Code' })}
      getIndex={() => 2}
    >
      <SchemaField scope={{ propsScope: { bb: 321 } }}>
        <SchemaField.String name="custom" x-component="Custom" />
      </SchemaField>
    </RecordScope>
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/hooks/useExpressionScope.zh-CN.md">
# useExpressionScope

## 描述

主要在自定义组件中读取表达式作用域，表达式作用域的来源主要有：

- createSchemaField 顶层下发
- SchemaField 组件属性下发
- ExpressionScope/RecordScope/RecordsScope 自定义组件内部下发

## 签名

```ts
interface useExpressionScope {
  (): any
}
```

## 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import {
  FormProvider,
  createSchemaField,
  useExpressionScope,
  RecordScope,
} from '@formily/react'

const form = createForm()

const Custom = () => {
  const scope = useExpressionScope()
  return (
    <code>
      <pre>{JSON.stringify(scope, null, 2)}</pre>
    </code>
  )
}

const SchemaField = createSchemaField({
  components: {
    Custom,
  },
  scope: {
    topScope: {
      aa: 123,
    },
  },
})

export default () => (
  <FormProvider form={form}>
    <RecordScope
      getRecord={() => ({ name: 'Record Name', code: 'Record Code' })}
      getIndex={() => 2}
    >
      <SchemaField scope={{ propsScope: { bb: 321 } }}>
        <SchemaField.String name="custom" x-component="Custom" />
      </SchemaField>
    </RecordScope>
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/hooks/useField.md">
# useField

## Description

Mainly used in custom components to read current field properties, manipulate field status, etc. It can be used in the subtree of all Field components. Note that the one you get is [GeneralField](https://core.formilyjs.org/ api/models/field#generalfield), if you need to process different types of fields, please use [Type Checker](https://core.formilyjs.org/api/entry/form-checker)

<Alert>
Note: If you want to use useField in a custom component and respond to changes in the field model, you need to wrap the observer for the custom component
</Alert>

## Signature

```ts
interface useField {
  (): Field
}
```

## Example

```tsx
import React, { useMemo } from 'react'
import { createForm } from '@formily/core'
import {
  FormProvider,
  FormConsumer,
  Field,
  useField,
  observer,
} from '@formily/react'
import { Input, Form, Button } from 'antd'

// FormItem UI component
const FormItem = observer(({ children }) => {
  const field = useField()
  return (
    <Form.Item
      label={field.title}
      help={field.selfErrors?.length ? field.selfErrors : undefined}
      extra={field.description}
      validateStatus={field.validateStatus}
    >
      {children}
    </Form.Item>
  )
})

export default () => {
  const form = useMemo(() => createForm({ validateFirst: true }))
  return (
    <FormProvider form={form}>
      <Form layout="vertical">
        <Field
          name="name"
          title="Name"
          required
          decorator={[FormItem]}
          component={[Input, { placeholder: 'Please Input' }]}
        />
        <code>
          <pre>
            <FormConsumer>
              {(form) => JSON.stringify(form.values, null, 2)}
            </FormConsumer>
          </pre>
        </code>
        <Button
          type="primary"
          onClick={() => {
            form.submit(console.log)
          }}
        >
          Submit
        </Button>
      </Form>
    </FormProvider>
  )
}
```
</file>

<file path="packages/react/docs/api/hooks/useField.zh-CN.md">
# useField

## 描述

主要用在自定义组件内读取当前字段属性，操作字段状态等，在所有 Field 组件的子树内都能使用，注意，拿到的是[GeneralField](https://core.formilyjs.org/zh-CN/api/models/field#generalfield)，如果需要对不同类型的字段做处理，请使用[Type Checker](https://core.formilyjs.org/zh-CN/api/entry/form-checker)

<Alert>
注意：如果要在自定义组件内使用useField，并响应字段模型变化，那需要给自定义组件包装observer
</Alert>

## 签名

```ts
interface useField {
  (): Field
}
```

## 用例

```tsx
import React, { useMemo } from 'react'
import { createForm } from '@formily/core'
import {
  FormProvider,
  FormConsumer,
  Field,
  useField,
  observer,
} from '@formily/react'
import { Input, Form, Button } from 'antd'

// FormItem UI组件
const FormItem = observer(({ children }) => {
  const field = useField()
  return (
    <Form.Item
      label={field.title}
      help={field.selfErrors?.length ? field.selfErrors : undefined}
      extra={field.description}
      validateStatus={field.validateStatus}
    >
      {children}
    </Form.Item>
  )
})

export default () => {
  const form = useMemo(() => createForm({ validateFirst: true }))
  return (
    <FormProvider form={form}>
      <Form layout="vertical">
        <Field
          name="name"
          title="Name"
          required
          decorator={[FormItem]}
          component={[Input, { placeholder: 'Please Input' }]}
        />
        <code>
          <pre>
            <FormConsumer>
              {(form) => JSON.stringify(form.values, null, 2)}
            </FormConsumer>
          </pre>
        </code>
        <Button
          type="primary"
          onClick={() => {
            form.submit(console.log)
          }}
        >
          Submit
        </Button>
      </Form>
    </FormProvider>
  )
}
```
</file>

<file path="packages/react/docs/api/hooks/useFieldSchema.md">
# useFieldSchema

## Description

Mainly read the Schema information of the current field in the custom component, this hook can only be used in the subtree of SchemaField or RecursionField

## Signature

```ts
interface useFieldSchema {
  (): Schema
}
```

Schema Reference [Schema](/api/shared/schema)

## Example

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField, useFieldSchema } from '@formily/react'

const form = createForm()

const Custom = () => {
  const schema = useFieldSchema()
  return (
    <code>
      <pre>{JSON.stringify(schema.toJSON(), null, 2)}</pre>
    </code>
  )
}

const SchemaField = createSchemaField({
  components: {
    Custom,
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Object
        name="custom"
        x-component="Custom"
        x-component-props={{
          schema: {
            type: 'object',
            properties: {
              input: {
                type: 'string',
                'x-component': 'Custom',
              },
            },
          },
        }}
      />
    </SchemaField>
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/hooks/useFieldSchema.zh-CN.md">
# useFieldSchema

## 描述

主要在自定义组件中读取当前字段的 Schema 信息，该 hook 只能用在 SchemaField 或者 RecursionField 的子树中使用

## 签名

```ts
interface useFieldSchema {
  (): Schema
}
```

Schema 参考[Schema](/api/shared/schema)

## 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField, useFieldSchema } from '@formily/react'

const form = createForm()

const Custom = () => {
  const schema = useFieldSchema()
  return (
    <code>
      <pre>{JSON.stringify(schema.toJSON(), null, 2)}</pre>
    </code>
  )
}

const SchemaField = createSchemaField({
  components: {
    Custom,
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.Object
        name="custom"
        x-component="Custom"
        x-component-props={{
          schema: {
            type: 'object',
            properties: {
              input: {
                type: 'string',
                'x-component': 'Custom',
              },
            },
          },
        }}
      />
    </SchemaField>
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/hooks/useForm.md">
# useForm

## Description

Mainly read the current [Form](https://core.formilyjs.org/api/models/form) instance in the custom component to implement some side-effect dependencies, such as relying on the errors information of the Form, for Implement some more complex scenario-based components

## Signature

```ts
interface useForm {
  (): Form
}
```

## Example

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, Field, useForm, observer } from '@formily/react'
import { Input } from 'antd'

const form = createForm()

const Custom = observer(() => {
  const form = useForm()
  return <div>{form.values.input}</div>
})

export default () => (
  <FormProvider form={form}>
    <Field name="input" component={[Input]} />
    <Field name="custom" component={[Custom]} />
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/hooks/useForm.zh-CN.md">
# useForm

## 描述

主要在自定义组件中读取当前[Form](https://core.formilyjs.org/zh-CN/api/models/form)实例，用于实现一些副作用依赖，比如依赖 Form 的 errors 信息之类的，用于实现一些较为复杂的场景化组件

## 签名

```ts
interface useForm {
  (): Form
}
```

## 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, Field, useForm, observer } from '@formily/react'
import { Input } from 'antd'

const form = createForm()

const Custom = observer(() => {
  const form = useForm()
  return <div>{form.values.input}</div>
})

export default () => (
  <FormProvider form={form}>
    <Field name="input" component={[Input]} />
    <Field name="custom" component={[Custom]} />
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/hooks/useFormEffects.md">
# useFormEffects

## Description

Mainly inject side-effect logic into the current [Form](https://core.formilyjs.org/api/models/form) instance in the custom component to implement some more complex scenario-based components

<Alert>
Note: It is invalid to monitor onFormInit in the effects function, because the Form has already been initialized when rendering to the current component, and the effects function will only be executed once, so if you want to rely on the data of useState, please use the reference data of useRef.
</Alert>

## Signature

```ts
interface useFormEffects {
  (form: Form): void
}
```

## Example

```tsx
import React from 'react'
import { createForm, onFieldReact } from '@formily/core'
import { FormProvider, Field, useFormEffects } from '@formily/react'
import { Input, Form } from 'antd'

const form = createForm({
  effects() {
    onFieldReact('custom.aa', (field) => {
      field.value = field.query('input').get('value')
    })
  },
})

const Custom = () => {
  useFormEffects(() => {
    onFieldReact('custom.bb', (field) => {
      field.value = field.query('.aa').get('value')
    })
  })
  return (
    <div>
      <Field name="aa" decorator={[Form.Item]} component={[Input]} />
      <Field name="bb" decorator={[Form.Item]} component={[Input]} />
    </div>
  )
}

export default () => (
  <FormProvider form={form}>
    <Field name="input" decorator={[Form.Item]} component={[Input]} />
    <Field name="custom" decorator={[Form.Item]} component={[Custom]} />
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/hooks/useFormEffects.zh-CN.md">
# useFormEffects

## 描述

主要在自定义组件中往当前[Form](https://core.formilyjs.org/zh-CN/api/models/form)实例注入副作用逻辑，用于实现一些较为复杂的场景化组件

<Alert>
注意：在effects函数内监听onFormInit是无效的，因为渲染到当前组件，Form早已初始化，同时effects函数是只会执行一次，所以想要依赖useState的数据，请使用useRef的引用数据
</Alert>

## 签名

```ts
interface useFormEffects {
  (form: Form): void
}
```

## 用例

```tsx
import React from 'react'
import { createForm, onFieldReact } from '@formily/core'
import { FormProvider, Field, useFormEffects } from '@formily/react'
import { Input, Form } from 'antd'

const form = createForm({
  effects() {
    onFieldReact('custom.aa', (field) => {
      field.value = field.query('input').get('value')
    })
  },
})

const Custom = () => {
  useFormEffects(() => {
    onFieldReact('custom.bb', (field) => {
      field.value = field.query('.aa').get('value')
    })
  })
  return (
    <div>
      <Field name="aa" decorator={[Form.Item]} component={[Input]} />
      <Field name="bb" decorator={[Form.Item]} component={[Input]} />
    </div>
  )
}

export default () => (
  <FormProvider form={form}>
    <Field name="input" decorator={[Form.Item]} component={[Input]} />
    <Field name="custom" decorator={[Form.Item]} component={[Custom]} />
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/hooks/useParentForm.md">
# useParentForm

## Description

Used to read the most recent Form or ObjectField instance, which is mainly convenient for calling the submit/validate of the subform

## Signature

```ts
interface useParentForm {
  (): Form | ObjectField
}
```

## Example

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import {
  FormProvider,
  ObjectField,
  VoidField,
  observer,
  useParentForm,
} from '@formily/react'

const form = createForm()

const Custom = observer(() => {
  const form = useParentForm()
  return <div>{form.displayName}</div>
})

export default () => (
  <FormProvider form={form}>
    <ObjectField name="object">
      <Custom />
    </ObjectField>
    <Custom />
    <VoidField name="void">
      <Custom />
    </VoidField>
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/hooks/useParentForm.zh-CN.md">
# useParentForm

## 描述

用于读取最近的 Form 或者 ObjectField 实例，主要方便于调用子表单的 submit/validate

## 签名

```ts
interface useParentForm {
  (): Form | ObjectField
}
```

## 用例

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import {
  FormProvider,
  ObjectField,
  VoidField,
  observer,
  useParentForm,
} from '@formily/react'

const form = createForm()

const Custom = observer(() => {
  const form = useParentForm()
  return <div>{form.displayName}</div>
})

export default () => (
  <FormProvider form={form}>
    <ObjectField name="object">
      <Custom />
    </ObjectField>
    <Custom />
    <VoidField name="void">
      <Custom />
    </VoidField>
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/api/shared/connect.md">
# connect

## Description

Mainly used for non-intrusive access to third-party component libraries Formily

## Signature

```ts
interface IComponentMapper<T extends React.FC> {
  (target: T): React.FC
}
interface connect<T extends React.FC> {
  (target: T, ...args: IComponentMapper<T>[]): React.FC
}
```

The first parameter passed in is the component to be connected, the following parameters are component mappers, each mapper is a function, usually we will use the built-in [mapProps](/api/shared/map- props) and [mapReadPretty](/api/shared/map-read-pretty) mapper

## Example

```tsx
import React, { useMemo } from 'react'
import { createForm } from '@formily/core'
import {
  FormProvider,
  FormConsumer,
  Field,
  connect,
  mapProps,
} from '@formily/react'
import { Input, Form, Button } from 'antd'

// FormItem UI component
const FormItem = connect(
  Form.Item,
  mapProps(
    {
      title: 'label',
      description: 'extra',
      required: true,
      validateStatus: true,
    },
    (props, field) => {
      return {
        ...props,
        help: field.selfErrors?.length ? field.selfErrors : undefined,
      }
    }
  )
)

export default () => {
  const form = useMemo(() => createForm({ validateFirst: true }))
  return (
    <FormProvider form={form}>
      <Form layout="vertical">
        <Field
          name="name"
          title="Name"
          required
          decorator={[FormItem]}
          component={[Input, { placeholder: 'Please Input' }]}
        />
        <code>
          <pre>
            <FormConsumer>
              {(form) => JSON.stringify(form.values, null, 2)}
            </FormConsumer>
          </pre>
        </code>
        <Button
          type="primary"
          onClick={() => {
            form.submit(console.log)
          }}
        >
          Submit
        </Button>
      </Form>
    </FormProvider>
  )
}
```
</file>

<file path="packages/react/docs/api/shared/connect.zh-CN.md">
# connect

## 描述

主要用于对第三方组件库的无侵入接入 Formily

## 签名

```ts
interface IComponentMapper<T extends React.FC> {
  (target: T): React.FC
}
interface connect<T extends React.FC> {
  (target: T, ...args: IComponentMapper<T>[]): React.FC
}
```

入参传入第一个参数是要接入的组件，后面的参数都是组件映射器，每个映射器都是一个函数，通常我们会使用内置的[mapProps](/api/shared/map-props)和[mapReadPretty](/api/shared/map-read-pretty)映射器

## 用例

```tsx
import React, { useMemo } from 'react'
import { createForm } from '@formily/core'
import {
  FormProvider,
  FormConsumer,
  Field,
  connect,
  mapProps,
} from '@formily/react'
import { Input, Form, Button } from 'antd'

// FormItem UI组件
const FormItem = connect(
  Form.Item,
  mapProps(
    {
      title: 'label',
      description: 'extra',
      required: true,
      validateStatus: true,
    },
    (props, field) => {
      return {
        ...props,
        help: field.selfErrors?.length ? field.selfErrors : undefined,
      }
    }
  )
)

export default () => {
  const form = useMemo(() => createForm({ validateFirst: true }))
  return (
    <FormProvider form={form}>
      <Form layout="vertical">
        <Field
          name="name"
          title="Name"
          required
          decorator={[FormItem]}
          component={[Input, { placeholder: 'Please Input' }]}
        />
        <code>
          <pre>
            <FormConsumer>
              {(form) => JSON.stringify(form.values, null, 2)}
            </FormConsumer>
          </pre>
        </code>
        <Button
          type="primary"
          onClick={() => {
            form.submit(console.log)
          }}
        >
          Submit
        </Button>
      </Form>
    </FormProvider>
  )
}
```
</file>

<file path="packages/react/docs/api/shared/context.md">
# context

## Description

All React Context of @formily/react is convenient for users to do more complex personalized customization. We can consume these contexts through useContext

## FormContext

#### Description

Form context, you can get the current Form instance

#### Signature

```ts
import { Form } from '@formily/core'

const FormContext = createContext<Form>(null)
```

## FieldContext

#### Description

Field context, you can get the current field instance

#### Signature

```ts
import { GeneralField } from '@formily/core'

const FieldContext = createContext<GeneralField>(null)
```

## SchemaMarkupContext

#### Description

Schema tag context, mainly used to collect Schema tags written in JSX Markup, and then convert them into standard JSON Schema

#### Signature

```ts
SchemaMarkupContext = createContext<Schema>(null)
```

## SchemaContext

#### Description

Field Schema context, mainly used to obtain the Schema information of the current field

#### Signature

```ts
const SchemaContext = createContext<Schema>(null)
```

## SchemaExpressionScopeContext

#### Description

Schema expression scope context

#### Signature

```ts
export const SchemaExpressionScopeContext = createContext<any>(null)
```

## SchemaOptionsContext

#### Description

Schema global parameter context, mainly used to obtain the parameters passed in from createSchemaField

#### Signature

```ts
const SchemaOptionsContext = createContext<ISchemaFieldFactoryOptions>(null)
```
</file>

<file path="packages/react/docs/api/shared/context.zh-CN.md">
# context

## 描述

@formily/react 的所有 React Context，方便用户做更复杂的个性化定制，我们可以通过 useContext 来消费这些上下文

## FormContext

#### 描述

Form 上下文，可以获取当前 Form 实例

#### 签名

```ts
import { Form } from '@formily/core'

const FormContext = createContext<Form>(null)
```

## FieldContext

#### 描述

字段上下文，可以获取当前字段实例

#### 签名

```ts
import { GeneralField } from '@formily/core'

const FieldContext = createContext<GeneralField>(null)
```

## SchemaMarkupContext

#### 描述

Schema 标签上下文，主要用于收集 JSX Markup 写法的 Schema 标签，然后转换成标准 JSON Schema

#### 签名

```ts
SchemaMarkupContext = createContext<Schema>(null)
```

## SchemaContext

#### 描述

字段 Schema 上下文，主要用于获取当前字段的 Schema 信息

#### 签名

```ts
const SchemaContext = createContext<Schema>(null)
```

## SchemaExpressionScopeContext

#### 描述

Schema 表达式作用域上下文

#### 签名

```ts
export const SchemaExpressionScopeContext = createContext<any>(null)
```

## SchemaOptionsContext

#### 描述

Schema 全局参数上下文，主要用于获取从 createSchemaField 传入的参数

#### 签名

```ts
const SchemaOptionsContext = createContext<ISchemaFieldFactoryOptions>(null)
```
</file>

<file path="packages/react/docs/api/shared/mapProps.md">
# mapProps

## Description

Adapter function that maps [Field](https://core.formilyjs.org/api/models/field) attributes and component attributes, mainly used in conjunction with the connect function

## Signature

```ts
import { Field, GeneralField } from '@formily/core'
type IStateMapper<Props> =
  | {
      [key in keyof Field]?: keyof Props | boolean
    }
  | ((props: Props, field: GeneralField) => Props)

interface mapProps<T extends React.FC> {
  (...args: IStateMapper<React.ComponentProps<T>>[]): React.FC
}
```

- Parameters can be passed objects (key is the attribute of the field, value is the attribute of the component, if the value is true, the mapped attribute name is the same)
- Parameters can be passed to functions, and functions can directly do more complex mappings to attributes

## Example

```tsx
import React, { useMemo } from 'react'
import { createForm } from '@formily/core'
import {
  FormProvider,
  FormConsumer,
  Field,
  connect,
  mapProps,
} from '@formily/react'
import { Input, Form, Button } from 'antd'

// FormItem UI component
const FormItem = connect(
  Form.Item,
  mapProps(
    {
      title: 'label',
      description: 'extra',
      required: true,
      validateStatus: true,
    },
    (props, field) => {
      return {
        ...props,
        help: field.selfErrors?.length ? field.selfErrors : undefined,
      }
    }
  )
)

export default () => {
  const form = useMemo(() => createForm({ validateFirst: true }))
  return (
    <FormProvider form={form}>
      <Form layout="vertical">
        <Field
          name="name"
          title="Name"
          required
          decorator={[FormItem]}
          component={[Input, { placeholder: 'Please Input' }]}
        />
        <code>
          <pre>
            <FormConsumer>
              {(form) => JSON.stringify(form.values, null, 2)}
            </FormConsumer>
          </pre>
        </code>
        <Button
          type="primary"
          onClick={() => {
            form.submit(console.log)
          }}
        >
          Submit
        </Button>
      </Form>
    </FormProvider>
  )
}
```
</file>

<file path="packages/react/docs/api/shared/mapProps.zh-CN.md">
# mapProps

## 描述

将[Field](https://core.formilyjs.org/zh-CN/api/models/field)属性与组件属性映射的适配器函数，主要与 connect 函数搭配使用

## 签名

```ts
import { Field, GeneralField } from '@formily/core'
type IStateMapper<Props> =
  | {
      [key in keyof Field]?: keyof Props | boolean
    }
  | ((props: Props, field: GeneralField) => Props)

interface mapProps<T extends React.FC> {
  (...args: IStateMapper<React.ComponentProps<T>>[]): React.FC
}
```

- 参数可以传对象(key 是 field 的属性，value 是组件的属性，如果 value 为 true，代表映射的属性名相同)
- 参数可以传函数，函数可以直接对属性做更复杂的映射

## 用例

```tsx
import React, { useMemo } from 'react'
import { createForm } from '@formily/core'
import {
  FormProvider,
  FormConsumer,
  Field,
  connect,
  mapProps,
} from '@formily/react'
import { Input, Form, Button } from 'antd'

// FormItem UI组件
const FormItem = connect(
  Form.Item,
  mapProps(
    {
      title: 'label',
      description: 'extra',
      required: true,
      validateStatus: true,
    },
    (props, field) => {
      return {
        ...props,
        help: field.selfErrors?.length ? field.selfErrors : undefined,
      }
    }
  )
)

export default () => {
  const form = useMemo(() => createForm({ validateFirst: true }))
  return (
    <FormProvider form={form}>
      <Form layout="vertical">
        <Field
          name="name"
          title="Name"
          required
          decorator={[FormItem]}
          component={[Input, { placeholder: 'Please Input' }]}
        />
        <code>
          <pre>
            <FormConsumer>
              {(form) => JSON.stringify(form.values, null, 2)}
            </FormConsumer>
          </pre>
        </code>
        <Button
          type="primary"
          onClick={() => {
            form.submit(console.log)
          }}
        >
          Submit
        </Button>
      </Form>
    </FormProvider>
  )
}
```
</file>

<file path="packages/react/docs/api/shared/mapReadPretty.md">
# mapReadPretty

## Description

Because most third-party components do not support the reading state, if you want to quickly support the reading state, you can use the mapReadPretty function to map a reading state component

## Signature

```ts
interface mapReadPretty<Target extends React.FC> {
  (component: Target, readPrettyProps?: React.ComponentProps<Target>): React.FC
}
```

## Example

```tsx
import React, { useMemo } from 'react'
import { createForm } from '@formily/core'
import {
  FormProvider,
  Field,
  connect,
  mapProps,
  mapReadPretty,
} from '@formily/react'
import { Input as AntdInput, Form } from 'antd'

// FormItem UI component
const FormItem = connect(
  Form.Item,
  mapProps(
    {
      title: 'label',
      description: 'extra',
      required: true,
      validateStatus: true,
    },
    (props, field) => {
      return {
        ...props,
        help: field.selfErrors?.length ? field.selfErrors : undefined,
      }
    }
  )
)

const Input = connect(
  AntdInput,
  mapReadPretty(({ value }) => <div>{value}</div>)
)

export default () => {
  const form = useMemo(() =>
    createForm({ validateFirst: true, readPretty: true })
  )
  return (
    <FormProvider form={form}>
      <Form layout="vertical">
        <Field
          name="name"
          title="Name"
          required
          initialValue="Hello world"
          decorator={[FormItem]}
          component={[Input, { placeholder: 'Please Input' }]}
        />
      </Form>
    </FormProvider>
  )
}
```
</file>

<file path="packages/react/docs/api/shared/mapReadPretty.zh-CN.md">
# mapReadPretty

## 描述

因为大多数第三方组件都不支持阅读态，如果想要快速支持阅读态的话，即可使用 mapReadPretty 函数来映射一个阅读态组件

## 签名

```ts
interface mapReadPretty<Target extends React.FC> {
  (component: Target, readPrettyProps?: React.ComponentProps<Target>): React.FC
}
```

## 用例

```tsx
import React, { useMemo } from 'react'
import { createForm } from '@formily/core'
import {
  FormProvider,
  Field,
  connect,
  mapProps,
  mapReadPretty,
} from '@formily/react'
import { Input as AntdInput, Form } from 'antd'

// FormItem UI组件
const FormItem = connect(
  Form.Item,
  mapProps(
    {
      title: 'label',
      description: 'extra',
      required: true,
      validateStatus: true,
    },
    (props, field) => {
      return {
        ...props,
        help: field.selfErrors?.length ? field.selfErrors : undefined,
      }
    }
  )
)

const Input = connect(
  AntdInput,
  mapReadPretty(({ value }) => <div>{value}</div>)
)

export default () => {
  const form = useMemo(() =>
    createForm({ validateFirst: true, readPretty: true })
  )
  return (
    <FormProvider form={form}>
      <Form layout="vertical">
        <Field
          name="name"
          title="Name"
          required
          initialValue="Hello world"
          decorator={[FormItem]}
          component={[Input, { placeholder: 'Please Input' }]}
        />
      </Form>
    </FormProvider>
  )
}
```
</file>

<file path="packages/react/docs/api/shared/observer.md">
# observer

## observer

### Description

The observer is a [HOC](https://reactjs.bootcss.com/docs/higher-order-components.html), which is used to add reactive features to react functional components.

### When to use

When a component uses an [observable](https://reactive.formilyjs.org/api/observable) object inside, and you want the component to respond to changes in the observable object.

### API definition

```ts
interface IObserverOptions {
  // Do you need observers to use forwardRef to pass ref attributes
  forwardRef?: boolean
  scheduler?: (updater: () => void) => void
  displayName?: string
}

function observer<P, Options extends IObserverOptions>(
  component: React.FunctionComponent<P>,
  options?: Options
): React.MemoExoticComponent<
  React.FunctionComponent<
    Options extends { forwardRef: true }
      ? React.PropsWithRef<P>
      : React.PropsWithoutRef<P>
  >
>
```

### Example

```tsx
/**
 * defaultShowCode: true
 */
import React from 'react'
import { observable } from '@formily/reactive'
import { observer } from '@formily/reactive-react'

const obs = observable({
  value: 'Hello world',
})

export default observer(() => {
  return (
    <div>
      <div>
        <input
          style={{
            height: 28,
            padding: '0 8px',
            border: '2px solid #888',
            borderRadius: 3,
          }}
          value={obs.value}
          onChange={(e) => {
            obs.value = e.target.value
          }}
        />
      </div>
      <div>{obs.value}</div>
    </div>
  )
})
```

### Note

`observer` can only receive callable function components, and does not support packaged components such as `React.forwardRef` | `React.memo`.

## Observer

### Description

Similar to Vue's responsive slot, it receives a Function RenderProps, as long as any responsive data consumed inside the Function, it will be automatically re-rendered as the data changes, and it is easier to achieve local accurate rendering

In fact, the function of this API is basically the same as that of FormConsumer, except that FormConsumer reveals the form instance of the current context in the RenderProps parameter.

### Signature

```ts
interface IObserverProps {
  children?: () => React.ReactElement
}

type Observer = React.FC<React.PropsWithChildren<IObserverProps>>
```

### Example

```tsx
/**
 * defaultShowCode: true
 */
import React from 'react'
import { observable } from '@formily/reactive'
import { Observer } from '@formily/react'

const obs = observable({
  value: 'Hello world',
})

export default () => {
  return (
    <div>
      <div>
        <Observer>
          {() => (
            <input
              style={{
                height: 28,
                padding: '0 8px',
                border: '2px solid #888',
                borderRadius: 3,
              }}
              value={obs.value}
              onChange={(e) => {
                obs.value = e.target.value
              }}
            />
          )}
        </Observer>
      </div>
      <Observer>{() => <div>{obs.value}</div>}</Observer>
    </div>
  )
}
```
</file>

<file path="packages/react/docs/api/shared/observer.zh-CN.md">
# observer

## observer

### 描述

observer 是一个 [HOC](https://reactjs.bootcss.com/docs/higher-order-components.html)，用于为 react 函数组件添加 reactive 特性。

### 什么时候使用

当一个组件内部使用了 [observable](https://reactive.formilyjs.org/zh-CN/api/observable) 对象，而你希望组件响应 observable 对象的变化时。

### API 定义

```ts
interface IObserverOptions {
  // 是否需要 observer 使用 forwardRef 传递 ref 属性
  forwardRef?: boolean
  scheduler?: (updater: () => void) => void
  displayName?: string
}

function observer<P, Options extends IObserverOptions>(
  component: React.FunctionComponent<P>,
  options?: Options
): React.MemoExoticComponent<
  React.FunctionComponent<
    Options extends { forwardRef: true }
      ? React.PropsWithRef<P>
      : React.PropsWithoutRef<P>
  >
>
```

### 用例

```tsx
/**
 * defaultShowCode: true
 */
import React from 'react'
import { observable } from '@formily/reactive'
import { observer } from '@formily/reactive-react'

const obs = observable({
  value: 'Hello world',
})

export default observer(() => {
  return (
    <div>
      <div>
        <input
          style={{
            height: 28,
            padding: '0 8px',
            border: '2px solid #888',
            borderRadius: 3,
          }}
          value={obs.value}
          onChange={(e) => {
            obs.value = e.target.value
          }}
        />
      </div>
      <div>{obs.value}</div>
    </div>
  )
})
```

### 注意

`observer` 只能接收 callable 函数组件，不支持 `React.forwardRef` | `React.memo` 等包裹的组件。

## Observer

### 描述

类似于 Vue 的响应式 Slot，它接收一个 Function RenderProps，只要在 Function 内部消费到的任何响应式数据，都会随数据变化而自动重新渲染，也更容易实现局部精确渲染

其实该 API 与 FormConsumer 的作用基本一致，只是 FormConsumer 在 RenderProps 参数中透出了当前上下文的 form 实例

### 签名

```ts
interface IObserverProps {
  children?: () => React.ReactElement
}

type Observer = React.FC<React.PropsWithChildren<IObserverProps>>
```

### 用例

```tsx
/**
 * defaultShowCode: true
 */
import React from 'react'
import { observable } from '@formily/reactive'
import { Observer } from '@formily/react'

const obs = observable({
  value: 'Hello world',
})

export default () => {
  return (
    <div>
      <div>
        <Observer>
          {() => (
            <input
              style={{
                height: 28,
                padding: '0 8px',
                border: '2px solid #888',
                borderRadius: 3,
              }}
              value={obs.value}
              onChange={(e) => {
                obs.value = e.target.value
              }}
            />
          )}
        </Observer>
      </div>
      <Observer>{() => <div>{obs.value}</div>}</Observer>
    </div>
  )
}
```
</file>

<file path="packages/react/docs/api/shared/Schema.md">
# Schema

## Description

The core part of the @formily/react protocol driver. Schema is a general class in which users can use it by themselves. At the same time, both SchemaField and RecursionField rely on it. It has several core capabilities:

- Ability to parse json-schema
- The ability to convert json-schema to Field Model
- The ability to compile json-schema expressions

You can export the Schema Class from @formily/react, but if you don’t want to use @formily/react, you can rely on the @formily/json-schema package alone

## Constructor

```ts
class Schema {
  constructor(json: ISchema, parent?: ISchema)
}
```

Create a Schema Tree based on a piece of json schema data to ensure that each schema node contains the corresponding method

## Attributes

| Property             | Description                                                                     | Type                                                                               | Field Model Mapping                                                      |
| -------------------- | ------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- | ------------------------------------------------------------------------ |
| type                 | Type                                                                            | [SchemaTypes](#schematypes)                                                        | [GeneralField](https://core.formilyjs.org/api/models/field#generalfield) |
| title                | Title                                                                           | React.ReactNode                                                                    | `title`                                                                  |
| description          | Description                                                                     | React.ReactNode                                                                    | `description`                                                            |
| default              | Default value                                                                   | Any                                                                                | `initialValue`                                                           |
| readOnly             | Is it read-only                                                                 | Boolean                                                                            | `readOnly`                                                               |
| writeOnly            | Whether to write only                                                           | Boolean                                                                            | `editable`                                                               |
| enum                 | Enumeration                                                                     | [SchemaEnum](#schemaenum)                                                          | `dataSource`                                                             |
| const                | Check whether the field value is equal to the value of const                    | Any                                                                                | `validator`                                                              |
| multipleOf           | Check whether the field value is divisible by the value of multipleOf           | Number                                                                             | `validator`                                                              |
| maximum              | Check the maximum value (greater than)                                          | Number                                                                             | `validator`                                                              |
| exclusiveMaximum     | Check the maximum value (greater than or equal to                               | Number                                                                             | `validator`                                                              |
| minimum              | Validation minimum value (less than)                                            | Number                                                                             | `validator`                                                              |
| exclusiveMinimum     | Minimum value (less than or equal to)                                           | Number                                                                             | `validator`                                                              |
| maxLength            | Maximum length of verification                                                  | Number                                                                             | `validator`                                                              |
| minLength            | Check minimum length                                                            | Number                                                                             | `validator`                                                              |
| pattern              | Regular verification rules                                                      | RegExpString                                                                       | `validator`                                                              |
| maxItems             | Maximum number of items                                                         | Number                                                                             | `validator`                                                              |
| minItems             | Minimum number of items                                                         | Number                                                                             | `validator`                                                              |
| uniqueItems          | Whether to verify duplicates                                                    | Boolean                                                                            | `validator`                                                              |
| maxProperties        | Maximum number of properties                                                    | Number                                                                             | `validator`                                                              |
| minProperties        | Minimum number of properties                                                    | Number                                                                             | `validator`                                                              |
| required             | required                                                                        | Boolean                                                                            | `validator`                                                              |
| format               | Regular verification format                                                     | [ValidatorFormats](https://core.formilyjs.org/api/models/field#fieldvalidator)     | `validator`                                                              |
| properties           | Property description                                                            | [SchemaProperties](#schemaproperties)                                              | -                                                                        |
| items                | Array description                                                               | [SchemaItems](#schemaitems)                                                        | -                                                                        |
| additionalItems      | Additional array element description                                            | Schema                                                                             | -                                                                        |
| patternProperties    | Schema of a certain property of the dynamic matching object                     | [SchemaProperties](#schemaproperties)                                              | -                                                                        |
| additionalProperties | Schema of matching object additional properties                                 | Schema                                                                             | -                                                                        |
| x-index              | UI display order                                                                | Number                                                                             | -                                                                        |
| x-pattern            | UI interaction mode                                                             | [FieldPatternTypes](https://core.formilyjs.org/api/models/field#fieldpatterntypes) | `pattern`                                                                |
| x-display            | UI display                                                                      | [FieldDisplayTypes](https://core.formilyjs.org/api/models/field#fielddisplaytypes) | `display`                                                                |
| x-validator          | Field Validator                                                                 | [FieldValidator](https://core.formilyjs.org/api/models/field#fieldvalidator)       | `validator`                                                              |
| x-decorator          | Field UI wrapper component                                                      | `String \| React.FC`                                                               | `decorator`                                                              |
| x-decorator-props    | Field UI wrapper component properties                                           | Any                                                                                | `decorator`                                                              |
| x-component          | Field UI component                                                              | `String \| React.FC`                                                               | `component`                                                              |
| x-component-props    | Field UI component properties                                                   | Any                                                                                | `component`                                                              |
| x-reactions          | Field linkage agreement                                                         | [SchemaReactions](#schemareactions)                                                | `reactions`                                                              |
| x-content            | Field content, used to pass in the child nodes of a component                   | React.ReactNode                                                                    | `content`                                                                |
| x-visible            | Field display hidden                                                            | Boolean                                                                            | `visible`                                                                |
| x-hidden             | Field UI hidden (data retention)                                                | Boolean                                                                            | `hidden`                                                                 |
| x-disabled           | Field disabled                                                                  | Boolean                                                                            | `disabled`                                                               |
| x-editable           | Editable field                                                                  | Boolean                                                                            | `editable`                                                               |
| x-read-only          | Field read-only                                                                 | Boolean                                                                            | `readOnly`                                                               |
| x-read-pretty        | Field Reading State                                                             | Boolean                                                                            | `readPretty`                                                             |
| definitions          | Schema predefined                                                               | [SchemaProperties](#schemaproperties)                                              | -                                                                        |
| $ref                 | Read the Schema from the Schema predefined and merge it into the current Schema | String                                                                             | -                                                                        |
| x-data               | Extends Data                                                                    | Object                                                                             | `data`                                                                   |
| x-compile-omitted    | list of attributes to ignore compiled expressions                               | string[]                                                                           | `[]`                                                                     |
| x-slot-node          | Slot node mark                                                                  | [Slot](#slot)                                                                      | -                                                                        |

#### Detailed description

- The component ID of x-component matches the key of the component collection passed in [createSchemaField](/api/components/schema-field#signature)
- The component ID of x-decorator matches the key of the component collection passed in [createSchemaField](/api/components/schema-field#signature)
- Every attribute of Schema can use string expression `{{expression}}`, expression variables can be passed in from createSchemaField or from SchemaField component
- The predefined format of $ref specified Schema must be `#/definitions/address` this format, loading remote JSON Schema is not supported

## Method

### addProperty

#### Description

Add attribute description

#### Signature

```ts
interface addProperty {
  (key: string | number, schema: ISchema): Schema //Return the added Schema object
}
```

### removeProperty

#### Description

Remove attribute description

#### Signature

```ts
interface removeProperty {
  (key: string | number): Schema //Return the removed Schema object
}
```

### setProperties

#### Description

Overwrite update attribute description

#### Signature

```ts
interface setProperties {
  (properties: SchemaProperties): Schema //Return the current Schema object
}
```

SchemaProperties Reference [SchemaProperties](#schemaproperties)

### addPatternProperty

#### Description

Add regular attribute description

#### Signature

```ts
interface addPatternProperty {
  (regexp: string, schema: ISchema): Schema //Return the added Schema object
}
```

### removePatternProperty

#### Description

Remove regular attribute description

#### Signature

```ts
interface removePatternProperty {
  (regexp: string): Schema //Return the removed Schema object
}
```

### setPatternProperties

#### Description

Override update regular attribute description

#### Signature

```ts
interface setPatternProperties {
  (properties: SchemaProperties): Schema //Return the current Schema object
}
```

SchemaProperties Reference [SchemaProperties](#schemaproperties)

### setAdditionalProperties

#### Description

Overwrite update extended attribute description

#### Signature

```ts
interface setAdditionalProperties {
  (properties: ISchema): Schema //Returns the extended properties Schema object
}
```

### setItems

#### Description

Override to update the array item description

#### Signature

```ts
interface setItems {
  (items: SchemaItems): SchemaItems //Return the updated SchemaItems object
}
```

SchemaItems Reference [SchemaItems](#schemaitems)

### setAdditionalItems

#### Description

Override to update the array extension item description

#### Signature

```ts
interface setAdditionalItems {
  (items: ISchema): Schema //Return the updated Schema object
}
```

SchemaItems Reference [SchemaItems](#schemaitems)

### mapProperties

#### Description

Traverse and map the properties of the current Schema, and traverse based on the x-index order

#### Signature

```ts
interface mapProperties<T> {
  (mapper: (property: Schema, key: string | number) => T): T[]
}
```

### mapPatternProperties

#### Description

Traverse and map the patternProperties attribute of the current Schema, and traverse based on the x-index order

#### Signature

```ts
interface mapPatternProperties<T> {
  (mapper: (property: Schema, key: string | number) => T): T[]
}
```

### reduceProperties

#### Description

reduce the properties of the current Schema, and it will be traversed based on the x-index order

#### Signature

```ts
interface reduceProperties<T> {
  (
    reducer: (value: T, property: Schema, key: string | number) => T,
    initialValue?: T
  ): T
}
```

### reducePatternProperties

#### Description

reduce the patternProperties attribute of the current Schema, and it will be traversed based on the x-index order

#### Signature

```ts
interface reducePatternProperties<T> {
  (
    reducer: (value: T, property: Schema, key: string | number) => T,
    initialValue?: T
  ): T
}
```

### compile

#### Description

Deeply recurse the expression fragments in the current Schema object, compile the expression, and return the Schema. We can pass in the scope object, and then consume the scope variable in the expression

Expression fragment convention: a string ending with `{{`beginning with `}}` represents an expression fragment

#### Signature

```ts
interface compile {
  (scope: any): Schema
}
```

### fromJSON

#### Description

Convert ordinary json data into Schema objects

#### Signature

```ts
interface fromJSON {
  (json: ISchema): Schema
}
```

### toJSON

#### Description

Convert the current Schema object into ordinary json data

#### Signature

```ts
interface toJSON {
  (): ISchema
}
```

### toFieldProps

#### Description

Convert the current Schema object into a Formily field model attribute, refer to the mapping relationship [attribute](#attributes)

#### Signature

```ts
import { IFieldFactoryProps } from '@formily/core'

interface toFieldProps {
  (): IFieldFactoryProps
}
```

IFieldFactoryProps reference [IFieldFactoryProps](https://core.formilyjs.org/api/models/form#ifieldfactoryprops)

## Static method

### getOrderProperties

#### Description

Get the sorted properties from the Schema

#### Signature

```ts
interface getOrderProperties {
  (schema: ISchema = {}, propertiesName: keyof ISchema = 'properties'): ISchema
}
```

### compile

#### Description

In-depth traversal of expression fragments in any object, expression fragment convention: a string ending with `{{`beginning`}}` represents an expression fragment

#### Signature

```ts
interface compile {
  (target: any, scope: any): any
}
```

### shallowCompile

#### Description

Shallow traversal of expression fragments in any object, expression fragment convention: a string ending with `{{`beginning with `}}` represents an expression fragment

#### Signature

```ts
interface shallowCompile {
  (target: any, scope: any): any
}
```

### silent

#### Description

Whether to compile silently, if it is, there will be no reminder if the expression error is reported

#### Signature

```ts
interface silent {
  (value?: boolean): void
}
```

### isSchemaInstance

#### Description

Determine whether an object is an instance of Schema Class

#### Signature

```ts
interface isSchemaInstance {
  (target: any): target is Schema
}
```

### registerCompiler

#### Description

Register the expression compiler

#### Signature

```ts
interface registerCompiler {
  (compiler: (expression: string, scope: any) => any): void
}
```

### registerPatches

#### Description

Register Schema patch to facilitate compatibility of different versions of Schema protocol

#### Signature

```ts
type SchemaPatch = (schema: ISchema) => ISchema

interface registerPatches {
  (...args: SchemaPatch[]): void
}
```

### registerVoidComponents

#### Description

Mark the field component to indicate that the component is a virtual component and is compatible with formily1.x

#### Signature

```ts
interface registerVoidComponents {
  (components: string[]): void
}
```

#### Example

```ts
import { Schema } from '@formily/react'

Schema.registerVoidComponents(['card', 'tab', 'step'])
```

<Alert type="warning">
  Note that this api needs to be used with <code>enablePolyfills(['1.0'])</code>
</Alert>

### registerTypeDefaultComponents

#### Description

Identify the default component type for the Schema type

#### Signature

```ts
interface registerTypeDefaultComponents {
  (maps: Record<string, string>): void
}
```

#### Example

```ts
import { Schema } from '@formily/react'

Schema.registerTypeDefaultComponents({
  string: 'Input',
  number: 'NumberPicker',
  array: 'ArrayTable',
})
```

<Alert type="warning">
  Note that this api needs to be used with <code>enablePolyfills(['1.0'])</code>
</Alert>

### registerPolyfills

#### Description

Registration agreement compatible gasket

#### Signature

```ts
type SchemaPatch = (schema: ISchema) => ISchema

interface registerPolyfills {
  (version: string, patch: SchemaPatch): void
}
```

#### Example

```ts
import { Schema } from '@formily/react'

Schema.registerPolyfills('1.0', (schema) => {
  schema['x-decorator'] = 'FormItem'
  return schema
})
```

### enablePolyfills

#### Description

Turn on the protocol gasket, the 1.0 version protocol compatible gasket is built in by default, and the main compatibility features are:

- x-decorator does not declare, it is automatically used as FormItem
- x-linkages converted to x-reactions
- x-props is automatically converted to x-decorator-props
- x-rules converted to x-validator
- convert editable to x-editable
- Convert visible to x-visible
- x-component is automatically converted to VoidField for card/block/grid-row/grid-col/grid/layout/step/tab/text-box,

#### Signature

```ts
interface enablePolyfills {
  (versions: string[]): void
}
```

#### Example

```ts
import { Schema } from '@formily/react'

Schema.enablePolyfills(['1.0'])
```

## Types of

### ISchema

#### Description

ISchema is a normal JSON data, and at the same time it is JSON data following the Schema [Attribute](#attributes) specification

### SchemaTypes

#### Description

Schema description type

#### Signature

```ts
type SchemaTypes =
  | 'string'
  | 'object'
  | 'array'
  | 'number'
  | 'boolean'
  | 'void'
  | 'date'
  | 'datetime'
  | (string & {})
```

### SchemaProperties

#### Description

Schema attribute description

#### Signature

```ts
type SchemaProperties = Record<string, ISchema>
```

### SchemaItems

#### Description

Schema array item description

#### Signature

```ts
type SchemaItems = ISchema | ISchema[]
```

### SchemaEnum

#### Description

Schema enum

#### Signature

```ts
type SchemaEnum<Message> = Array<
  | string
  | number
  | { label: Message; value: any; [key: string]: any }
  | { key: any; title: Message; [key: string]: any }
>
```

### SchemaReactions

#### Description

Schema linkage protocol, if the reaction object contains target, it represents active linkage mode, otherwise it represents passive linkage mode  
If you want to achieve more complex linkage, you can pass in the reaction responder function through the scope for processing  
FormPathPattern path syntax documentation is [here](https://core.formilyjs.org/api/entry/form-path#formpathpattern)

#### Signature

```ts
import { IGeneralFieldState } from '@formily/core'

type SchemaReactionEffect =
  | 'onFieldInit'
  | 'onFieldMount'
  | 'onFieldUnmount'
  | 'onFieldValueChange'
  | 'onFieldInputValueChange'
  | 'onFieldInitialValueChange'
  | 'onFieldValidateStart'
  | 'onFieldValidateEnd'
  | 'onFieldValidateFailed'
  | 'onFieldValidateSuccess'

type SchemaReaction<Field = any> =
  | {
      dependencies?: //The list of dependent field paths can only describe dependencies in dot paths, and supports relative paths
      | Array<
            | string //If it is an array contains string format, then it is also an array format when reading
            | {
                //If it is an array contains object format, then it is an object format when reading, but the name field is equivalent to an alias
                name?: string
                type?: string
                source?: string
                property?: string
              }
          >
        | Record<string, string> //If it is an object format, It is also an object format when reading, but the key for object is equivalent to an alias
      when?: string | boolean //Linkage condition
      target?: string //The field path to be operated, supports FormPathPattern path syntax, note: relative path is not supported! !
      effects?: SchemaReactionEffect[] //Independent life cycle hook in active mode
      fulfill?: {
        //To meet the conditions
        state?: IGeneralFieldState //Update state
        schema?: ISchema //Update Schema
        run?: string //Execute statement
      }
      otherwise?: {
        //Does not meet the conditions
        state?: IGeneralFieldState //Update state
        schema?: ISchema //Update Schema
        run?: string //Execute statement
      }
    }
  | ((field: Field) => void) //Can be complex linkage

type SchemaReactions<Field = any> =
  | SchemaReaction<Field>
  | SchemaReaction<Field>[]
```

#### Example

**Active linkage**

Writing method one, standard initiative linkage

```json
{
  "type": "object",
  "properties": {
    "source": {
      "type": "string",
      "x-component": "Input",
      "x-reactions": {
        "target": "target",
        "when": "{{$self.value === '123'}}",
        "fulfill": {
          "state": {
            "visible": false
          }
        },
        "otherwise": {
          "state": {
            "visible": true
          }
        }
      }
    },
    "target": {
      "type": "string",
      "x-component": "Input"
    }
  }
}
```

Writing method two, local expression distribution linkage

```json
{
  "type": "object",
  "properties": {
    "source": {
      "type": "string",
      "x-component": "Input",
      "x-reactions": {
        "target": "target",
        "fulfill": {
          "state": {
            "visible": "{{$self.value === '123'}}" //Any level of attributes supports expressions
          }
        }
      }
    },
    "target": {
      "type": "string",
      "x-component": "Input"
    }
  }
}
```

Writing method three, based on Schema protocol linkage

```json
{
  "type": "object",
  "properties": {
    "source": {
      "type": "string",
      "x-component": "Input",
      "x-reactions": {
        "target": "target",
        "fulfill": {
          "schema": {
            "x-visible": "{{$self.value === '123'}}" //Any level of attributes supports expressions
          }
        }
      }
    },
    "target": {
      "type": "string",
      "x-component": "Input"
    }
  }
}
```

Writing method four, based on run statement linkage

```json
{
  "type": "object",
  "properties": {
    "source": {
      "type": "string",
      "x-component": "Input",
      "x-reactions": {
        "fulfill": {
          "run": "$form.setFieldState('target',state=>{state.visible = $self.value === '123'})"
        }
      }
    },
    "target": {
      "type": "string",
      "x-component": "Input"
    }
  }
}
```

Writing method five, based on the linkage of life cycle hooks

```json
{
  "type": "object",
  "properties": {
    "source": {
      "type": "string",
      "x-component": "Input",
      "x-reactions": {
        "target": "target",
        "effects": ["onFieldInputValueChange"],
        "fulfill": {
          "state": {
            "visible": "{{$self.value === '123'}}" //Any level of attributes supports expressions
          }
        }
      }
    },
    "target": {
      "type": "string",
      "x-component": "Input"
    }
  }
}
```

**Passive linkage**

Writing method one, standard passive linkage

```json
{
  "type": "object",
  "properties": {
    "source": {
      "type": "string",
      "x-component": "Input"
    },
    "target": {
      "type": "string",
      "x-component": "Input",
      "x-reactions": {
        "dependencies": ["source"], //Dependency path is written by default to take value. If you rely on other attributes of the field, you can use source#modified, and use # to split to get detailed attributes
        // "dependencies":{ aliasName:"source" }, //alias form
        "fulfill": {
          "schema": {
            "x-visible": "{{$deps[0] === '123'}}" //Any level of attributes supports expressions
          }
        }
      }
    }
  }
}
```

Writing method two, linkage of adjacent elements

```json
{
  "type": "array",
  "x-component": "ArrayTable",
  "items": {
    "type": "object",
    "properties": {
      "source": {
        "type": "string",
        "x-component": "Input"
      },
      "target": {
        "type": "string",
        "x-component": "Input",
        "x-reactions": {
          "dependencies": [".source"],
          "fulfill": {
            "schema": {
              "x-visible": "{{$deps[0] === '123'}}"
            }
          }
        }
      }
    }
  }
}
```

**Complex linkage**

```json
{
  "type": "object",
  "properties": {
    "source": {
      "type": "string",
      "x-component": "Input"
    },
    "target": {
      "type": "string",
      "x-component": "Input",
      "x-reactions": "{{myReaction}}" //For externally passed functions, more complex linkages can be realized within the function
    }
  }
}
```

**Component attribute linkage**

Writing one, operating status

```json
{
  "type": "object",
  "properties": {
    "source": {
      "type": "string",
      "x-component": "Input",
      "x-reactions": {
        "target": "target",
        "fulfill": {
          "state": {
            "component[1].style.color": "{{$self.value === '123'?'red':'blue'}}" //Any level attribute supports expressions, and the key is a support path Expression, can achieve precise manipulation of attributes
          }
        }
      }
    },
    "target": {
      "type": "string",
      "x-component": "Input"
    }
  }
}
```

Writing method two, operating the Schema protocol

```json
{
  "type": "object",
  "properties": {
    "source": {
      "type": "string",
      "x-component": "Input",
      "x-reactions": {
        "target": "target",
        "fulfill": {
          "schema": {
            "x-component-props.style.color": "{{$self.value === '123'?'red':'blue'}}" //Any level of property supports expressions, and the key is supported Path expression, can achieve precise operation properties
          }
        }
      }
    },
    "target": {
      "type": "string",
      "x-component": "Input"
    }
  }
}
```

### Slot

#### Description

Mark this node as a Slot node, which will be skipped in the normal rendering process.  
Use `target` to specify the target property for rendering this node, which must be a sibling property at the same level.  
You can use `isRenderProp` to specify that this node is passed in the form of the renderProp function.  
When `isRenderProp` is `true`, the renderProp function’s argument list can be accessed within the Slot through `$slotArgs`.

#### Signature

```ts
type Slot = {
  //Slot target: Specify the target property for rendering this node, which must be a sibling property at the same level.
  target: string // 'some-sibling-node.x-component-props.xxx' or 'some-sibling-node.x-decorator-props.xxx'
  //whether it is a renderProp Slot
  isRenderProp?: boolean
}
```

#### Example

**ReactNode Prop**  
Reference [SchemaField](https://react.formilyjs.org/api/components/schema-field#json-schema-reactnode-prop-use-case-x-slot-node)

```json
{
  "type": "object",
  "properties": {
    "search_icon": {
      "x-slot-node": {
        "target": "button.x-component-props.icon" //Specify to render the search_icon node as a slot into the icon prop of the Button component.
      },
      "x-component": "SearchOutlined",
      "x-component-props": {
        "data-testid": "icon"
      }
    },
    "button": {
      "type": "string",
      "x-component": "Button",
      "x-component-props": {
        "data-testid": "button"
      }
    }
  }
}
```

**RenderProp**  
Reference [SchemaField](https://react.formilyjs.org/api/components/schema-field#json-schema-render-prop-use-case-x-slot-node--isrenderprop)

```json
{
  "type": "object",
  "properties": {
    "dollar_icon": {
      "x-slot-node": {
        "target": "rate.x-component-props.character", //Specify to render the dollar_icon node as a slot into the character prop of the Rate component.
        "isRenderProp": true //The character prop accepts a renderProp function. Specify the Slot as a renderProp to take control of the rendering of the rating icons.
      },
      "x-component": "DollarOutlined",
      "x-component-props": {
        "data-testid": "icon",
        "rotate": "{{$slotArgs[0].value * 45}}", //When isRenderProp is true, the renderProp function’s argument list can be accessed within the Slot through $slotArgs.
        "style": {
          "fontSize": "50px"
        }
      }
    },
    "rate": {
      "x-component": "Rate"
    }
  }
}
```

## Built-in expression scope

Built-in expression scope is mainly used to realize various linkage relationships in expressions

### $self

Represents the current field instance, can be used in ordinary attribute expressions, and can also be used in x-reactions

### $values

Represents the top-level form data, which can be used in ordinary attribute expressions, and can also be used in x-reactions

### $form

Represents the current Form instance, which can be used in ordinary attribute expressions, and can also be used in x-reactions

### $observable

It is used to create reactive objects in the same way as observable

### $memo

Used to create persistent reference data in the same way as autorun.memo

### $effect

The timing of the next microtask in response to autorun's first execution and the dispose in response to autorun are used in the same way as autorun.effect

### $dependencies

It can only be consumed by expressions in x-reactions, corresponding to the dependencies defined by x-reactions, and the sequence of the array is the same

### $deps

It can only be consumed by expressions in x-reactions, corresponding to the dependencies defined by x-reactions, and the sequence of the array is the same

### $target

Can only be consumed in expressions in x-reactions, representing the target field of active mode

### $slotArgs

Can only be consumed in slot node. When slot used as render prop, $slotArgs can access render function arguments array
</file>

<file path="packages/react/docs/api/shared/Schema.zh-CN.md">
# Schema

## 描述

@formily/react 协议驱动最核心的部分，Schema 在其中是一个通用 Class，用户可以自行使用，同时在 SchemaField 和 RecursionField 中都有依赖它，它主要有几个核心能力：

- 解析 json-schema 的能力
- 将 json-schema 转换成 Field Model 的能力
- 编译 json-schema 表达式的能力

从@formily/react 中可以导出 Schema 这个 Class，但是如果你不希望使用@formily/react，你可以单独依赖@formily/json-schema 这个包

## 构造器

```ts
class Schema {
  constructor(json: ISchema, parent?: ISchema)
}
```

基于一份 json schema 数据创建一棵 Schema Tree，保证每个 schema 节点都是包含对应方法的

## 属性

| 属性                 | 描述                                              | 类型                                                                                     | 字段模型映射                                                                   |
| -------------------- | ------------------------------------------------- | ---------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ |
| type                 | 类型                                              | [SchemaTypes](#schematypes)                                                              | [GeneralField](https://core.formilyjs.org/zh-CN/api/models/field#generalfield) |
| title                | 标题                                              | React.ReactNode                                                                          | `title`                                                                        |
| description          | 描述                                              | React.ReactNode                                                                          | `description`                                                                  |
| default              | 默认值                                            | Any                                                                                      | `initialValue`                                                                 |
| readOnly             | 是否只读                                          | Boolean                                                                                  | `readOnly`                                                                     |
| writeOnly            | 是否只写                                          | Boolean                                                                                  | `editable`                                                                     |
| enum                 | 枚举                                              | [SchemaEnum](#schemaenum)                                                                | `dataSource`                                                                   |
| const                | 校验字段值是否与 const 的值相等                   | Any                                                                                      | `validator`                                                                    |
| multipleOf           | 校验字段值是否可被 multipleOf 的值整除            | Number                                                                                   | `validator`                                                                    |
| maximum              | 校验最大值(大于)                                  | Number                                                                                   | `validator`                                                                    |
| exclusiveMaximum     | 校验最大值（大于等于                              | Number                                                                                   | `validator`                                                                    |
| minimum              | 校验最小值(小于)                                  | Number                                                                                   | `validator`                                                                    |
| exclusiveMinimum     | 最小值（小于等于）                                | Number                                                                                   | `validator`                                                                    |
| maxLength            | 校验最大长度                                      | Number                                                                                   | `validator`                                                                    |
| minLength            | 校验最小长度                                      | Number                                                                                   | `validator`                                                                    |
| pattern              | 正则校验规则                                      | RegExpString                                                                             | `validator`                                                                    |
| maxItems             | 最大条目数                                        | Number                                                                                   | `validator`                                                                    |
| minItems             | 最小条目数                                        | Number                                                                                   | `validator`                                                                    |
| uniqueItems          | 是否校验重复                                      | Boolean                                                                                  | `validator`                                                                    |
| maxProperties        | 最大属性数量                                      | Number                                                                                   | `validator`                                                                    |
| minProperties        | 最小属性数量                                      | Number                                                                                   | `validator`                                                                    |
| required             | 必填                                              | Boolean                                                                                  | `validator`                                                                    |
| format               | 正则校验格式                                      | [ValidatorFormats](https://core.formilyjs.org/zh-CN/api/models/field#fieldvalidator)     | `validator`                                                                    |
| properties           | 属性描述                                          | [SchemaProperties](#schemaproperties)                                                    | -                                                                              |
| items                | 数组描述                                          | [SchemaItems](#schemaitems)                                                              | -                                                                              |
| additionalItems      | 额外数组元素描述                                  | Schema                                                                                   | -                                                                              |
| patternProperties    | 动态匹配对象的某个属性的 Schema                   | [SchemaProperties](#schemaproperties)                                                    | -                                                                              |
| additionalProperties | 匹配对象额外属性的 Schema                         | Schema                                                                                   | -                                                                              |
| x-index              | UI 展示顺序                                       | Number                                                                                   | -                                                                              |
| x-pattern            | UI 交互模式                                       | [FieldPatternTypes](https://core.formilyjs.org/zh-CN/api/models/field#fieldpatterntypes) | `pattern`                                                                      |
| x-display            | UI 展示                                           | [FieldDisplayTypes](https://core.formilyjs.org/zh-CN/api/models/field#fielddisplaytypes) | `display`                                                                      |
| x-validator          | 字段校验器                                        | [FieldValidator](https://core.formilyjs.org/zh-CN/api/models/field#fieldvalidator)       | `validator`                                                                    |
| x-decorator          | 字段 UI 包装器组件                                | `String \| React.FC`                                                                     | `decorator`                                                                    |
| x-decorator-props    | 字段 UI 包装器组件属性                            | Any                                                                                      | `decorator`                                                                    |
| x-component          | 字段 UI 组件                                      | `String \| React.FC`                                                                     | `component`                                                                    |
| x-component-props    | 字段 UI 组件属性                                  | Any                                                                                      | `component`                                                                    |
| x-reactions          | 字段联动协议                                      | [SchemaReactions](#schemareactions)                                                      | `reactions`                                                                    |
| x-content            | 字段内容，用来传入某个组件的子节点                | React.ReactNode                                                                          | `content`                                                                      |
| x-visible            | 字段显示隐藏                                      | Boolean                                                                                  | `visible`                                                                      |
| x-hidden             | 字段 UI 隐藏(保留数据)                            | Boolean                                                                                  | `hidden`                                                                       |
| x-disabled           | 字段禁用                                          | Boolean                                                                                  | `disabled`                                                                     |
| x-editable           | 字段可编辑                                        | Boolean                                                                                  | `editable`                                                                     |
| x-read-only          | 字段只读                                          | Boolean                                                                                  | `readOnly`                                                                     |
| x-read-pretty        | 字段阅读态                                        | Boolean                                                                                  | `readPretty`                                                                   |
| definitions          | Schema 预定义                                     | [SchemaProperties](#schemaproperties)                                                    | -                                                                              |
| $ref                 | 从 Schema 预定义中读取 Schema 并合并至当前 Schema | String                                                                                   | -                                                                              |
| x-data               | 扩展属性                                          | Object                                                                                   | `data`                                                                         |
| x-compile-omitted    | 忽略编译表达式的属性列表                          | string[]                                                                                 | `[]`                                                                           |
| x-slot-node          | Slot 节点标记                                     | [Slot](#slot)                                                                            | -                                                                              |

#### 详细说明

- x-component 的组件标识与[createSchemaField](/api/components/schema-field#签名)传入的组件集合的 Key 匹配
- x-decorator 的组件标识与[createSchemaField](/api/components/schema-field#签名)传入的组件集合的 Key 匹配
- Schema 的每个属性都能使用字符串表达式`{{expression}}`，表达式变量可以从 createSchemaField 中传入，也可以从 SchemaField 组件中传入
- $ref 指定 Schema 预定义的格式必须是`#/definitions/address`这种格式，不支持加载远程 JSON Schema

## 方法

### addProperty

#### 描述

添加属性描述

#### 签名

```ts
interface addProperty {
  (key: string | number, schema: ISchema): Schema //返回添加后的Schema对象
}
```

### removeProperty

#### 描述

移除属性描述

#### 签名

```ts
interface removeProperty {
  (key: string | number): Schema //返回被移除的Schema对象
}
```

### setProperties

#### 描述

覆盖式更新属性描述

#### 签名

```ts
interface setProperties {
  (properties: SchemaProperties): Schema //返回当前Schema对象
}
```

SchemaProperties 参考 [SchemaProperties](#schemaproperties)

### addPatternProperty

#### 描述

添加正则属性描述

#### 签名

```ts
interface addPatternProperty {
  (regexp: string, schema: ISchema): Schema //返回添加后的Schema对象
}
```

### removePatternProperty

#### 描述

移除正则属性描述

#### 签名

```ts
interface removePatternProperty {
  (regexp: string): Schema //返回移除后的Schema对象
}
```

### setPatternProperties

#### 描述

覆盖式更新正则属性描述

#### 签名

```ts
interface setPatternProperties {
  (properties: SchemaProperties): Schema //返回当前Schema对象
}
```

SchemaProperties 参考 [SchemaProperties](#schemaproperties)

### setAdditionalProperties

#### 描述

覆盖式更新扩展属性描述

#### 签名

```ts
interface setAdditionalProperties {
  (properties: ISchema): Schema //返回扩展属性Schema对象
}
```

### setItems

#### 描述

覆盖式更新数组项描述

#### 签名

```ts
interface setItems {
  (items: SchemaItems): SchemaItems //返回更新后的SchemaItems对象
}
```

SchemaItems 参考 [SchemaItems](#schemaitems)

### setAdditionalItems

#### 描述

覆盖式更新数组扩展项描述

#### 签名

```ts
interface setAdditionalItems {
  (items: ISchema): Schema //返回更新后的Schema对象
}
```

SchemaItems 参考 [SchemaItems](#schemaitems)

### mapProperties

#### 描述

遍历并映射当前 Schema 的 properties 属性，同时会基于 x-index 顺序来遍历

#### 签名

```ts
interface mapProperties<T> {
  (mapper: (property: Schema, key: string | number) => T): T[]
}
```

### mapPatternProperties

#### 描述

遍历并映射当前 Schema 的 patternProperties 属性，同时会基于 x-index 顺序来遍历

#### 签名

```ts
interface mapPatternProperties<T> {
  (mapper: (property: Schema, key: string | number) => T): T[]
}
```

### reduceProperties

#### 描述

reduce 当前 Schema 的 properties 属性，同时会基于 x-index 顺序来遍历

#### 签名

```ts
interface reduceProperties<T> {
  (
    reducer: (value: T, property: Schema, key: string | number) => T,
    initialValue?: T
  ): T
}
```

### reducePatternProperties

#### 描述

reduce 当前 Schema 的 patternProperties 属性，同时会基于 x-index 顺序来遍历

#### 签名

```ts
interface reducePatternProperties<T> {
  (
    reducer: (value: T, property: Schema, key: string | number) => T,
    initialValue?: T
  ): T
}
```

### compile

#### 描述

深度递归当前 Schema 对象中的表达式片段，编译表达式，并返回 Schema，我们可以传入作用域对象，在表达式中即可消费作用域变量

表达式片段约定：以`{{`开头`}}`结尾的字符串代表一个表达式片段

#### 签名

```ts
interface compile {
  (scope: any): Schema
}
```

### fromJSON

#### 描述

将普通 json 数据转换成 Schema 对象

#### 签名

```ts
interface fromJSON {
  (json: ISchema): Schema
}
```

### toJSON

#### 描述

将当前 Schema 对象转换成普通 json 数据

#### 签名

```ts
interface toJSON {
  (): ISchema
}
```

### toFieldProps

#### 描述

将当前 Schema 对象转换成 Formily 字段模型属性，映射关系参考 [属性](#属性)

#### 签名

```ts
import { IFieldFactoryProps } from '@formily/core'

interface toFieldProps {
  (): IFieldFactoryProps
}
```

IFieldFactoryProps 参考 [IFieldFactoryProps](https://core.formilyjs.org/zh-CN/api/models/form#ifieldfactoryprops)

## 静态方法

### getOrderProperties

#### 描述

从 Schema 中获取排序后的 properties

#### 签名

```ts
interface getOrderProperties {
  (schema: ISchema = {}, propertiesName: keyof ISchema = 'properties'): ISchema
}
```

### compile

#### 描述

深度遍历任意对象中的表达式片段，表达式片段约定：以`{{`开头`}}`结尾的字符串代表一个表达式片段

#### 签名

```ts
interface compile {
  (target: any, scope: any): any
}
```

### shallowCompile

#### 描述

浅层遍历任意对象中的表达式片段，表达式片段约定：以`{{`开头`}}`结尾的字符串代表一个表达式片段

#### 签名

```ts
interface shallowCompile {
  (target: any, scope: any): any
}
```

### silent

#### 描述

是否静默编译，如果是，则表达式报错不会有任何提醒

#### 签名

```ts
interface silent {
  (value?: boolean): void
}
```

### isSchemaInstance

#### 描述

判断某个对象是否为 Schema Class 的实例对象

#### 签名

```ts
interface isSchemaInstance {
  (target: any): target is Schema
}
```

### registerCompiler

#### 描述

注册表达式编译器

#### 签名

```ts
interface registerCompiler {
  (compiler: (expression: string, scope: any) => any): void
}
```

### registerPatches

#### 描述

注册 Schema 补丁，方便做不同版本的 Schema 协议兼容

#### 签名

```ts
type SchemaPatch = (schema: ISchema) => ISchema

interface registerPatches {
  (...args: SchemaPatch[]): void
}
```

### registerVoidComponents

#### 描述

给字段组件打上标识，标识该组件是虚拟组件，与 formily1.x 做兼容

#### 签名

```ts
interface registerVoidComponents {
  (components: string[]): void
}
```

#### 用例

```ts
import { Schema } from '@formily/react'

Schema.registerVoidComponents(['card', 'tab', 'step'])
```

<Alert type="warning">
  注意，该 api 需要配合 <code>enablePolyfills(['1.0'])</code> 使用
</Alert>

### registerTypeDefaultComponents

#### 描述

给 Schema 类型标识默认组件类型

#### 签名

```ts
interface registerTypeDefaultComponents {
  (maps: Record<string, string>): void
}
```

#### 用例

```ts
import { Schema } from '@formily/react'

Schema.registerTypeDefaultComponents({
  string: 'Input',
  number: 'NumberPicker',
  array: 'ArrayTable',
})
```

<Alert type="warning">
  注意，该 api 需要配合 <code>enablePolyfills(['1.0'])</code> 使用
</Alert>

### registerPolyfills

#### 描述

注册协议兼容垫片

#### 签名

```ts
type SchemaPatch = (schema: ISchema) => ISchema

interface registerPolyfills {
  (version: string, patch: SchemaPatch): void
}
```

#### 用例

```ts
import { Schema } from '@formily/react'

Schema.registerPolyfills('1.0', (schema) => {
  schema['x-decorator'] = 'FormItem'
  return schema
})
```

### enablePolyfills

#### 描述

开启协议垫片，默认内置 1.0 版本协议兼容垫片，主要兼容特性：

- x-decorator 不声明，自动作为 FormItem
- x-linkages 转换为 x-reactions
- x-props 自动转换为 x-decorator-props
- x-rules 转换为 x-validator
- editable 转换为 x-editable
- visible 转换为 x-visible
- x-component 为 card/block/grid-row/grid-col/grid/layout/step/tab/text-box 自动转换 VoidField，

#### 签名

```ts
interface enablePolyfills {
  (versions: string[]): void
}
```

#### 用例

```ts
import { Schema } from '@formily/react'

Schema.enablePolyfills(['1.0'])
```

## 类型

### ISchema

#### 描述

ISchema 就是一份普通 JSON 数据，同时它是遵循 Schema [属性](#属性) 规范的 JSON 数据

### SchemaTypes

#### 描述

Schema 描述的类型

#### 签名

```ts
type SchemaTypes =
  | 'string'
  | 'object'
  | 'array'
  | 'number'
  | 'boolean'
  | 'void'
  | 'date'
  | 'datetime'
  | (string & {})
```

### SchemaProperties

#### 描述

Schema 属性描述

#### 签名

```ts
type SchemaProperties = Record<string, ISchema>
```

### SchemaItems

#### 描述

Schema 数组项描述

#### 签名

```ts
type SchemaItems = ISchema | ISchema[]
```

### SchemaEnum

#### 描述

Schema 枚举

#### 签名

```ts
type SchemaEnum<Message> = Array<
  | string
  | number
  | { label: Message; value: any; [key: string]: any }
  | { key: any; title: Message; [key: string]: any }
>
```

### SchemaReactions

#### 描述

Schema 联动协议，如果 reaction 对象里包含 target，则代表主动联动模式，否则代表被动联动模式  
如果想实现更复杂的联动，可以通过作用域传入 reaction 响应器函数进行处理  
FormPathPattern 路径语法文档看[这里](https://core.formilyjs.org/zh-CN/api/entry/form-path#formpathpattern)

#### 签名

```ts
import { IGeneralFieldState } from '@formily/core'

type SchemaReactionEffect =
  | 'onFieldInit'
  | 'onFieldMount'
  | 'onFieldUnmount'
  | 'onFieldValueChange'
  | 'onFieldInputValueChange'
  | 'onFieldInitialValueChange'
  | 'onFieldValidateStart'
  | 'onFieldValidateEnd'
  | 'onFieldValidateFailed'
  | 'onFieldValidateSuccess'

type SchemaReaction<Field = any> =
  | {
      dependencies?: //依赖的字段路径列表，支持FormPathPattern数据路径语法, 只能以点路径描述依赖，支持相对路径
      | Array<
            | string //如果数组里是string，那么读的时候也是数组格式
            | {
                //如果数组里是对象, 那么读的时候通过name从$deps获取
                name?: string //从$deps读取时的别名
                type?: string //字段类型
                source?: string //字段路径
                property?: string //依赖属性, 默认为value
              }
          >
        | Record<string, string> //如果是对象格式，读的时候也是对象格式，只是对象的key相当于别名
      when?: string | boolean //联动条件
      target?: string //要操作的字段路径，支持FormPathPattern匹配路径语法，注意：不支持相对路径！！
      effects?: SchemaReactionEffect[] //主动模式下的独立生命周期钩子
      fulfill?: {
        //满足条件
        state?: IGeneralFieldState //更新状态
        schema?: ISchema //更新Schema
        run?: string //执行语句
      }
      otherwise?: {
        //不满足条件
        state?: IGeneralFieldState //更新状态
        schema?: ISchema //更新Schema
        run?: string //执行语句
      }
    }
  | ((field: Field) => void) //支持函数, 可以复杂联动

type SchemaReactions<Field = any> =
  | SchemaReaction<Field>
  | SchemaReaction<Field>[] //支持传入数组
```

#### 用例

**主动联动**

写法一，标准主动联动

```json
{
  "type": "object",
  "properties": {
    "source": {
      "type": "string",
      "x-component": "Input",
      "x-reactions": {
        "target": "target",
        "when": "{{$self.value === '123'}}",
        "fulfill": {
          "state": {
            "visible": false
          }
        },
        "otherwise": {
          "state": {
            "visible": true
          }
        }
      }
    },
    "target": {
      "type": "string",
      "x-component": "Input"
    }
  }
}
```

写法二，局部表达式分发联动

```json
{
  "type": "object",
  "properties": {
    "source": {
      "type": "string",
      "x-component": "Input",
      "x-reactions": {
        "target": "target",
        "fulfill": {
          "state": {
            "visible": "{{$self.value === '123'}}" //任意层次属性都支持表达式
          }
        }
      }
    },
    "target": {
      "type": "string",
      "x-component": "Input"
    }
  }
}
```

写法三，基于 Schema 协议联动

```json
{
  "type": "object",
  "properties": {
    "source": {
      "type": "string",
      "x-component": "Input",
      "x-reactions": {
        "target": "target",
        "fulfill": {
          "schema": {
            "x-visible": "{{$self.value === '123'}}" //任意层次属性都支持表达式
          }
        }
      }
    },
    "target": {
      "type": "string",
      "x-component": "Input"
    }
  }
}
```

写法四，基于 run 语句联动

```json
{
  "type": "object",
  "properties": {
    "source": {
      "type": "string",
      "x-component": "Input",
      "x-reactions": {
        "fulfill": {
          "run": "$form.setFieldState('target',state=>{state.visible = $self.value === '123'})"
        }
      }
    },
    "target": {
      "type": "string",
      "x-component": "Input"
    }
  }
}
```

写法五，基于生命周期钩子联动

```json
{
  "type": "object",
  "properties": {
    "source": {
      "type": "string",
      "x-component": "Input",
      "x-reactions": {
        "target": "target",
        "effects": ["onFieldInputValueChange"],
        "fulfill": {
          "state": {
            "visible": "{{$self.value === '123'}}" //任意层次属性都支持表达式
          }
        }
      }
    },
    "target": {
      "type": "string",
      "x-component": "Input"
    }
  }
}
```

**被动联动**

写法一，标准被动联动

```json
{
  "type": "object",
  "properties": {
    "source": {
      "type": "string",
      "x-component": "Input"
    },
    "target": {
      "type": "string",
      "x-component": "Input",
      "x-reactions": {
        "dependencies": ["source"], //依赖路径写法默认是取value，如果依赖的是字段的其他属性，可以使用 source#modified，用#分割取详细属性
        // "dependencies":{ aliasName:"source" }, //别名形式
        "fulfill": {
          "schema": {
            "x-visible": "{{$deps[0] === '123'}}" //任意层次属性都支持表达式
          }
        }
      }
    }
  }
}
```

写法二，相邻元素联动

```json
{
  "type": "array",
  "x-component": "ArrayTable",
  "items": {
    "type": "object",
    "properties": {
      "source": {
        "type": "string",
        "x-component": "Input"
      },
      "target": {
        "type": "string",
        "x-component": "Input",
        "x-reactions": {
          "dependencies": [".source"],
          "fulfill": {
            "schema": {
              "x-visible": "{{$deps[0] === '123'}}"
            }
          }
        }
      }
    }
  }
}
```

**复杂联动**

```json
{
  "type": "object",
  "properties": {
    "source": {
      "type": "string",
      "x-component": "Input"
    },
    "target": {
      "type": "string",
      "x-component": "Input",
      "x-reactions": "{{myReaction}}" //外部传入的函数，在函数内可以实现更复杂的联动
    }
  }
}
```

**组件属性联动**

写法一，操作状态

```json
{
  "type": "object",
  "properties": {
    "source": {
      "type": "string",
      "x-component": "Input",
      "x-reactions": {
        "target": "target",
        "fulfill": {
          "state": {
            "component[1].style.color": "{{$self.value === '123' ? 'red' : 'blue'}}" //任意层次属性都支持表达式，同时key是支持路径表达式的，可以实现精确操作属性
          }
        }
      }
    },
    "target": {
      "type": "string",
      "x-component": "Input"
    }
  }
}
```

写法二，操作 Schema 协议

```json
{
  "type": "object",
  "properties": {
    "source": {
      "type": "string",
      "x-component": "Input",
      "x-reactions": {
        "target": "target",
        "fulfill": {
          "schema": {
            "x-component-props.style.color": "{{$self.value === '123' ? 'red' : 'blue'}}" //任意层次属性都支持表达式，同时key是支持路径表达式的，可以实现精确操作属性
          }
        }
      }
    },
    "target": {
      "type": "string",
      "x-component": "Input"
    }
  }
}
```

### Slot

#### 描述

标记该节点为 Slot 节点，会在常规渲染流程中被跳过  
通过 `target` 指定此节点渲染的目标属性，必须为同级兄弟节点属性  
可以通过 `isRenderProp` 来指定该节点以 renderProp 函数形式传入  
当`isRenderProp`为`true`时，在 Slot 中可以通过`$slotArgs`访问到 renderProp 函数入参参数列表

#### 签名

```ts
type Slot = {
  //Slot目标，指定此节点渲染的目标属性，必须为同级兄弟节点属性
  target: string // 'some-sibling-node.x-component-props.xxx' 或 'some-sibling-node.x-decorator-props.xxx'
  //Slot是否为render prop
  isRenderProp?: boolean
}
```

#### 用例

**ReactNode Prop**  
参考 [SchemaField](https://react.formilyjs.org/zh-CN/api/components/schema-field#json-schema-reactnode-prop-%E7%94%A8%E4%BE%8B-x-slot-node)

```json
{
  "type": "object",
  "properties": {
    "search_icon": {
      "x-slot-node": {
        "target": "button.x-component-props.icon" //指定将search_icon节点作为slot渲染到Button组件的icon prop中
      },
      "x-component": "SearchOutlined",
      "x-component-props": {
        "data-testid": "icon"
      }
    },
    "button": {
      "type": "string",
      "x-component": "Button",
      "x-component-props": {
        "data-testid": "button"
      }
    }
  }
}
```

**RenderProp**  
参考 [SchemaField](https://react.formilyjs.org/zh-CN/api/components/schema-field#json-schema-render-prop-%E7%94%A8%E4%BE%8B-x-slot-node--isrenderprop)

```json
{
  "type": "object",
  "properties": {
    "dollar_icon": {
      "x-slot-node": {
        "target": "rate.x-component-props.character", //指定将dollar_icon节点作为slot渲染到Rate组件的character prop中
        "isRenderProp": true //character prop接受一个renderProp函数，指定Slot作为renderProp传入，接管评分图标渲染
      },
      "x-component": "DollarOutlined",
      "x-component-props": {
        "data-testid": "icon",
        "rotate": "{{$slotArgs[0].value * 45}}", //当isRenderProp为true时，在Slot中可以通过$slotArgs访问到renderProp函数入参参数列表
        "style": {
          "fontSize": "50px"
        }
      }
    },
    "rate": {
      "x-component": "Rate"
    }
  }
}
```

## 内置表达式作用域

内置表达式作用域主要用于在表达式中实现各种联动关系

### $self

代表当前字段实例，可以在普通属性表达式中使用，也能在 x-reactions 中使用

### $values

代表顶层表单数据，可以在普通属性表达式中使用，也能在 x-reactions 中使用

### $form

代表当前 Form 实例，可以在普通属性表达式中使用，也能在 x-reactions 中使用

### $observable

用于创建响应式对象，使用方式与 observable 一致

### $memo

用于创建持久引用数据，使用方式与 autorun.memo 一致

### $effect

用于响应 autorun 第一次执行的下一个微任务时机与响应 autorun 的 dispose，使用方式与 autorun.effect 一致

### $dependencies

只能在 x-reactions 中的表达式消费，与 x-reactions 定义的 dependencies 对应，数组顺序一致

### $deps

只能在 x-reactions 中的表达式消费，与 x-reactions 定义的 dependencies 对应，数组顺序一致

### $target

只能在 x-reactions 中的表达式消费，代表主动模式的 target 字段

### $slotArgs

只能在 Slot 节点中消费。当为 render prop slot 时，可以通过$slotArgs 获取渲染函数入参数组
</file>

<file path="packages/react/docs/guide/architecture.md">
# Core Architecture

The architecture of @formily/react is not complicated compared to @formily/core. First look at the architecture diagram:

![](https://img.alicdn.com/imgextra/i1/O1CN013jbRfk1l5n6N7jYH8_!!6000000004768-55-tps-2200-1637.svg)

From this architecture diagram, we can see that @formily/react supports two types of users, one is pure source code development users, they only need to use the Field/ArrayField/ObjectField/VoidField component. The other type is users who do dynamic development based on JSON-Schema. They mainly rely on the SchemaField component. However, both types of users need to use a FormProvider component to uniformly deliver the context. Then there is the SchemaField component, which is actually the dependent Field/ArrayField/ObjectField/VoidField component inside.
</file>

<file path="packages/react/docs/guide/architecture.zh-CN.md">
# 核心架构

@formily/react 的架构相比于@formily/core 并不复杂，先看架构图：

![](https://img.alicdn.com/imgextra/i1/O1CN013jbRfk1l5n6N7jYH8_!!6000000004768-55-tps-2200-1637.svg)

从这张架构图中我们可以看到，@formily/react 支持了两类用户，一类就是纯源码开发用户，他们只需要使用 Field/ArrayField/ObjectField/VoidField 组件。另一类就是基于 JSON-Schema 做动态开发的用户，他们依赖的主要是 SchemaField 组件，但是，这两类用户都需要使用一个 FormProvider 的组件来统一下发上下文。然后是 SchemaField 组件，它内部其实是依赖的 Field/ArrayField/ObjectField/VoidField 组件。
</file>

<file path="packages/react/docs/guide/concept.md">
# Core idea

The architecture of @formily/react itself is not complicated, because it only provides a series of components and Hooks for users to use, but we still need to understand the following concepts:

- Form context
- Field context
- Protocol context
- Model binding
- Protocol driven
- Three development modes

## Form context

From the [architecture diagram](/guide/architecture) we can see that FormProvider exists as a unified context for forms, and its position is very important. It is mainly used to create [Form](//core. formilyjs.org/api/models/form) instances are distributed to all sub-components, whether in built-in components or user-extended components, can be read through [useForm](/api/hooks/use-form) [ Form](//core.formilyjs.org/api/models/form) instance

## Field context

From the [architecture diagram](/guide/architecture) we can see that whether it is Field/ArrayField/ObjectField/VoidField, a FieldContext will be issued to the subtree. We can read the current field model in the custom component, mainly Use [useField](/api/hooks/use-field) to read, which is very convenient for model mapping

## Protocol context

From the [architecture diagram](/guide/architecture) we can see that [RecursionField](/api/components/recursion-field) will send a FieldSchemaContext to the subtree, and we can read the current field in the custom component The Schema description is mainly read using [useFieldSchema](/api/hooks/useFieldSchema). Note that this Hook can only be used in the [SchemaField](/api/components/SchemaField) and [RecursionField](/api/components/recursion-field) subtrees

## Model binding

To understand model binding, you need to understand what [MVVM](//core.formilyjs.org/guide/mvvm) is. After understanding, let’s take a look at this picture:

![](https://img.alicdn.com/imgextra/i1/O1CN01A03C191KwT1raxnDg_!!6000000001228-55-tps-2200-869.svg)

In Formily, @formily/core is ViewModel, Component and Decorator are View, @formily/react is the glue layer that binds ViewModel and View, and the binding of ViewModel and View is called model binding, which implements model binding. The main methods are [useField](/api/hooks/use-field), and [connect](/api/shared/connect) and [mapProps](/api/shared/map-props) can also be used. Note that Component only needs to support the value/onChange property to automatically realize the two-way binding of the data layer.

## JSON Schema Driver

Protocol-driven rendering is the most expensive part of @formily/react, but after learning it, the benefits it brings to the business are also very high. A total of 4 core concepts need to be understood:

- Schema
- Recursive rendering
- Protocol binding
- Three development modes

### Schema

Formily’s protocol driver is mainly based on the standard JSON Schema to drive rendering. At the same time, we have extended some `x-*` attributes to express the UI on top of the standard, so that the entire protocol can fully describe a complex form. Schema protocol, refer to [Schema](/api/shared/schema) API document

### Recursive rendering

What is recursive rendering? Recursive rendering means that component A will continue to use component A to render content under certain conditions. Take a look at the following pseudo code:

```json
{<---- RecursionField (condition: object; rendering right: RecursionField)
  "type":"object",
  "properties":{
    "username":{ <---- RecursionField (condition: string; rendering right: RecursionField)
      "type":"string",
      "x-component":"Input"
    },
    "phone":{ <---- RecursionField (condition: string; rendering right: RecursionField)
      "type":"string",
      "x-component":"Input",
      "x-validator":"phone"
    },
    "email":{ <---- RecursionField (condition: string; rendering right: RecursionField)
      "type":"string",
      "x-component":"Input",
      "x-validator":"email"
    },
    "contacts":{ <---- RecursionField (condition: array; rendering right: RecursionField)
      "type":"array",
      "x-component":"ArrayTable",
      "items":{ <---- RecursionField (condition: object; rendering rights: ArrayTable component)
        "type":"object",
        "properties":{
          "username":{ <---- RecursionField (condition: string; rendering right: RecursionField)
            "type":"string",
            "x-component":"Input"
          },
          "phone":{ <---- RecursionField (condition: string; rendering right: RecursionField)
            "type":"string",
            "x-component":"Input",
            "x-validator":"phone"
          },
          "email":{ <---- RecursionField (condition: string; rendering right: RecursionField)
            "type":"string",
            "x-component":"Input",
            "x-validator":"email"
          },
        }
      }
    }
  }
}
```

@formily/react The entry point for recursive rendering is [SchemaField](/api/components/schema-field), but it actually uses [RecursionField](/api/components/recursion-field) to render internally, because of JSON-Schema It is a recursive structure, so [RecursionField](/api/components/recursion-field) will be parsed from the top-level Schema node when rendering. If it is a non-object and array type, it will directly render the specific component. If it is an object, it will traverse. properties Continue to use [RecursionField](/api/components/recursion-field) to render child Schema nodes.

A special case here is the rendering of the array type auto-increment list, which requires the user to use [RecursionField](/api/components/recursion-field) in the custom component for recursive rendering, because the UI of the auto-increment list is very customized High, so the recursive rendering rights are handed over to the user to render, so the design can also make protocol-driven rendering more flexible.

What is the difference between SchemaField and RecursionField? There are two main points:

- SchemaField supports Markup grammar, it will parse Markup grammar in advance to generate [JSON Schema](/api/shared/schema) and transfer it to RecursionField for rendering, so RecursionField can only be rendered based on [JSON Schema](/api/shared/schema)
- SchemaField renders the overall Schema protocol, while RecursionField renders the partial Schema protocol

### Protocol binding

I talked about model binding, and protocol binding is the process of converting Schema protocol into model binding, because JSON-Schema protocol is a JSON string and can be stored offline, while model binding is a binding between memory The relationship is at the Runtime layer. For example, `x-component` is the string identifier of the component in the Schema, but the component in the model requires component reference, so the JSON string and the Runtime layer need to be converted. Then we can continue to improve the above model binding diagram:

![](https://img.alicdn.com/imgextra/i3/O1CN01jLCRxH1aa3V0x6nw4_!!6000000003345-55-tps-2200-1147.svg)

To sum up, in @formily/react, there are mainly two layers of binding relationships, Schema binding model, model binding component, the glue layer that realizes the binding is @formily/react, it should be noted that Schema binds the field model After that, the Schema is not perceptible in the field model. For example, if you want to modify the `enum`, you need to modify the `dataSource` attribute in the field model. In short, if you want to update the field model, refer to [Field](//core.formilyjs. org/api/models/field), you can refer to [Schema](/api/shared/schema) document if you want to understand the mapping relationship between Schema and field model

## Three development models

From the [architecture diagram](/guide/architecture), we have actually seen that the entire @formily/react has three development modes, corresponding to different users:

- JSX development model
- JSON Schema development mode
- Markup Schema development mode

We can look at specific examples

#### JSX development model

This mode mainly uses Field/ArrayField/ObjectField/VoidField components

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'
import { Input } from 'antd'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field name="input" component={[Input, { placeholder: 'Please enter' }]} />
  </FormProvider>
)
```

#### JSON Schema Development Mode

This mode is to pass JSON Schema to the schema attribute of SchemaField

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Input } from 'antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    Input,
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField
      schema={{
        type: 'object',
        properties: {
          input: {
            type: 'string',
            'x-component': 'Input',
            'x-component-props': {
              placeholder: 'Please enter',
            },
          },
        },
      }}
    />
  </FormProvider>
)
```

#### Markup Schema Development Mode

This mode can be regarded as a Schema development mode that is more friendly to source code development, and it also uses the SchemaField component.

Because it is difficult to get the best smart prompt experience in the JSX environment with JSON Schema, and it is inconvenient to maintain, the maintainability in the form of tags will be better, and the smart prompt is also very strong.

Markup Schema mode mainly has the following characteristics:

- Mainly rely on description tags such as SchemaField.String/SchemaField.Array/SchemaField.Object... to express Schema
- Each description tag represents a Schema node, which is equivalent to JSON-Schema
- SchemaField child nodes cannot insert UI elements at will, because SchemaField will only parse all the Schema description tags of the child nodes, and then convert them into JSON Schema, and finally give it to [RecursionField](/api/components/recursion-field) for rendering, if you want Insert UI elements, you can upload the `x-content` attribute in VoidDield to insert UI elements

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Input } from 'antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    Input,
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        x-component="Input"
        x-component-props={{ placeholder: 'Please enter' }}
      />
      <div>I will not be rendered</div>
      <SchemaField.Void x-content={<div>I will be rendered</div>} />
    </SchemaField>
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/guide/concept.zh-CN.md">
# 核心概念

@formily/react 本身架构不复杂，因为它只是提供了一系列的组件和 Hooks 给用户使用，但是我们还是需要理解以下几个概念：

- 表单上下文
- 字段上下文
- 协议上下文
- 模型绑定
- 协议驱动
- 三种开发模式

## 表单上下文

从[架构图](/guide/architecture)中我们可以看到 FormProvider 是作为表单统一上下文而存在，它的地位非常重要，主要用于将@formily/core 创建出来的[Form](//core.formilyjs.org/zh-CN/api/models/form)实例下发到所有子组件中，不管是在内置组件还是用户扩展的组件，都能通过[useForm](/api/hooks/use-form)读取到[Form](//core.formilyjs.org/zh-CN/api/models/form)实例

## 字段上下文

从[架构图](/guide/architecture)中我们可以看到不管是 Field/ArrayField/ObjectField/VoidField，会给子树下发一个 FieldContext，我们可以在自定义组件中读取到当前字段模型，主要是使用[useField](/api/hooks/use-field)来读取，这样非常方便于做模型映射

## 协议上下文

从[架构图](/guide/architecture)中我们可以看到[RecursionField](/api/components/recursion-field)会给子树下发一个 FieldSchemaContext，我们可以在自定义组件中读取到当前字段的 Schema 描述，主要是使用[useFieldSchema](/api/hooks/useFieldSchema)来读取。注意，该 Hook 只能用在[SchemaField](/api/components/SchemaField)和[RecursionField](/api/components/recursion-field)子树中使用

## 模型绑定

想要理解模型绑定，需要先理解什么是[MVVM](//core.formilyjs.org/zh-CN/guide/mvvm)，理解了之后我们再看看这张图：

![](https://img.alicdn.com/imgextra/i1/O1CN01A03C191KwT1raxnDg_!!6000000001228-55-tps-2200-869.svg)

在 Formily 中，@formily/core 就是 ViewModel，Component 和 Decorator 就是 View，@formily/react 就是将 ViewModel 和 View 绑定起来的胶水层，ViewModel 和 View 的绑定就叫做模型绑定，实现模型绑定的手段主要有[useField](/api/hooks/use-field)，也能使用[connect](/api/shared/connect)和[mapProps](/api/shared/map-props)，需要注意的是，Component 只需要支持 value/onChange 属性即可自动实现数据层的双向绑定。

## 协议驱动

协议驱动渲染算是@formily/react 中学习成本最高的部分了，但是学会了之后，它给业务带来的收益也是很高，总共需要理解 4 个核心概念：

- Schema
- 递归渲染
- 协议绑定
- 三种开发模式

### Schema

formily 的协议驱动主要是基于标准 JSON Schema 来进行驱动渲染的，同时我们在标准之上又扩展了一些`x-*`属性来表达 UI，使得整个协议可以具备完整描述一个复杂表单的能力，具体 Schema 协议，参考[Schema](/api/shared/schema) API 文档

### 递归渲染

何为递归渲染？递归渲染就是组件 A 在某些条件下会继续用组件 A 来渲染内容，看看以下伪代码：

```json
{ <---- RecursionField(条件：object；渲染权：RecursionField)
  "type":"object",
  "properties":{
    "username":{ <---- RecursionField(条件：string；渲染权：RecursionField)
      "type":"string",
      "x-component":"Input"
    },
    "phone":{ <---- RecursionField(条件：string；渲染权：RecursionField)
      "type":"string",
      "x-component":"Input",
      "x-validator":"phone"
    },
    "email":{ <---- RecursionField(条件：string；渲染权：RecursionField)
      "type":"string",
      "x-component":"Input",
      "x-validator":"email"
    },
    "contacts":{ <---- RecursionField(条件：array；渲染权：RecursionField)
      "type":"array",
      "x-component":"ArrayTable",
      "items":{ <---- RecursionField(条件：object；渲染权：ArrayTable组件)
        "type":"object",
        "properties":{
          "username":{ <---- RecursionField(条件：string；渲染权：RecursionField)
            "type":"string",
            "x-component":"Input"
          },
          "phone":{ <---- RecursionField(条件：string；渲染权：RecursionField)
            "type":"string",
            "x-component":"Input",
            "x-validator":"phone"
          },
          "email":{ <---- RecursionField(条件：string；渲染权：RecursionField)
            "type":"string",
            "x-component":"Input",
            "x-validator":"email"
          },
        }
      }
    }
  }
}
```

@formily/react 递归渲染的入口是[SchemaField](/api/components/schema-field)，但它内部实际是使用 [RecursionField](/api/components/recursion-field) 来渲染的，因为 JSON-Schema 就是一个递归型结构，所以 [RecursionField](/api/components/recursion-field) 在渲染的时候会从顶层 Schema 节点解析，如果是非 object 和 array 类型则直接渲染具体组件，如果是 object，则会遍历 properties 继续用 [RecursionField](/api/components/recursion-field) 渲染子级 Schema 节点。

这里有点特殊的情况是 array 类型的自增列表渲染，需要用户在自定义组件内使用[RecursionField](/api/components/recursion-field)进行递归渲染，因为自增列表的 UI 个性化定制程度很高，所以就把递归渲染权交给用户来渲染了，这样设计也能让协议驱动渲染变得更加灵活。

那 SchemaField 和 RecursionField 有啥差别呢？主要有两点：

- SchemaField 是支持 Markup 语法的，它会提前解析 Markup 语法生成[JSON Schema](/api/shared/schema)移交给 RecursionField 渲染，所以 RecursionField 只能基于 [JSON Schema](/api/shared/schema) 渲染
- SchemaField 渲染的是整体的 Schema 协议，而 RecursionField 渲染的是局部 Schema 协议

### 协议绑定

前面讲了模型绑定，而协议绑定则是将 Schema 协议转换成模型绑定的过程，因为 JSON-Schema 协议是 JSON 字符串，可离线存储的，而模型绑定则是内存间的绑定关系，是 Runtime 层的，比如`x-component`在 Schema 中是组件的字符串标识，但是在模型中的 component 则是需要组件引用，所以 JSON 字符串与 Runtime 层是需要转换的。然后我们就可以继续完善一下以上模型绑定的图：

![](https://img.alicdn.com/imgextra/i3/O1CN01jLCRxH1aa3V0x6nw4_!!6000000003345-55-tps-2200-1147.svg)

总结下来，在@formily/react 中，主要有 2 层绑定关系，Schema 绑定模型，模型绑定组件，实现绑定的胶水层就是@formily/react，需要注意的是，Schema 绑定字段模型之后，字段模型中是感知不到 Schema 的，比如要修改`enum`，就是修改字段模型中的`dataSource`属性了，总之，想要更新字段模型，参考[Field](//core.formilyjs.org/zh-CN/api/models/field)，想要理解 Schema 与字段模型的映射关系可以参考[Schema](/api/shared/schema)文档

## 三种开发模式

从[架构图](/guide/architecture)中我们其实已经看到整个@formily/react 是有三种开发模式的，对应不同用户：

- JSX 开发模式
- JSON Schema 开发模式
- Markup Schema 开发模式

我们可以看看具体例子

#### JSX 开发模式

该模式主要是使用 Field/ArrayField/ObjectField/VoidField 组件

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, Field } from '@formily/react'
import { Input } from 'antd'

const form = createForm()

export default () => (
  <FormProvider form={form}>
    <Field name="input" component={[Input, { placeholder: '请输入' }]} />
  </FormProvider>
)
```

#### JSON Schema 开发模式

该模式是给 SchemaField 的 schema 属性传递 JSON Schema 即可

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Input } from 'antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    Input,
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField
      schema={{
        type: 'object',
        properties: {
          input: {
            type: 'string',
            'x-component': 'Input',
            'x-component-props': {
              placeholder: '请输入',
            },
          },
        },
      }}
    />
  </FormProvider>
)
```

#### Markup Schema 开发模式

该模式算是一个对源码开发比较友好的 Schema 开发模式，同样是使用 SchemaField 组件。

因为用 JSON Schema 在 JSX 环境下很难得到最好的智能提示体验，而且也不方便维护，用标签的形式可维护性会更好，智能提示也很强。

Markup Schema 模式主要有以下几个特点：

- 主要依赖 SchemaField.String/SchemaField.Array/SchemaField.Object...这类描述标签来表达 Schema
- 每个描述标签都代表一个 Schema 节点，与 JSON-Schema 等价
- SchemaField 子节点不能随意插 UI 元素，因为 SchemaField 只会解析子节点的所有 Schema 描述标签，然后转换成 JSON Schema，最终交给[RecursionField](/api/components/recursion-field)渲染，如果想要插入 UI 元素，可以在 VoidField 上传`x-content`属性来插入 UI 元素

```tsx
import React from 'react'
import { createForm } from '@formily/core'
import { FormProvider, createSchemaField } from '@formily/react'
import { Input } from 'antd'

const form = createForm()

const SchemaField = createSchemaField({
  components: {
    Input,
  },
})

export default () => (
  <FormProvider form={form}>
    <SchemaField>
      <SchemaField.String
        x-component="Input"
        x-component-props={{ placeholder: '请输入' }}
      />
      <div>我不会被渲染</div>
      <SchemaField.Void x-content={<div>我会被渲染</div>} />
    </SchemaField>
  </FormProvider>
)
```
</file>

<file path="packages/react/docs/guide/index.md">
# Introduction

The core positioning of @formily/react is to realize a state binding relationship between ViewModel ([@formily/core](//core.formilyjs.org)) and components. It is not responsible for managing form data and form verification. It is only A rendering glue layer, but such a layer of glue is not dirty, it will elegantly decouple a lot of dirty logic and become maintainable.

## Ultra high performance

With the responsive model of [@formily/core](//core.formilyjs.org), @formily/react can obtain super high performance advantages without any optimization, relying on tracking, accurate updates, on-demand rendering, let us The form of really does only need to focus on business logic, without considering performance issues.

## Out of the box

@formily/react provides a series of React components, such as Field/ArrayField/ObjectField/VoidField. When using it, users only need to pass the component property to the Field component (supporting two-way binding conventions such as value/onChange). Quick access to @formily/react, the access cost is extremely low.

## JSON Schema Driver

@formily/react provides protocol-driven components such as SchemaField. It is also driven by the standard JSON-Schema, so that form development can become more dynamic and configurable. What's more, we can achieve a protocol that allows multiple terminals Render the form.

## Scene Reuse

With the help of protocol-driven capabilities, we can abstract a protocol fragment carrying business logic into a scene component to help users develop efficiently in certain scenes, such as scene components such as FormTab and FormStep.

## Smart tips

Because formily is a complete Typescript project, users can develop on VSCode or WebStorm to get the maximum intelligent prompt experience

![img](https://img.alicdn.com/imgextra/i2/O1CN01yiREHk1X95KJPPz1c_!!6000000002880-2-tps-2014-868.png)

## Status observable

Install [FormilyDevtools](https://chrome.google.com/webstore/detail/formily-devtools/kkocalmbfnplecdmbadaapgapdioecfm?hl=zh-CN) to observe the model status changes in real time and troubleshoot problems

![img](https://img.alicdn.com/imgextra/i4/O1CN01DSci5h1rAGfRafpXw_!!6000000005590-2-tps-2882-1642.png)
</file>

<file path="packages/react/docs/guide/index.zh-CN.md">
# 介绍

@formily/react 的核心定位是将 ViewModel([@formily/core](//core.formilyjs.org))与组件实现一个状态绑定关系，它不负责管理表单数据，表单校验，它仅仅是一个渲染胶水层，但是这样一层胶水，并不脏，它会把很多脏逻辑优雅的解耦，变得可维护。

## 超高性能

借助 [@formily/core](//core.formilyjs.org) 的响应式模型，@formily/react 无需做任何优化即可获得超高的性能优势，依赖追踪，精确更新，按需渲染，让我们的表单真正做到了只需关注业务逻辑，无需考虑性能问题。

## 开箱即用

@formily/react 提供了一系列的 React 组件，比如 Field/ArrayField/ObjectField/VoidField，用户在使用的时候，只需要给 Field 组件传入 component 属性(支持 value/onChange 这样的双向绑定约定)即可快速接入@formily/react，接入成本极低。

## 协议驱动

@formily/react 提供了 SchemaField 这样的协议驱动组件，同时是基于标准 JSON-Schema 的驱动，让表单开发可以变得更加动态化，可配置化，更甚，我们可以做到一份协议，让多端渲染表单。

## 场景复用

借助协议驱动的能力，我们可以将一个携带业务逻辑的协议片段抽象成一个场景组件，帮助用户在某些场景上高效开发，比如 FormTab、FormStep 这类场景组件。

## 智能提示

因为 formily 是完全的 Typescript 项目，所以用户在 VSCode 或 WebStorm 等上开发可以获得最大化的智能提示体验

![img](https://img.alicdn.com/imgextra/i2/O1CN01yiREHk1X95KJPPz1c_!!6000000002880-2-tps-2014-868.png)

## 状态可观测

安装 [FormilyDevtools](https://chrome.google.com/webstore/detail/formily-devtools/kkocalmbfnplecdmbadaapgapdioecfm?hl=zh-CN) 可以实时观测模型状态变化，排查问题

![img](https://img.alicdn.com/imgextra/i4/O1CN01DSci5h1rAGfRafpXw_!!6000000005590-2-tps-2882-1642.png)
</file>

<file path="packages/react/docs/index.md">
---
title: Formily-Alibaba unified front-end form solution
order: 10
hero:
  title: React Library
  desc: Alibaba Unified Form Solution
  actions:
    - text: Home Site
      link: //formilyjs.org
    - text: Development Guide
      link: /guide
features:
  - icon: https://img.alicdn.com/imgextra/i1/O1CN01bHdrZJ1rEOESvXEi5_!!6000000005599-55-tps-800-800.svg
    title: Ultra High Performance
    desc: Dependency tracking, efficient update, on-demand rendering
  - icon: https://img.alicdn.com/imgextra/i2/O1CN016i72sH1c5wh1kyy9U_!!6000000003550-55-tps-800-800.svg
    title: Out Of The Box
    desc: The component status is automatically bound, and the access cost is extremely low
  - icon: https://img.alicdn.com/imgextra/i3/O1CN01JHzg8U1FZV5Mvt012_!!6000000000501-55-tps-800-800.svg
    title: JSON Schema Driver
    desc: Standard JSON-Schema
  - icon: https://img.alicdn.com/imgextra/i3/O1CN0194OqFF1ui6mMT4g7O_!!6000000006070-55-tps-800-800.svg
    title: Scene Reuse
    desc: Based on protocol-driven, abstract scene components
  - icon: https://img.alicdn.com/imgextra/i4/O1CN018vDmpl2186xdLu6KI_!!6000000006939-55-tps-800-800.svg
    title: Debugging Friendly
    desc: Natural docking with Formily DevTools
  - icon: https://img.alicdn.com/imgextra/i4/O1CN01u6jHgs1ZMwXpjAYnh_!!6000000003181-55-tps-800-800.svg
    title: Smart Tips
    desc: Embrace Typescript
footer: Open-source MIT Licensed | Copyright © 2019-present<br />Powered by self
---

## Installation

```bash
$ npm install --save @formily/core @formily/react

```

## Quick start

```tsx
/**
 * defaultShowCode: true
 */
import React, { useMemo } from 'react'
import { createForm, setValidateLanguage } from '@formily/core'
import {
  FormProvider,
  FormConsumer,
  Field,
  useField,
  observer,
} from '@formily/react'
import { Input, Form } from 'antd'

// FormItem UI component
const FormItem = observer(({ children }) => {
  const field = useField()
  return (
    <Form.Item
      label={field.title}
      help={field.selfErrors?.length ? field.selfErrors : undefined}
      extra={field.description}
      validateStatus={field.validateStatus}
    >
      {children}
    </Form.Item>
  )
})

/*
 * The above logic has been implemented in @formily/antd, and there is no need to rewrite it in actual use
 */

//Switch the built-in check internationalization copy to English
setValidateLanguage('en')

export default () => {
  const form = useMemo(() => createForm({ validateFirst: true }))

  const createPasswordEqualValidate = (equalName) => (field) => {
    if (
      form.values.confirm_password &&
      field.value &&
      form.values[equalName] !== field.value
    ) {
      field.selfErrors = ['Password does not match Confirm Password.']
    } else {
      field.selfErrors = []
    }
  }

  return (
    <FormProvider form={form}>
      <Form layout="vertical">
        <Field
          name="name"
          title="Name"
          required
          decorator={[FormItem]}
          component={[Input, { placeholder: 'Please Input' }]}
        />
        <Field
          name="password"
          title="Password"
          required
          decorator={[FormItem]}
          component={[Input, { type: 'password', placeholder: 'Please Input' }]}
          reactions={createPasswordEqualValidate('confirm_password')}
        />
        <Field
          name="confirm_password"
          title="Confirm Password"
          required
          decorator={[FormItem]}
          component={[Input, { type: 'password', placeholder: 'Please Input' }]}
          reactions={createPasswordEqualValidate('password')}
        />
        <code>
          <pre>
            <FormConsumer>
              {(form) => JSON.stringify(form.values, null, 2)}
            </FormConsumer>
          </pre>
        </code>
      </Form>
    </FormProvider>
  )
}
```
</file>

<file path="packages/react/docs/index.zh-CN.md">
---
title: Formily - 阿里巴巴统一前端表单解决方案
order: 10
hero:
  title: React Library
  desc: 阿里巴巴统一前端表单解决方案
  actions:
    - text: 主站文档
      link: //formilyjs.org
    - text: 开发指南
      link: /zh-CN/guide
features:
  - icon: https://img.alicdn.com/imgextra/i1/O1CN01bHdrZJ1rEOESvXEi5_!!6000000005599-55-tps-800-800.svg
    title: 超高性能
    desc: 依赖追踪，高效更新，按需渲染
  - icon: https://img.alicdn.com/imgextra/i2/O1CN016i72sH1c5wh1kyy9U_!!6000000003550-55-tps-800-800.svg
    title: 开箱即用
    desc: 组件状态自动绑定，接入成本极低
  - icon: https://img.alicdn.com/imgextra/i3/O1CN01JHzg8U1FZV5Mvt012_!!6000000000501-55-tps-800-800.svg
    title: 协议驱动
    desc: 标准JSON-Schema
  - icon: https://img.alicdn.com/imgextra/i3/O1CN0194OqFF1ui6mMT4g7O_!!6000000006070-55-tps-800-800.svg
    title: 场景复用
    desc: 基于协议驱动，抽象场景组件
  - icon: https://img.alicdn.com/imgextra/i4/O1CN018vDmpl2186xdLu6KI_!!6000000006939-55-tps-800-800.svg
    title: 调试友好
    desc: 天然对接Formily DevTools
  - icon: https://img.alicdn.com/imgextra/i4/O1CN01u6jHgs1ZMwXpjAYnh_!!6000000003181-55-tps-800-800.svg
    title: 智能提示
    desc: 拥抱Typescript
footer: Open-source MIT Licensed | Copyright © 2019-present<br />Powered by self
---

## 安装

```bash
$ npm install --save @formily/core @formily/react

```

## 快速开始

```tsx
/**
 * defaultShowCode: true
 */
import React, { useMemo } from 'react'
import { createForm, setValidateLanguage } from '@formily/core'
import {
  FormProvider,
  FormConsumer,
  Field,
  useField,
  observer,
} from '@formily/react'
import { Input, Form } from 'antd'

// FormItem UI组件
const FormItem = observer(({ children }) => {
  const field = useField()
  return (
    <Form.Item
      label={field.title}
      help={field.selfErrors?.length ? field.selfErrors : undefined}
      extra={field.description}
      validateStatus={field.validateStatus}
    >
      {children}
    </Form.Item>
  )
})

/*
 * 以上逻辑都已经在 @formily/antd 中实现，实际使用无需重复编写
 */

//切换内置校验国际化文案为英文
setValidateLanguage('en')

export default () => {
  const form = useMemo(() => createForm({ validateFirst: true }))

  const createPasswordEqualValidate = (equalName) => (field) => {
    if (
      form.values.confirm_password &&
      field.value &&
      form.values[equalName] !== field.value
    ) {
      field.selfErrors = ['Password does not match Confirm Password.']
    } else {
      field.selfErrors = []
    }
  }

  return (
    <FormProvider form={form}>
      <Form layout="vertical">
        <Field
          name="name"
          title="Name"
          required
          decorator={[FormItem]}
          component={[Input, { placeholder: 'Please Input' }]}
        />
        <Field
          name="password"
          title="Password"
          required
          decorator={[FormItem]}
          component={[Input, { type: 'password', placeholder: 'Please Input' }]}
          reactions={createPasswordEqualValidate('confirm_password')}
        />
        <Field
          name="confirm_password"
          title="Confirm Password"
          required
          decorator={[FormItem]}
          component={[Input, { type: 'password', placeholder: 'Please Input' }]}
          reactions={createPasswordEqualValidate('password')}
        />
        <code>
          <pre>
            <FormConsumer>
              {(form) => JSON.stringify(form.values, null, 2)}
            </FormConsumer>
          </pre>
        </code>
      </Form>
    </FormProvider>
  )
}
```
</file>

<file path="packages/reactive/docs/api/react/observer.md">
# observer

## observer

### Description

In React, turn Function Component into Reaction, and dependencies will be collected every time the view is re-rendered, and dependency updates will be automatically re-rendered

<Alert>
Note: Only Function Component is supported
</Alert>

### Signature

```ts
interface IObserverOptions {
  forwardRef?: boolean //Whether to pass the reference transparently
  scheduler?: (updater: () => void) => void //The scheduler, you can manually control the timing of the update
  displayName?: string //displayName of the packaged component
}

interface observer<T extends React.FC> {
  (component: T, options?: IObserverOptions): T
}
```

### Example

```tsx
/**
 * defaultShowCode: true
 */
import React from 'react'
import { observable } from '@formily/reactive'
import { observer } from '@formily/reactive-react'

const obs = observable({
  value: 'Hello world',
})

export default observer(() => {
  return (
    <div>
      <div>
        <input
          style={{
            height: 28,
            padding: '0 8px',
            border: '2px solid #888',
            borderRadius: 3,
          }}
          value={obs.value}
          onChange={(e) => {
            obs.value = e.target.value
          }}
        />
      </div>
      <div>{obs.value}</div>
    </div>
  )
})
```

## Observer

### Description

Similar to Vue's responsive slot, it receives a Function RenderProps, as long as any responsive data consumed inside the Function, it will be automatically re-rendered as the data changes, and it is easier to achieve local accurate rendering

### Signature

```ts
interface IObserverProps {
  children?: () => React.ReactElement
}

type Observer = React.FC<React.PropsWithChildren<IObserverProps>>
```

### Example

```tsx
/**
 * defaultShowCode: true
 */
import React from 'react'
import { observable } from '@formily/reactive'
import { Observer } from '@formily/reactive-react'

const obs = observable({
  value: 'Hello world',
})

export default () => {
  return (
    <div>
      <div>
        <Observer>
          {() => (
            <input
              style={{
                height: 28,
                padding: '0 8px',
                border: '2px solid #888',
                borderRadius: 3,
              }}
              value={obs.value}
              onChange={(e) => {
                obs.value = e.target.value
              }}
            />
          )}
        </Observer>
      </div>
      <Observer>{() => <div>{obs.value}</div>}</Observer>
    </div>
  )
}
```
</file>

<file path="packages/reactive/docs/api/react/observer.zh-CN.md">
# observer

## observer

### 描述

在 React 中，将 Function Component 变成 Reaction，每次视图重新渲染就会收集依赖，依赖更新会自动重渲染

<Alert>
注意：只支持Function Component
</Alert>

### 签名

```ts
interface IObserverOptions {
  forwardRef?: boolean //是否透传引用
  scheduler?: (updater: () => void) => void //调度器，可以手动控制更新时机
  displayName?: string //包装后的组件的displayName
}

interface observer<T extends React.FC> {
  (component: T, options?: IObserverOptions): T
}
```

### 用例

```tsx
/**
 * defaultShowCode: true
 */
import React from 'react'
import { observable } from '@formily/reactive'
import { observer } from '@formily/reactive-react'

const obs = observable({
  value: 'Hello world',
})

export default observer(() => {
  return (
    <div>
      <div>
        <input
          style={{
            height: 28,
            padding: '0 8px',
            border: '2px solid #888',
            borderRadius: 3,
          }}
          value={obs.value}
          onChange={(e) => {
            obs.value = e.target.value
          }}
        />
      </div>
      <div>{obs.value}</div>
    </div>
  )
})
```

## Observer

### 描述

类似于 Vue 的响应式 Slot，它接收一个 Function RenderProps，只要在 Function 内部消费到的任何响应式数据，都会随数据变化而自动重新渲染，也更容易实现局部精确渲染

### 签名

```ts
interface IObserverProps {
  children?: () => React.ReactElement
}

type Observer = React.FC<React.PropsWithChildren<IObserverProps>>
```

### 用例

```tsx
/**
 * defaultShowCode: true
 */
import React from 'react'
import { observable } from '@formily/reactive'
import { Observer } from '@formily/reactive-react'

const obs = observable({
  value: 'Hello world',
})

export default () => {
  return (
    <div>
      <div>
        <Observer>
          {() => (
            <input
              style={{
                height: 28,
                padding: '0 8px',
                border: '2px solid #888',
                borderRadius: 3,
              }}
              value={obs.value}
              onChange={(e) => {
                obs.value = e.target.value
              }}
            />
          )}
        </Observer>
      </div>
      <Observer>{() => <div>{obs.value}</div>}</Observer>
    </div>
  )
}
```
</file>

<file path="packages/reactive/docs/api/vue/observer.md">
# observer

## describe

In Vue, the component rendering method is changed to Reaction, and dependencies are collected every time the view is re-rendered, and dependencies are updated automatically to re-render.

### Signature

```ts
interface IObserverOptions {
  scheduler?: (updater: () => void) => void //The scheduler, you can manually control the timing of the update
  name?: string //name of the packaged component
}

interface observer<T extends VueComponent> {
  (component: T, options?: IObserverOptions): T
}
```

## Example

```html
<template>
  <div>
    <div>
      <input
        :style="{
           height: 28,
           padding: '0 8px',
           border: '2px solid #888',
           borderRadius: 3,
         }"
        :value="obs.value"
        @input="(e) => {
           obs.value = e.target.value
         }"
      />
    </div>
    <div>{{obs.value}}</div>
  </div>
</template>

<script>
  import { observable } from '@formily/reactive'
  import { observer } from '@formily/reactive-vue'

  export default observer({
    data() {
      // can coexist with vue's response system
      const obs = observable({
        value: 'Hello world',
      })
      return {
        obs,
      }
    },
  })
</script>
```
</file>

<file path="packages/reactive/docs/api/vue/observer.zh-CN.md">
# observer

## 描述

在 Vue 中，将组件渲染方法变成 Reaction，每次视图重新渲染就会收集依赖，依赖更新会自动重渲染。

### 签名

```ts
interface IObserverOptions {
  scheduler?: (updater: () => void) => void //调度器，可以手动控制更新时机
  name?: string //包装后的组件的name
}

interface observer<T extends VueComponent> {
  (component: T, options?: IObserverOptions): T
}
```

## 用例

```html
<template>
  <div>
    <div>
      <input
        :style="{
          height: 28,
          padding: '0 8px',
          border: '2px solid #888',
          borderRadius: 3,
        }"
        :value="obs.value"
        @input="(e) => {
          obs.value = e.target.value
        }"
      />
    </div>
    <div>{{obs.value}}</div>
  </div>
</template>

<script>
  import { observable } from '@formily/reactive'
  import { observer } from '@formily/reactive-vue'

  export default observer({
    data() {
      // 能与 vue 的响应系统共存
      const obs = observable({
        value: 'Hello world',
      })
      return {
        obs,
      }
    },
  })
</script>
```
</file>

<file path="packages/reactive/docs/api/action.md">
# action

## Description

Define a batch action. The only difference with batch is that dependencies cannot be collected inside an action

## Signature

```ts
interface action {
  <T>(callback?: () => T): T //In-situ action
  scope<T>(callback?: () => T): T //In-situ local action
  bound<T extends (...args: any[]) => any>(callback: T, context?: any): T //High-level binding
}
```

## Example

```ts
import { observable, action } from '@formily/reactive'

const obs = observable({})

const method = action.bound(() => {
  obs.aa = 123
  obs.bb = 321
})

method()
```
</file>

<file path="packages/reactive/docs/api/action.zh-CN.md">
# action

## 描述

定义一个批量动作。与 batch 的唯一差别就是 action 内部是无法收集依赖的

## 签名

```ts
interface action {
  <T>(callback?: () => T): T //原地action
  scope<T>(callback?: () => T): T //原地局部action
  bound<T extends (...args: any[]) => any>(callback: T, context?: any): T //高阶绑定
}
```

## 用例

```ts
import { observable, action } from '@formily/reactive'

const obs = observable({})

const method = action.bound(() => {
  obs.aa = 123
  obs.bb = 321
})

method()
```
</file>

<file path="packages/reactive/docs/api/autorun.md">
# autorun

## Description

Receive a tracker function, if there is observable data in the function, the tracker function will be executed repeatedly when the data changes

## Signature

```ts
interface autorun {
  (tracker: () => void, name?: string): void
}
```

## Example

```ts
import { observable, autorun } from '@formily/reactive'

const obs = observable({})

const dispose = autorun(() => {
  console.log(obs.aa)
})

obs.aa = 123

dispose()
```

## autorun.memo

### Description

Used in autorun to create persistent reference data, only re-execute memo internal functions due to dependency changes

Note: Please do not use it in If/For statements, because it depends on the execution order to bind the current autorun

### Signature

```ts
interface memo<T> {
  (callback: () => T, dependencies: any[] = []): T
}
```

Note: The default dependency is `[]`, that is, if the dependency is not passed, it means that the second time will never be executed

### Example

```ts
import { observable, autorun } from '@formily/reactive'

const obs1 = observable({
  aa: 0,
})

const dispose = autorun(() => {
  const obs2 = autorun.memo(() =>
    observable({
      bb: 0,
    })
  )
  console.log(obs1.aa, obs2.bb++)
})

obs1.aa++
obs1.aa++
obs1.aa++
//Execute four times, the output result is
/**
 * 0 0
 * 1 1
 * twenty two
 * 3 3
 */

dispose()
```

## autorun.effect

### Description

In autorun, it is used to respond to the next micro task timing of autorun's first execution and the dispose of responding to autorun

Note: Please do not use it in If/For statements, because it depends on the execution order to bind the current autorun

### Signature

```ts
interface effect {
  (callback: () => void | (() => void), dependencies: any[] = [{}]): void
}
```

Note: The default dependency is `[{}]`, that is, if the dependency is not passed, the representative will continue to execute, because the internal dirty check is a shallow comparison

### Example

```ts
import { observable, autorun } from '@formily/reactive'

const obs1 = observable({
  aa: 0,
})
const dispose = autorun(() => {
  const obs2 = autorun.memo(() =>
    observable({
      bb: 0,
    })
  )
  console.log(obs1.aa, obs2.bb++)
  autorun.effect(() => {
    obs2.bb++
  }, [])
})
obs1.aa++
obs1.aa++
obs1.aa++
//Execute five times, the output result is
/**
 * 0 0
 * 1 1
 * twenty two
 * 3 3
 * 3 5
 */

dispose()
```
</file>

<file path="packages/reactive/docs/api/autorun.zh-CN.md">
# autorun

## 描述

接收一个 tracker 函数，如果函数内部有消费 observable 数据，数据发生变化时，tracker 函数会重复执行

## 签名

```ts
interface autorun {
  (tracker: () => void, name?: string): void
}
```

## 用例

```ts
import { observable, autorun } from '@formily/reactive'

const obs = observable({})

const dispose = autorun(() => {
  console.log(obs.aa)
})

obs.aa = 123

dispose()
```

## autorun.memo

### 描述

在 autorun 中用于创建持久引用数据，仅仅只会受依赖变化而重新执行 memo 内部函数

注意：请不要在 If/For 这类语句中使用，因为它内部是依赖执行顺序来绑定当前 autorun 的

### 签名

```ts
interface memo<T> {
  (callback: () => T, dependencies: any[] = []): T
}
```

注意：依赖默认为`[]`，也就是如果不传依赖，代表永远不会执行第二次

### 用例

```ts
import { observable, autorun } from '@formily/reactive'

const obs1 = observable({
  aa: 0,
})

const dispose = autorun(() => {
  const obs2 = autorun.memo(() =>
    observable({
      bb: 0,
    })
  )
  console.log(obs1.aa, obs2.bb++)
})

obs1.aa++
obs1.aa++
obs1.aa++
//执行四次，输出结果为
/**
 * 0 0
 * 1 1
 * 2 2
 * 3 3
 */

dispose()
```

## autorun.effect

### 描述

在 autorun 中用于响应 autorun 第一次执行的下一个微任务时机与响应 autorun 的 dispose

注意：请不要在 If/For 这类语句中使用，因为它内部是依赖执行顺序来绑定当前 autorun 的

### 签名

```ts
interface effect {
  (callback: () => void | (() => void), dependencies: any[] = [{}]): void
}
```

注意：依赖默认为`[{}]`，也就是如果不传依赖，代表会持续执行，因为内部脏检查是浅比较

### 用例

```ts
import { observable, autorun } from '@formily/reactive'

const obs1 = observable({
  aa: 0,
})
const dispose = autorun(() => {
  const obs2 = autorun.memo(() =>
    observable({
      bb: 0,
    })
  )
  console.log(obs1.aa, obs2.bb++)
  autorun.effect(() => {
    obs2.bb++
  }, [])
})
obs1.aa++
obs1.aa++
obs1.aa++
//执行五次，输出结果为
/**
 * 0 0
 * 1 1
 * 2 2
 * 3 3
 * 3 5
 */

dispose()
```
</file>

<file path="packages/reactive/docs/api/batch.md">
# batch

## Description

Define batch operations, internal dependencies can be collected

## Signature

```ts
interface batch {
  <T>(callback?: () => T): T //In-place batch
  scope<T>(callback?: () => T): T //In-situ local batch
  bound<T extends (...args: any[]) => any>(callback: T, context?: any): T //High-level binding
  endpoint(callback?: () => void): void //Register batch endpoint callback
}
```

## Example

```ts
import { observable, autorun, batch } from '@formily/reactive'

const obs = observable({})

autorun(() => {
  console.log(obs.aa, obs.bb, obs.cc, obs.dd)
})

batch(() => {
  batch.scope(() => {
    obs.aa = 123
  })
  batch.scope(() => {
    obs.cc = 'ccccc'
  })
  obs.bb = 321
  obs.dd = 'dddd'
})
```
</file>

<file path="packages/reactive/docs/api/batch.zh-CN.md">
# batch

## 描述

定义批量操作，内部可以收集依赖

## 签名

```ts
interface batch {
  <T>(callback?: () => T): T //原地batch
  scope<T>(callback?: () => T): T //原地局部batch
  bound<T extends (...args: any[]) => any>(callback: T, context?: any): T //高阶绑定
  endpoint(callback?: () => void): void //注册批量执行结束回调
}
```

## 用例

```ts
import { observable, autorun, batch } from '@formily/reactive'

const obs = observable({})

autorun(() => {
  console.log(obs.aa, obs.bb, obs.cc, obs.dd)
})

batch(() => {
  batch.scope(() => {
    obs.aa = 123
  })
  batch.scope(() => {
    obs.cc = 'ccccc'
  })
  obs.bb = 321
  obs.dd = 'dddd'
})
```
</file>

<file path="packages/reactive/docs/api/define.md">
# define

## Description

Manually define the domain model, you can specify the responsive behavior of specific attributes, or you can specify a method as batch mode

## Signature

```ts
interface define<Target extends object> {
  (
    target: Target,
    annotations?: {
      [key: string]: (...args: any[]) => any
    }
  ): Target
}
```

## Annotations

All Annotations currently supported are:

- observable/observable.deep defines deep hijacking responsive properties
- observable.box defines get/set container
- observable.computed defines calculated properties
- observable.ref defines reference hijacking responsive attributes
- observable.shallow defines shallow hijacking responsive properties
- action/batch defines the batch processing method

## Example

```ts
import { define, observable, action, autorun } from '@formily/reactive'

class DomainModel {
  deep = { aa: 1 }
  shallow = {}
  box = 0
  ref = ''

  constructor() {
    define(this, {
      deep: observable,
      shallow: observable.shallow,
      box: observable.box,
      ref: observable.ref,
      computed: observable.computed,
      action,
    })
  }

  get computed() {
    return this.deep.aa + this.box.get()
  }
  action(aa, box) {
    this.deep.aa = aa
    this.box.set(box)
  }
}

const model = new DomainModel()

autorun(() => {
  console.log(model.computed)
})

model.action(1, 2)
model.action(1, 2) //Repeat calls will not respond repeatedly
model.action(3, 4)
```
</file>

<file path="packages/reactive/docs/api/define.zh-CN.md">
# define

## 描述

手动定义领域模型，可以指定具体属性的响应式行为，也可以指定某个方法为 batch 模式

## 签名

```ts
interface define<Target extends object> {
  (
    target: Target,
    annotations?: {
      [key: string]: (...args: any[]) => any
    }
  ): Target
}
```

## Annotations

目前支持的所有 Annotation 有：

- observable/observable.deep 定义深度劫持响应式属性
- observable.box 定义 get/set 容器
- observable.computed 定义计算属性
- observable.ref 定义引用劫持响应式属性
- observable.shallow 定义浅劫持响应式属性
- action/batch 定义批处理方法

## 用例

```ts
import { define, observable, action, autorun } from '@formily/reactive'

class DomainModel {
  deep = { aa: 1 }
  shallow = {}
  box = 0
  ref = ''

  constructor() {
    define(this, {
      deep: observable,
      shallow: observable.shallow,
      box: observable.box,
      ref: observable.ref,
      computed: observable.computed,
      action,
    })
  }

  get computed() {
    return this.deep.aa + this.box.get()
  }
  action(aa, box) {
    this.deep.aa = aa
    this.box.set(box)
  }
}

const model = new DomainModel()

autorun(() => {
  console.log(model.computed)
})

model.action(1, 2)
model.action(1, 2) //重复调用不会重复响应
model.action(3, 4)
```
</file>

<file path="packages/reactive/docs/api/hasCollected.md">
# hasCollected

## describe

Used to detect whether a certain piece of execution logic has dependent collection

## Signature

```ts
interface hasCollected {
  (callback?: () => void): boolean
}
```

## Example

```ts
import { observable, autorun } from '@formily/reactive'

const obs = observable({
  aa: 11,
})

autorun(() => {
  console.log(
    hasCollected(() => {
      obs.aa
    })
  ) //return true
  console.log(
    hasCollected(() => {
      11 + 22
    })
  ) //return false
})

obs.aa = 22
```
</file>

<file path="packages/reactive/docs/api/hasCollected.zh-CN.md">
# hasCollected

## 描述

用于检测某段执行逻辑是否存在依赖收集

## 签名

```ts
interface hasCollected {
  (callback?: () => void): boolean
}
```

## 用例

```ts
import { observable, autorun } from '@formily/reactive'

const obs = observable({
  aa: 11,
})

autorun(() => {
  console.log(
    hasCollected(() => {
      obs.aa
    })
  ) //return true
  console.log(
    hasCollected(() => {
      11 + 22
    })
  ) //return false
})

obs.aa = 22
```
</file>

<file path="packages/reactive/docs/api/markObservable.md">
# markObservable

## Description

Mark any object or class prototype as being hijacked by observable. React Node and objects with toJSON/toJS methods will be automatically bypassed in @formily/reactive. In special scenarios, we may hope that the object should be hijacked, so you can use it markObservable mark

## Signature

```ts
interface markObservable<T> {
  (target: T): T
}
```

## Example

```ts
import { observable, autorun, markObservable } from '@formily/reactive'

class A {
  property = ''

  toJSON() {}
}

const a = observable(new A())

autorun(() => {
  console.log(a.property) //will not be triggered when the property changes, because there is a toJSON method in the A instance
})

a.property = 123

//--------------------------------------------

const b = observable(markObservable(new A())) //instance-level mark, only valid for the current instance

autorun(() => {
  console.log(b.property) //Can be triggered when the property changes, because it has been marked as observable
})

b.property = 123

//--------------------------------------------

markObservable(A) //Class-level mark, then all instances will take effect

const c = observable(new A())

autorun(() => {
  console.log(c.property) //Can be triggered when the property changes, because it has been marked as observable
})

c.property = 123
```
</file>

<file path="packages/reactive/docs/api/markObservable.zh-CN.md">
# markObservable

## 描述

标记任意一个对象或者类原型为可被 observable 劫持，在@formily/reactive 中会自动绕过 React Node 与带有 toJSON/toJS 方法的对象，特殊场景，我们可能希望该对象应该被劫持，所以可以使用 markObservable 标记

## 签名

```ts
interface markObservable<T> {
  (target: T): T
}
```

## 用例

```ts
import { observable, autorun, markObservable } from '@formily/reactive'

class A {
  property = ''

  toJSON() {}
}

const a = observable(new A())

autorun(() => {
  console.log(a.property) //property变化时不会被触发，因为A实例中有toJSON方法
})

a.property = 123

//--------------------------------------------

const b = observable(markObservable(new A())) //实例级标记，只对当前实例生效

autorun(() => {
  console.log(b.property) //property变化时可以被触发，因为已被标记observable
})

b.property = 123

//--------------------------------------------

markObservable(A) //类级标记，那么所有实例都会生效

const c = observable(new A())

autorun(() => {
  console.log(c.property) //property变化时可以被触发，因为已被标记observable
})

c.property = 123
```
</file>

<file path="packages/reactive/docs/api/markRaw.md">
# markRaw

## Description

Mark any object or class prototype as never being hijacked by observable, priority is higher than markObservable

Note: If you mark an object that is already observable with markRaw, then toJS will not convert it into a normal object

## Signature

```ts
interface markRaw<T> {
  (target: T): T
}
```

## Example

```ts
import { observable, autorun, markRaw } from '@formily/reactive'

class A {
  property = ''
}

const a = observable(new A())

autorun(() => {
  console.log(a.property) //It will be triggered when the property changes, because the A instance is a normal object
})

a.property = 123

//--------------------------------------------

const b = observable(markRaw(new A())) //instance-level mark, only valid for the current instance

autorun(() => {
  console.log(b.property) //will not be triggered when the property changes, because it has been marked raw
})

b.property = 123

//--------------------------------------------

markRaw(A) //Class-level mark, then all instances will take effect

const c = observable(new A())

autorun(() => {
  console.log(c.property) //will not be triggered when the property changes, because it has been marked raw
})

c.property = 123
```
</file>

<file path="packages/reactive/docs/api/markRaw.zh-CN.md">
# markRaw

## 描述

标记任意一个对象或者类原型为永远不可被 observable 劫持，优先级比 markObservable 高

注意：如果对一个已经是 observable 的对象标记 markRaw，那么 toJS，是不会将它转换成普通对象的

## 签名

```ts
interface markRaw<T> {
  (target: T): T
}
```

## 用例

```ts
import { observable, autorun, markRaw } from '@formily/reactive'

class A {
  property = ''
}

const a = observable(new A())

autorun(() => {
  console.log(a.property) //property变化时会被触发，因为A实例是普通对象
})

a.property = 123

//--------------------------------------------

const b = observable(markRaw(new A())) //实例级标记，只对当前实例生效

autorun(() => {
  console.log(b.property) //property变化时不会被触发，因为已被标记raw
})

b.property = 123

//--------------------------------------------

markRaw(A) //类级标记，那么所有实例都会生效

const c = observable(new A())

autorun(() => {
  console.log(c.property) //property变化时不会被触发，因为已被标记raw
})

c.property = 123
```
</file>

<file path="packages/reactive/docs/api/model.md">
# model

## Description

Quickly define the domain model, and automatically declare the model attributes:

- Automatic declaration of getter/setter properties computed
- Function automatically declare action
- Common attributes are automatically declared observable

## Signature

```ts
interface model<Target extends object> {
  (target: Target): Target
}
```

## Example

```ts
import { model, autorun } from '@formily/reactive'

const obs = model({
  aa: 1,
  bb: 2,
  get cc() {
    return this.aa + this.bb
  },
  update(aa, bb) {
    this.aa=aa
    this.bb=bb
  },
})

autorun(() => {
  console.log(obs.cc)
})

obs.aa = 3

obs.update(4, 6)
```
</file>

<file path="packages/reactive/docs/api/model.zh-CN.md">
# model

## 描述

快速定义领域模型，会对模型属性做自动声明：

- getter/setter 属性自动声明 computed
- 函数自动声明 action
- 普通属性自动声明 observable

## 签名

```ts
interface model<Target extends object> {
  (target: Target): Target
}
```

## 用例

```ts
import { model, autorun } from '@formily/reactive'

const obs = model({
  aa: 1,
  bb: 2,
  get cc() {
    return this.aa + this.bb
  },
  update(aa, bb) {
    this.aa=aa
    this.bb=bb
  },
})

autorun(() => {
  console.log(obs.cc)
})

obs.aa = 3

obs.update(4, 6)
```
</file>

<file path="packages/reactive/docs/api/observable.md">
# observable

> Mainly used to create observable objects with different responsive behaviors, and can be used as an annotation to define to mark responsive attributes

## observable/observable.deep

### Description

Create deep hijacking responsive objects

### Signature

```ts
interface observable<T extends object> {
  (target: T): T
}

interface deep<T extends object> {
  (target: T): T
}
```

### Example

```ts
import { observable, autorun } from '@formily/reactive'

const obs = observable({
  aa: {
    bb: 123,
  },
})

autorun(() => {
  console.log(obs.aa.bb)
})

obs.aa.bb = 321
```

## observable.shallow

### Description

Create shallow hijacking responsive objects, that is, only respond to the first-level attribute operations of the target object

### Signature

```ts
interface shallow<T extends object> {
  (target: T): T
}
```

### Example

```ts
import { observable, autorun } from '@formily/reactive'

const obs = observable.shallow({
  aa: {
    bb: 111,
  },
})

autorun(() => {
  console.log(obs.aa.bb)
})

obs.aa.bb = 222 // will not respond
obs.aa = { bb: 333 } // can respond
```

## observable.computed

### Description

Create a calculation buffer

### Signature

```ts
interface computed {
  <T extends () => any>(target: T): { value: ReturnType<T> }
  <T extends { get?: () => any; set?: (value: any) => void }>(target: T): {
    value: ReturnType<T['get']>
  }
}
```

### Example

```ts
import { observable, autorun } from '@formily/reactive'

const obs = observable({
  aa: 11,
  bb: 22,
})

const computed = observable.computed(() => obs.aa + obs.bb)

autorun(() => {
  console.log(computed.value)
})

obs.aa = 33
```

## observable.ref

### Description

Create reference hijacking responsive objects

### Signature

```ts
interface ref<T extends object> {
  (target: T): { value: T }
}
```

### Example

```ts
import { observable, autorun } from '@formily/reactive'

const ref = observable.ref(1)

autorun(() => {
  console.log(ref.value)
})

ref.value = 2
```

## observable.box

### Description

Similar to ref, except that the data is read and written through the get/set method

### Signature

```ts
interface box<T extends object> {
  (target: T): { get: () => T; set: (value: T) => void }
}
```

### Example

```ts
import { observable, autorun } from '@formily/reactive'

const box = observable.box(1)

autorun(() => {
  console.log(box.get())
})

box.set(2)
```
</file>

<file path="packages/reactive/docs/api/observable.zh-CN.md">
# observable

> 主要用于创建不同响应式行为的 observable 对象，同时可以作为 annotation 给 define 用于标记响应式属性

## observable/observable.deep

### 描述

创建深度劫持响应式对象

### 签名

```ts
interface observable<T extends object> {
  (target: T): T
}

interface deep<T extends object> {
  (target: T): T
}
```

### 用例

```ts
import { observable, autorun } from '@formily/reactive'

const obs = observable({
  aa: {
    bb: 123,
  },
})

autorun(() => {
  console.log(obs.aa.bb)
})

obs.aa.bb = 321
```

## observable.shallow

### 描述

创建浅劫持响应式对象，也就是只会对目标对象的第一级属性操作响应

### 签名

```ts
interface shallow<T extends object> {
  (target: T): T
}
```

### 用例

```ts
import { observable, autorun } from '@formily/reactive'

const obs = observable.shallow({
  aa: {
    bb: 111,
  },
})

autorun(() => {
  console.log(obs.aa.bb)
})

obs.aa.bb = 222 // 不会响应
obs.aa = { bb: 333 } // 可以响应
```

## observable.computed

### 描述

创建一个计算缓存器

### 签名

```ts
interface computed {
  <T extends () => any>(target: T): { value: ReturnType<T> }
  <T extends { get?: () => any; set?: (value: any) => void }>(target: T): {
    value: ReturnType<T['get']>
  }
}
```

### 用例

```ts
import { observable, autorun } from '@formily/reactive'

const obs = observable({
  aa: 11,
  bb: 22,
})

const computed = observable.computed(() => obs.aa + obs.bb)

autorun(() => {
  console.log(computed.value)
})

obs.aa = 33
```

## observable.ref

### 描述

创建引用劫持响应式对象

### 签名

```ts
interface ref<T extends object> {
  (target: T): { value: T }
}
```

### 用例

```ts
import { observable, autorun } from '@formily/reactive'

const ref = observable.ref(1)

autorun(() => {
  console.log(ref.value)
})

ref.value = 2
```

## observable.box

### 描述

与 ref 相似，只是读写数据是通过 get/set 方法

### 签名

```ts
interface box<T extends object> {
  (target: T): { get: () => T; set: (value: T) => void }
}
```

### 用例

```ts
import { observable, autorun } from '@formily/reactive'

const box = observable.box(1)

autorun(() => {
  console.log(box.get())
})

box.set(2)
```
</file>

<file path="packages/reactive/docs/api/observe.md">
# observe

## Description

Very different from autorun/reaction/Tracker, using observe will monitor all operations of observable objects, support deep monitoring and shallow monitoring

<Alert>
Note: The read operation will not be monitored
</Alert>

## Signature

```ts
type PropertyKey = string | number | symbol

type ObservablePath = Array<string | number>

type OperationType =
  | 'add'
  | 'delete'
  | 'clear'
  | 'set'
  | 'get'
  | 'iterate'
  | 'has'

interface IChange {
  key?: PropertyKey
  path?: ObservablePath
  object?: object
  value?: any
  oldValue?: any
  type?: OperationType
}

interface IDispose {
  (): void
}

interface observe {
  (
    target: object,
    observer?: (change: IChange) => void,
    deep?: boolean //default is true
  ): IDispose //Release the monitor
}
```

## Example

```ts
import { observable, observe } from '@formily/reactive'

const obs = observable({
  aa: 11,
})

const dispose = observe(obs, (change) => {
  console.log(change)
})

obs.aa = 22

dispose()
```
</file>

<file path="packages/reactive/docs/api/observe.zh-CN.md">
# observe

## 描述

与 autorun/reaction/Tracker 非常不一样，使用 observe 会监听 observable 对象的所有操作，支持深度监听也支持浅监听

<Alert>
注意：读取操作是不会被监听到的
</Alert>

## 签名

```ts
type PropertyKey = string | number | symbol

type ObservablePath = Array<string | number>

type OperationType =
  | 'add'
  | 'delete'
  | 'clear'
  | 'set'
  | 'get'
  | 'iterate'
  | 'has'

interface IChange {
  key?: PropertyKey
  path?: ObservablePath
  object?: object
  value?: any
  oldValue?: any
  type?: OperationType
}

interface IDispose {
  (): void
}

interface observe {
  (
    target: object,
    observer?: (change: IChange) => void,
    deep?: boolean //默认为true
  ): IDispose //释放监听
}
```

## 用例

```ts
import { observable, observe } from '@formily/reactive'

const obs = observable({
  aa: 11,
})

const dispose = observe(obs, (change) => {
  console.log(change)
})

obs.aa = 22

dispose()
```
</file>

<file path="packages/reactive/docs/api/raw.md">
# raw

## Description

Obtain the source data from the observable object. Generally, this API is not recommended

<Alert>
Note: Only the source data of the current object can be obtained, excluding deep object properties
</Alert>

## Signature

```ts
interface raw<T extends object> {
  (target: T): T
}
```

## Example

```ts
import { raw, observable } from '@formily/reactive'

const obs = observable({})

obs.aa = { bb: 123 }

console.log(raw(obs))
console.log(raw(obs.aa))
```
</file>

<file path="packages/reactive/docs/api/raw.zh-CN.md">
# raw

## 描述

从 observable 对象中获取源数据，通常情况下并不推荐使用该 API

<Alert>
注意：只能获取当前对象的源数据，不包括深层对象属性
</Alert>

## 签名

```ts
interface raw<T extends object> {
  (target: T): T
}
```

## 用例

```ts
import { raw, observable } from '@formily/reactive'

const obs = observable({})

obs.aa = { bb: 123 }

console.log(raw(obs))
console.log(raw(obs.aa))
```
</file>

<file path="packages/reactive/docs/api/reaction.md">
# reaction

## Description

Receive a tracker function and a callback response function. If there is observable data in the tracker, the tracker function will be executed repeatedly when the data changes, but the callback execution must be executed when the tracker function return value changes.

## Signature

```ts
interface IReactionOptions<T> {
  name?: string
  equals?: (oldValue: T, newValue: T) => boolean //Dirty check
  fireImmediately?: boolean //Is it triggered by default for the first time, bypassing the dirty check
}

interface reaction<T> {
  (
    tracker: () => T,
    subscriber?: (newValue: T, oldValue: T) => void,
    options?: IReactionOptions<T>
  ): void
}
```

## Example

```ts
import { observable, reaction, batch } from '@formily/reactive'

const obs = observable({
  aa: 1,
  bb: 2,
})

const dispose = reaction(() => {
  return obs.aa + obs.bb
}, console.log)

batch(() => {
  //Won't trigger because the value of obs.aa + obs.bb has not changed
  obs.aa = 2
  obs.bb = 1
})

obs.aa = 4

dispose()
```
</file>

<file path="packages/reactive/docs/api/reaction.zh-CN.md">
# reaction

## 描述

接收一个 tracker 函数，与 callback 响应函数，如果 tracker 内部有消费 observable 数据，数据发生变化时，tracker 函数会重复执行，但是 callback 执行必须要求 tracker 函数返回值发生变化时才执行

## 签名

```ts
interface IReactionOptions<T> {
  name?: string
  equals?: (oldValue: T, newValue: T) => boolean //脏检查
  fireImmediately?: boolean //是否第一次默认触发，绕过脏检查
}

interface reaction<T> {
  (
    tracker: () => T,
    subscriber?: (newValue: T, oldValue: T) => void,
    options?: IReactionOptions<T>
  ): void
}
```

## 用例

```ts
import { observable, reaction, batch } from '@formily/reactive'

const obs = observable({
  aa: 1,
  bb: 2,
})

const dispose = reaction(() => {
  return obs.aa + obs.bb
}, console.log)

batch(() => {
  //不会触发，因为obs.aa + obs.bb值没变
  obs.aa = 2
  obs.bb = 1
})

obs.aa = 4

dispose()
```
</file>

<file path="packages/reactive/docs/api/toJS.md">
# toJS

## Description

Deep recursion converts observable objects into ordinary JS objects

Note: If you mark an object that is already observable with markRaw, then toJS will not convert it into a normal object

## Signature

```ts
interface toJS<T> {
  (target: T): T
}
```

## Example

```ts
import { observable, autorun, toJS } from '@formily/reactive'

const obs = observable({
  aa: {
    bb: {
      cc: 123,
    },
  },
})

const js = toJS(obs)

autorun(() => {
  console.log(js.aa.bb.cc) // will not trigger when changes
})

js.aa.bb.cc = 321
```
</file>

<file path="packages/reactive/docs/api/toJS.zh-CN.md">
# toJS

## 描述

深度递归将 observable 对象转换成普通 JS 对象

注意：如果对一个已经是 observable 的对象标记 markRaw，那么 toJS，是不会将它转换成普通对象的

## 签名

```ts
interface toJS<T> {
  (target: T): T
}
```

## 用例

```ts
import { observable, autorun, toJS } from '@formily/reactive'

const obs = observable({
  aa: {
    bb: {
      cc: 123,
    },
  },
})

const js = toJS(obs)

autorun(() => {
  console.log(js.aa.bb.cc) //变化时不会触发
})

js.aa.bb.cc = 321
```
</file>

<file path="packages/reactive/docs/api/tracker.md">
# tracker

## Description

Mainly used to access the manual tracking dependency tool of React/Vue. The tracker function will not be executed repeatedly when the dependency changes. It requires the user to manually execute it repeatedly, which will only trigger the scheduler

## Signature

```ts
class Tracker {
  constructor(scheduler?: (reaction: this['track']) => void, name?: string)
  track: <T>(tracker?: () => T) => T
  dispose: () => void
}
```

## Example

```ts
import { observable, Tracker } from '@formily/reactive'

const obs = observable({
  aa: 11,
})

const view = () => {
  console.log(obs.aa)
}

const tracker = new Tracker(() => {
  tracker.track(view)
})

tracker.track(view)

obs.aa = 22

tracker.dispose()
```
</file>

<file path="packages/reactive/docs/api/tracker.zh-CN.md">
# tracker

## 描述

主要用于接入 React/Vue 的手动追踪依赖工具，在依赖发生变化时不会重复执行 tracker 函数，需要用户手动重复执行，只会触发 scheduler

## 签名

```ts
class Tracker {
  constructor(scheduler?: (reaction: this['track']) => void, name?: string)
  track: <T>(tracker?: () => T) => T
  dispose: () => void
}
```

## 用例

```ts
import { observable, Tracker } from '@formily/reactive'

const obs = observable({
  aa: 11,
})

const view = () => {
  console.log(obs.aa)
}

const tracker = new Tracker(() => {
  tracker.track(view)
})

tracker.track(view)

obs.aa = 22

tracker.dispose()
```
</file>

<file path="packages/reactive/docs/api/typeChecker.md">
# Type Checker

## isObservable

#### Description

Determine whether an object is observable

#### Signature

```ts
interface isObservable {
  (target: any): boolean
}
```

## isAnnotation

#### Description

Determine whether an object is Annotation

#### Signature

```ts
interface isAnnotation {
  (target: any): boolean
}
```

## isSupportObservable

#### Description

Determine whether an object can be observable

#### Signature

```ts
interface isSupportObservable {
  (target: any): boolean
}
```
</file>

<file path="packages/reactive/docs/api/typeChecker.zh-CN.md">
# Type Checker

## isObservable

#### 描述

判断某个对象是否是 observable 对象

#### 签名

```ts
interface isObservable {
  (target: any): boolean
}
```

## isAnnotation

#### 描述

判断某个对象是否是 Annotation

#### 签名

```ts
interface isAnnotation {
  (target: any): boolean
}
```

## isSupportObservable

#### 描述

判断某个对象是否可以被 observable

#### 签名

```ts
interface isSupportObservable {
  (target: any): boolean
}
```
</file>

<file path="packages/reactive/docs/api/untracked.md">
# untracked

## Description

Usage is similar to batch, and will never be collected by dependencies within a given untracker function

## Signature

```ts
interface untracked<T extends () => any> {
  (untracker?: T): ReturnType<T>
}
```

## Example

```ts
import { observable, autorun, untracked } from '@formily/reactive'

const obs = observable({
  aa: 11,
})

autorun(() => {
  console.log(untracked(() => obs.aa)) // will not trigger when changes
})

obs.aa = 22
```
</file>

<file path="packages/reactive/docs/api/untracked.zh-CN.md">
# untracked

## 描述

用法与 batch 相似，在给定的 untracker 函数内部永远不会被依赖收集

## 签名

```ts
interface untracked<T extends () => any> {
  (untracker?: T): ReturnType<T>
}
```

## 用例

```ts
import { observable, autorun, untracked } from '@formily/reactive'

const obs = observable({
  aa: 11,
})

autorun(() => {
  console.log(untracked(() => obs.aa)) //变化时不会触发
})

obs.aa = 22
```
</file>

<file path="packages/reactive/docs/guide/best-practice.md">
# Best Practices

When using @formily/reactive, we only need to pay attention to the following points:

- Minimize the use of observable/observable.deep for deep packaging, instead of using observable.ref/observable.shallow as a last resort, the performance will be better
- Multi-use computed properties in the domain model, which can intelligently cache the calculation results
- Although batch operation is not necessary, use batch mode as much as possible to reduce the number of executions of Reaction
- When using autorun/reaction, you must remember to call the dispose release function (that is, the second-order function returned by the calling function), otherwise there will be memory leaks
</file>

<file path="packages/reactive/docs/guide/best-practice.zh-CN.md">
# 最佳实践

在使用@formily/reactive 的时候，我们只需要注意以下几点即可：

- 尽量少用 observable/observable.deep 进行深度包装，不是非不得已就多用 observable.ref/observable.shallow，这样性能会更好
- 领域模型中多用 computed 计算属性，它可以智能缓存计算结果
- 虽然批量操作不是必须的，但是尽量多用 batch 模式，这样可以减少 Reaction 执行次数
- 使用 autorun/reaction 的时候，一定记得调用 dispose 释放函数(也就是调用函数所返回的二阶函数)，否则会内存泄漏
</file>

<file path="packages/reactive/docs/guide/concept.md">
# Core idea

## Observable

Observable is the most important part of the reactive programming model. Its core concepts are:

An observable object, literally means a subscribable object, **we create a subscribable object, each time we manipulate the attribute data of the object, we will automatically notify the subscriber**, @formily/reactive creates an observable object mainly It is created by ES Proxy, which can perfectly hijack data operations

We mainly use the following APIs to create observable objects in @formily/reactive:

- The observable function creates a deep observable object
  - The observable.deep function creates a deep hijacking observable object
  - The observable.shallow function creates shallow hijacked observable objects
  - The observable.computed function creates a cache calculator
  - The observable.box function creates observable objects with get/set methods
  - The observable.ref function creates a reference-level observable object
- The define function defines the observable domain model, which can be combined with the observable function and its static attribute (such as observable.computed) function to complete the definition of the domain model
- The model function defines an automatic observable domain model. It will wrap the getter setter attribute as a computed attribute, wrap the function as an action, and wrap other data attributes with observable (note that this is a deep hijacking)

## Reaction

In the reactive programming model, reaction is equivalent to the subscriber of the subscribeable object. It receives a tracker function. When this function is executed, if there is a **read operation* on an attribute in the observable object inside the function. * (Dependency collection), then the current reaction will be bound to the attribute (dependency tracking), until the attribute has a **write operation\*\* in other places, it will trigger the tracker function to repeat execution, using a picture Means:

![](https://img.alicdn.com/imgextra/i4/O1CN01DQMGUL22mFICDsKfY_!!6000000007162-2-tps-1234-614.png)

You can see that from subscribing to dispatching subscriptions, it is actually a closed loop state machine. Each time the tracker function is executed, the dependencies are re-collected, and the tracker execution is re-triggered when the dependencies change. So, if we don't want to subscribe to the reaction anymore, we must manually dispose, otherwise there will be memory leaks.

In @formily/reactive, we mainly use the following APIs to create reactions:

- autorun creates an automatically executed responder
- reaction creates a responder that can implement dirty checks
- Tracker creates a dependency tracker that requires users to manually perform tracking

## Computed

Computed is also a relatively important concept in the reactive programming model. In one sentence, **computed is a Reaction that can cache calculation results**

Its caching strategy is: as long as the observable data that the computed function relies on changes, the function will re-execute the calculation, otherwise the cached result will always be read

The requirement here is that the computed function must be a pure function. The internally dependent data is either observable data or external constant data. If it is external variable data (non-observable), then if the external variable data changes, the computed will not be re-executed computational.

## Batch

As mentioned earlier, @formily/reactive is a reactive programming model based on Proxy hijacking. Therefore, any atomic operation will trigger the execution of Reaction, which is obviously a waste of computing resources. For example, we have a function for multiple observables. Property to operate:

```ts
import { observable, autorun } from '@formily/reactive'
const obs = observable({})
const handler = () => {
  obs.aa = 123
  obs.bb = 321
}

autorun(() => {
  console.log(obs.aa, obs.bb)
})

handler()
```

This will execute 3 prints, autorun is executed once by default, plus the assignment of obs.aa is executed once, and the assignment of obs.bb is executed once. If there are more atomic operations, the number of executions will be more. Therefore, we recommend using batch mode To merge the updates:

```ts
import { observable, autorun, batch } from '@formily/reactive'
const obs = observable({})
const handler = () => {
  obs.aa = 123
  obs.bb = 321
}

autorun(() => {
  console.log(obs.aa, obs.bb)
})

batch(() => {
  handler()
})
```

Of course, we can also use action for high-level packaging:

```ts
import { observable, autorun, action } from '@formily/reactive'
const obs = observable({})
const handler = action.bound(() => {
  obs.aa = 123
  obs.bb = 321
})

autorun(() => {
  console.log(obs.aa, obs.bb)
})

handler()
```

The final number of executions is 2 times, even if there are more operations inside the handler, it is still 2 times
</file>

<file path="packages/reactive/docs/guide/concept.zh-CN.md">
# 核心概念

## Observable

observable 是响应式编程模型中最重要的一块，它的核心概念就是：

一个 observable 对象，字面意思是可订阅对象，**我们通过创建一个可订阅对象，在每次操作该对象的属性数据的过程中，会自动通知订阅者**，@formily/reactive 创建 observable 对象主要是通过 ES Proxy 来创建的，它可以做到完美劫持数据操作

我们在@formily/reactive 中主要用以下几个 API 来创建 observable 对象：

- observable 函数创建深度 observable 对象
  - observable.deep 函数创建深劫持 observable 对象
  - observable.shallow 函数创建浅劫持 observable 对象
  - observable.computed 函数创建缓存计算器
  - observable.box 函数创建带 get/set 方法的 observable 对象
  - observable.ref 函数创建引用级 observable 对象
- define 函数定义 observable 领域模型，可以组合 observable 函数与其静态属性(比如 observable.computed)函数完成领域模型的定义
- model 函数定义自动 observable 领域模型，它会将 getter setter 属性包装为 computed 计算属性，将函数包装为 action，将其他数据属性用 observable 包装(注意这里是深劫持)

## Reaction

reaction 在响应式编程模型中，它就相当于是可订阅对象的订阅者，它接收一个 tracker 函数，这个函数在执行的时候，如果函数内部有对 observable 对象中的某个属性进行**读操作**(依赖收集)，那当前 reaction 就会与该属性进行一个绑定(依赖追踪)，直到该属性在其他地方发生了**写操作**，就会触发 tracker 函数重复执行，用一张图表示：

![](https://img.alicdn.com/imgextra/i4/O1CN01DQMGUL22mFICDsKfY_!!6000000007162-2-tps-1234-614.png)

可以看到从订阅到派发订阅，其实是一个封闭的循环状态机，每次 tracker 函数执行的时候都会重新收集依赖，依赖变化时又会重新触发 tracker 执行。所以，如果一旦我们不想再订阅 reaction 了，一定要手动 dispose，否则会内存泄漏。

在@formily/reactive 中的我们主要是使用以下几个 API 来创建 reaction:

- autorun 创建一个自动执行的响应器
- reaction 创建一个可以实现脏检查的响应器
- Tracker 创建一个依赖追踪器，需要用户手动执行追踪

## Computed

computed 在响应式编程模型中也是属于一个比较重要的概念，一句话表达的话，**computed 是一个可以缓存计算结果的 Reaction**

它的缓存策略是：只要 computed 函数内部所依赖的 observable 数据发生变化，函数才会重新执行计算，否则永远读取缓存结果

这里要求的就是 computed 函数必须是纯函数，内部依赖的数据要么是 observable 数据，要么是外部常量数据，如果是外部变量数据(非 observable)，那如果外部变量数据发生变化，computed 是不会重新执行计算的。

## Batch

前面有讲到@formily/reactive 是基于 Proxy 劫持来实现的响应式编程模型，所以任何一个原子操作都会触发 Reaction 执行，这样明显是浪费了计算资源的，比如我们有一个函数内部是对多个 observable 属性进行操作的：

```ts
import { observable, autorun } from '@formily/reactive'
const obs = observable({})
const handler = () => {
  obs.aa = 123
  obs.bb = 321
}

autorun(() => {
  console.log(obs.aa, obs.bb)
})

handler()
```

这样就会执行 3 次打印，autorun 默认执行一次，加上 obs.aa 赋值执行一次，obs.bb 赋值执行一次，如果原子操作更多一些，那执行次数会更多，所以，我们推荐使用 batch 模式，将更新进行合并：

```ts
import { observable, autorun, batch } from '@formily/reactive'
const obs = observable({})
const handler = () => {
  obs.aa = 123
  obs.bb = 321
}

autorun(() => {
  console.log(obs.aa, obs.bb)
})

batch(() => {
  handler()
})
```

当然，我们也可以使用 action 进行高阶包装：

```ts
import { observable, autorun, action } from '@formily/reactive'
const obs = observable({})
const handler = action.bound(() => {
  obs.aa = 123
  obs.bb = 321
})

autorun(() => {
  console.log(obs.aa, obs.bb)
})

handler()
```

最终执行次数就是 2 次了，即便 handler 内部的操作再多也还是 2 次
</file>

<file path="packages/reactive/docs/guide/index.md">
# Introduction

The core idea of @formily/reactive is to refer to [Mobx](https://mobx.js.org/), so why reinvent the wheel?

There are four main reasons:

- mobx does not support dependency collection within actions
- The observable function of mobx does not support filtering special objects such as react node, moment, and immutable
- mobx's observable function will automatically turn the function into action
- The observer of mobx-react-lite does not support React concurrent rendering

For the above reasons, Formily had to reinvent the wheel, but the wheel strongly relies on Proxy, that is, it does not support IE browser. Of course, reinventing the wheel also has its advantages:

- More controllability, you can do more in-depth optimization and customization for formily scenes
- Regardless of the historical burden of Mobx, the code can be cleaner
- If the Mobx version is Break Change or there are security vulnerabilities, it will have no impact on Formily
</file>

<file path="packages/reactive/docs/guide/index.zh-CN.md">
# 介绍

@formily/reactive 的核心思想是参考 [Mobx](https://mobx.js.org/) 的，那为什么要重新造轮子呢？

主要有 4 点原因：

- mobx 不支持 action 内部进行依赖收集
- mobx 的 observable 函数不支持过滤 react node,moment,immutable 之类的特殊对象
- mobx 的 observable 函数会自动将函数变成 action
- mobx-react-lite 的 observer 不支持 React 并发渲染

基于以上原因，formily 不得不重新造轮子，不过该轮子是强依赖 Proxy 的，也就是不支持 IE 浏览器，当然，重新造轮子也有它的好处：

- 把控性更强，可以为 formily 场景做更深的优化定制
- 不用考虑 Mobx 的历史包袱，代码可以更干净
- 如果 Mobx 版本 Break Change 或者存在安全漏洞，对 Formily 无影响
</file>

<file path="packages/reactive/docs/index.md">
---
title: Formily-Alibaba unified front-end form solution
order: 10
hero:
  title: Reactive Library
  desc: DDD-oriented Responsive State Management Solution
  actions:
    - text: Home Site
      link: //formilyjs.org
    - text: Document
      link: /guide
features:
  - icon: https://img.alicdn.com/imgextra/i1/O1CN01bHdrZJ1rEOESvXEi5_!!6000000005599-55-tps-800-800.svg
    title: High Performance
    desc: Efficient update, Demand rendering
  - icon: https://img.alicdn.com/imgextra/i2/O1CN01YqmcpN1tDalwgyHBH_!!6000000005868-55-tps-800-800.svg
    title: Zero Dependencies
    desc: Cross Device,Cross Framework
  - icon: https://img.alicdn.com/imgextra/i4/O1CN01u6jHgs1ZMwXpjAYnh_!!6000000003181-55-tps-800-800.svg
    title: Smart Tips
    desc: Embrace Typescript
footer: Open-source MIT Licensed | Copyright © 2019-present<br />Powered by self
---

## Installation

```bash
$ npm install --save @formily/reactive

```

## Quick start

```tsx
/**
 * defaultShowCode: true
 */
import React from 'react'
import { observable } from '@formily/reactive'
import { observer } from '@formily/reactive-react'

const obs = observable({
  value: 'Hello world',
})

export default observer(() => {
  return (
    <div>
      <div>
        <input
          style={{
            height: 28,
            padding: '0 8px',
            border: '2px solid #888',
            borderRadius: 3,
          }}
          value={obs.value}
          onChange={(e) => {
            obs.value = e.target.value
          }}
        />
      </div>
      <div>{obs.value}</div>
    </div>
  )
})
```
</file>

<file path="packages/reactive/docs/index.zh-CN.md">
---
title: Formily - 阿里巴巴统一前端表单解决方案
order: 10
hero:
  title: Reactive Library
  desc: 面向DDD的响应式状态管理方案
  actions:
    - text: 主站文档
      link: //formilyjs.org
    - text: 开发指南
      link: /zh-CN/guide
features:
  - icon: https://img.alicdn.com/imgextra/i1/O1CN01bHdrZJ1rEOESvXEi5_!!6000000005599-55-tps-800-800.svg
    title: 超高性能
    desc: 依赖追踪，高效更新，按需渲染
  - icon: https://img.alicdn.com/imgextra/i2/O1CN01YqmcpN1tDalwgyHBH_!!6000000005868-55-tps-800-800.svg
    title: 跨终端，跨框架
    desc: UI无关，框架无关
  - icon: https://img.alicdn.com/imgextra/i4/O1CN01u6jHgs1ZMwXpjAYnh_!!6000000003181-55-tps-800-800.svg
    title: 智能提示
    desc: 拥抱Typescript
footer: Open-source MIT Licensed | Copyright © 2019-present<br />Powered by self
---

## 安装

```bash
$ npm install --save @formily/reactive

```

## 快速开始

```tsx
/**
 * defaultShowCode: true
 */
import React from 'react'
import { observable } from '@formily/reactive'
import { observer } from '@formily/reactive-react'

const obs = observable({
  value: 'Hello world',
})

export default observer(() => {
  return (
    <div>
      <div>
        <input
          style={{
            height: 28,
            padding: '0 8px',
            border: '2px solid #888',
            borderRadius: 3,
          }}
          value={obs.value}
          onChange={(e) => {
            obs.value = e.target.value
          }}
        />
      </div>
      <div>{obs.value}</div>
    </div>
  )
})
```
</file>

</files>
